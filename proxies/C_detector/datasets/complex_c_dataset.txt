#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/icmp.h>
#include <linux/netdevice.h>
#include <linux/inet.h>
#include "fw.h"
#include <linux/klist.h>
#include <linux/jiffies.h> // For timestamp in jiffies
#include <linux/slab.h> // For kmalloc and kfree
#include <linux/fs.h>
#include <linux/device.h>
#include <net/checksum.h>
#include <linux/tcp.h>
#include <linux/ip.h>
#include <net/ip.h>
#include <net/tcp.h>


MODULE_LICENSE("GPL");
MODULE_AUTHOR("Razaq");
MODULE_DESCRIPTION("Stateful Firewall");
MODULE_VERSION("1");

static int major_number;
static struct class* sysfs_class = NULL;
static struct device* sysfs_device = NULL;
struct device *log_device;
struct device *conns_device;
struct device *mitm_device;

// Define packet_log struct
struct packet_log {
    log_row_t log_object;       // The log entry object
    struct klist_node node;     // Node for inclusion in the klist
};

// Define connection_row struct for connections_table
typedef struct{
    connection_rule_t connection_rule_srv;       
    connection_rule_t connection_rule_cli;       
    struct klist_node node;
} connection_rule_row;

// Define the static klist for packet logs
static struct klist packet_logs = KLIST_INIT(packet_logs, NULL, NULL);
static int logs_num = 0;


// Define the static klist for packet logs
static struct klist connections_table = KLIST_INIT(connections_table, NULL, NULL);

// Netfilter hooks for relevant packet phases
static struct nf_hook_ops netfilter_ops_fw;
static struct nf_hook_ops netfilter_ops_fw_local_out;

static int RULES_COUNT = 0;
static rule_t* FW_RULES;

void print_tcp_packet(struct sk_buff *skb) {
    struct iphdr *iph;
    struct tcphdr *tcph;

    // Ensure the skb is valid and contains an IP header
    if (!skb)
        return;

    iph = ip_hdr(skb);
    if (!iph || iph->protocol != PROT_TCP) {
        pr_info("Not a TCP packet\n");
        return;
    }

    // Get the TCP header
    tcph = tcp_hdr(skb);
    if (!tcph) {
        pr_info("TCP header is NULL\n");
        return;
    }

    // Print source and destination IP addresses
    pr_info("Source IP: %pI4\n", &iph->saddr);
    pr_info("Destination IP: %pI4\n", &iph->daddr);

    // Print source and destination ports
    pr_info("Source Port: %u\n", ntohs(tcph->source));
    pr_info("Destination Port: %u\n", ntohs(tcph->dest));

    // Print TCP flags
    pr_info("TCP Flags: [");
    if (tcph->fin)
        pr_cont("FIN ");
    if (tcph->syn)
        pr_cont("SYN ");
    if (tcph->rst)
        pr_cont("RST ");
    if (tcph->psh)
        pr_cont("PSH ");
    if (tcph->ack)
        pr_cont("ACK ");
    if (tcph->urg)
        pr_cont("URG ");
    if (tcph->ece)
        pr_cont("ECE ");
    if (tcph->cwr)
        pr_cont("CWR ");
    pr_cont("]\n");
}


void print_tcp_data(const tcp_data_t *data) {
    if (!data) {
        pr_err("[tcp_data_t] Null pointer provided.\n");
        return;
    }

    pr_info("[tcp_data_t]\n");
    pr_info("Source Port: %u\n", ntohs(data->src_port));
    pr_info("Destination Port: %u\n", ntohs(data->dst_port));

    pr_info("ACK: %s\n", (data->ack == ACK_NO) ? "NO" : (data->ack == ACK_YES) ? "YES" : "ANY");
    pr_info("SYN: %s\n", (data->syn == SYN_NO) ? "NO" : (data->syn == SYN_YES) ? "YES" : "ANY");
    pr_info("FIN: %s\n", (data->fin == FIN_NO) ? "NO" : (data->fin == FIN_YES) ? "YES" : "ANY");
    pr_info("RST: %s\n", (data->rst == RST_NO) ? "NO" : (data->rst == RST_YES) ? "YES" : "ANY");
}

static void print_packet_identifier(const packet_identifier_t *pkt)
{
    char src_ip[16];
    char dst_ip[16];

    // Convert the source and destination IPs to human-readable strings
    snprintf(src_ip, sizeof(src_ip), "%pI4", &pkt->src_ip);
    snprintf(dst_ip, sizeof(dst_ip), "%pI4", &pkt->dst_ip);

    // Log the packet identifier details
    printk(KERN_INFO "Packet Identifier:\n");
    printk(KERN_INFO "  Source IP: %s\n", src_ip);
    printk(KERN_INFO "  Destination IP: %s\n", dst_ip);
    printk(KERN_INFO "  Source Port: %u\n", ntohs(pkt->src_port));
    printk(KERN_INFO "  Destination Port: %u\n", ntohs(pkt->dst_port));
}

static direction_t get_direction_incoming(const struct nf_hook_state *state) {
    return strcmp(state->in->name, IN_NET_DEVICE_NAME) == 0 ? DIRECTION_IN : DIRECTION_OUT;
}

static direction_t get_direction_outgoing(const struct nf_hook_state *state) {
    return strcmp(state->out->name, IN_NET_DEVICE_NAME) == 0 ? DIRECTION_OUT : DIRECTION_IN;
}

static int is_active_connection (connection_rule_row* rule){
    return ((rule->connection_rule_cli.state != STATE_CLOSED) || (rule->connection_rule_srv.state != STATE_CLOSED) );
}

static __be32 ip_string_to_be32(const char *ip_string)
{
    __be32 ip_32be = 0; // Initialize to 0 (error indicator)

    if (!ip_string || ip_string[0] == '\0') {
        pr_err("ip_string_to_be32: Invalid input (NULL or empty string).\n");
        return 0; // Return 0 to indicate an error
    }

    if (!in4_pton(ip_string, -1, (u8 *)&ip_32be, '\0', NULL)) {
        pr_err("ip_string_to_be32: Failed to parse IP string: %s\n", ip_string);
        return 0; // Return 0 to indicate an error
    }

    return ip_32be; // Return the converted __be32 value
}

static log_row_t init_log_entry(packet_identifier_t packet_identifier, __u8 protocol) {
	log_row_t log_entry;

	// Initialize the log entry fields
	log_entry.timestamp = jiffies;            // Use jiffies as the timestamp
	log_entry.protocol = protocol;           // Protocol passed to the function
	log_entry.src_ip = packet_identifier.src_ip; // Source IP from the packet identifier
	log_entry.dst_ip = packet_identifier.dst_ip; // Destination IP from the packet identifier
	log_entry.src_port = packet_identifier.src_port; // Source port
	log_entry.dst_port = packet_identifier.dst_port; // Destination port
	log_entry.action = 0;                    // Default action (can be updated later)
	log_entry.reason = 0;                    // Default reason (can be updated later)
	log_entry.count = 1;                     // Initialize count to 1
    log_entry.ignore = 0;

	return log_entry;
}


int compare_packets(packet_identifier_t p1, packet_identifier_t p2){
    return (p1.src_ip == p2.src_ip && 
    p1.dst_ip == p2.dst_ip && 
    p1.src_port == p2.src_port && 
    p1.src_port == p2.src_port && 
    p1.dst_port == p2.dst_port && 
    p1.src_port == p2.src_port);
}

// Display_rules the rules
ssize_t display_rules(struct device *dev, struct device_attribute *attr, char *buf) 
{
    int i;
    int len = 0; // Tracks the total length written into the buffer

    // Iterate over each rule and append its details to the buffer
    for (i = 0; i < RULES_COUNT; i++) {
        rule_t *rule = &FW_RULES[i];
        // Add each field of the rule in a readable format
        len += scnprintf(buf + len, PAGE_SIZE - len,
                         "%s %d %pI4/%d %pI4/%d %d %d %d %d %d\n",
                         rule->rule_name,
                         rule->direction,
                         &rule->src_ip, rule->src_prefix_size,
                         &rule->dst_ip, rule->dst_prefix_size,
                         rule->protocol,
                         rule->src_port,
                         rule->dst_port,
                         rule->ack,
                         rule->action);
        // Check if the buffer is full
        if (len >= PAGE_SIZE)
            break;
    }

    return len;
}


int convert_src_port(const char *src_port_str, __be16 *network_port) {
    int src_port;
    int ret;

    // Convert string to integer
    ret = kstrtoint(src_port_str, 10, &src_port);
    if (ret) {
        printk(KERN_ERR "Invalid src_port string: %s\n", src_port_str);
        return -EINVAL;  // Invalid argument
    }

    // Check for valid port range (1-65535)
    if (src_port < 1 || src_port > 65535) {
        printk(KERN_ERR "Port out of range: %d\n", src_port);
        return -ERANGE;
    }

    // Convert to network byte order
    *network_port = htons((uint16_t)src_port);

    return 0;
}
// Helper function to parse IP/prefix into IP, mask, and size
static int parse_ip_prefix(const char *ip_prefix, __be32 *ip, __be32 *mask, __u8 *prefix_size) {
    char ip_str[16];
    int prefix;
    if(strcmp(ip_prefix, "any") == 0){
        *prefix_size = (__u8)0;
        *mask = (IP_ANY);
        *ip = (IP_ANY);
    } else {
        if (sscanf(ip_prefix, "%15[^/]/%d", ip_str, &prefix) != 2) {
            return -EINVAL; // Invalid input
        }

        *prefix_size = (__u8)prefix;
        *mask = htonl(~0 << (32 - prefix));
        *ip = in_aton(ip_str);
    }

    return 0;
}

size_t get_rules_number(const char *buf, size_t count) {
    size_t rows = 0;
    size_t i;

    // Count the number of rows based on newline characters
    for (i = 0; i < count; i++) {
        if (buf[i] == '\n') {
            rows++;
        }
    }
    return rows + 1;
}


static int parse_rule(const char *rule_str, rule_t *rule) {
    char src_ip_prefix[32], dst_ip_prefix[32], src_port_str[10], dst_port_str[10];
    char direction_str[10], protocol_str[10], ack_str[10], action_str[10];
    int successful_scans = sscanf(rule_str, "%19s %9s %31s %31s %9s %9s %9s %9s %9s",
               rule->rule_name, direction_str, src_ip_prefix, dst_ip_prefix,
               protocol_str, src_port_str, dst_port_str, ack_str, action_str);
    if (successful_scans != 9) {
                    printk(KERN_ALERT "Invalid rule string - Parsed  %d/9 fields", successful_scans);
                    printk(KERN_INFO "String: %s.\n", rule_str);
        return -EINVAL;
    }

    // Parse direction
    if (strcmp(direction_str, "in") == 0) {
        rule->direction = DIRECTION_IN;
    } else if (strcmp(direction_str, "out") == 0) {
        rule->direction = DIRECTION_OUT;
    } else if(strcmp(direction_str, "any") == 0){
        rule->direction = DIRECTION_ANY;
    } else {
        printk(KERN_CRIT "ERROR IN Direction");
        return -EINVAL;
    }

    // Parse IP prefixes
    if (parse_ip_prefix(src_ip_prefix, &rule->src_ip, &rule->src_prefix_mask, &rule->src_prefix_size) < 0 ||
        parse_ip_prefix(dst_ip_prefix, &rule->dst_ip, &rule->dst_prefix_mask, &rule->dst_prefix_size) < 0) {
        printk(KERN_CRIT "ERROR IN Rule Parsing IP Prefix.");
        return -EINVAL;
    }

    // Parse ports
    if (strcmp(protocol_str, "any") == 0) {
        rule->protocol = PROT_ANY;
    } else if (strcmp(protocol_str, "TCP") == 0) {
        rule->protocol = PROT_TCP;
    } else if (strcmp(protocol_str, "UDP") == 0) {
        rule->protocol = PROT_UDP;
    } else if (strcmp(protocol_str, "ICMP") == 0) {
        rule->protocol = PROT_ICMP;
    } else {
        // Undefined behaviour in the assignemnet
        printk(KERN_CRIT "ERROR IN Rule Protocol.");
        rule->protocol = -EINVAL;;
    }

    if (strcmp(src_port_str, "any") == 0) {
        rule->src_port = PORT_ANY;
    } else if (strcmp(src_port_str, ">1023") == 0){
        rule->src_port = PORT_ABOVE_1023;
    } else {
        if (convert_src_port(src_port_str, &rule->src_port) != 0){
            printk(KERN_CRIT "Error in provided rule port: %s", src_port_str);
            return -EINVAL;
        }
    }

    if (strcmp(dst_port_str, "any") == 0) {
        rule->dst_port = PORT_ANY;
    } else if (strcmp(dst_port_str, ">1023") == 0){
        rule->dst_port = PORT_ABOVE_1023;
    } else {
        if (convert_src_port(dst_port_str, &rule->dst_port) != 0){
            printk(KERN_CRIT "Error in provided rule port: %s", dst_port_str);
            return -EINVAL;
        }
    }

    // Parse ACK
    if (strcmp(ack_str, "yes") == 0) {
        rule->ack = ACK_YES;
    } else if (strcmp(ack_str, "no") == 0) {
        rule->ack = ACK_NO;
    } else if (strcmp(ack_str, "any") == 0) {
        rule->ack = ACK_ANY;
    } else {
        printk(KERN_CRIT "ERROR IN Rule ACK Bit.");
        return -EINVAL;;
    }

    // Parse action
    if (strcmp(action_str, "accept") == 0) {
        rule->action = NF_ACCEPT;
    } else if (strcmp(action_str, "drop") == 0) {
        rule->action = NF_DROP;
    } else {
        printk(KERN_CRIT "ERROR IN Rule Decision.");
        return -EINVAL;
    }

    return 0;
}



// Modify_rules the rules 
ssize_t modify_rules(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
    char *rules_str, *tmp_rules_str, *line;
    int i = 0;
    int num_of_rules = get_rules_number(buf, count);
    static DEFINE_MUTEX(rules_mutex);

    // Allocate FW_RULES
    FW_RULES = kmalloc_array(num_of_rules, sizeof(rule_t), GFP_KERNEL);
    if (!FW_RULES) {
        printk(KERN_ALERT "Memory allocation failed for FW_RULES.\n");
        return -ENOMEM;
    }

    // Allocate memory for rules_str
    rules_str = kmalloc(count + 1, GFP_KERNEL);
    if (!rules_str) {
        kfree(FW_RULES);  // Free FW_RULES if rules_str allocation fails
        return -ENOMEM;
    }

    strncpy(rules_str, buf, count);
    rules_str[count] = '\0';
    tmp_rules_str = rules_str;

    mutex_lock(&rules_mutex);  // Protect critical section

    for (line = strsep(&tmp_rules_str, "\n"); line != NULL; line = strsep(&tmp_rules_str, "\n")) {
        if (i > num_of_rules) {
            printk(KERN_ALERT "Rule count exceeded allocated space.\n");
            break;
        }
        if (*line == '\0') continue;
        if (parse_rule(line, &FW_RULES[i]) < 0) {
            printk(KERN_ALERT "ERROR IN Rule Parsing.");
            printk(KERN_ALERT "Terminating ...");
            kfree(FW_RULES);
            RULES_COUNT = 0;
            kfree(rules_str);
            mutex_unlock(&rules_mutex);
            return -EINVAL;
        }
        i++;
    }

    RULES_COUNT = i;

    kfree(rules_str);
    mutex_unlock(&rules_mutex);

    return count;
}

// Reset the logs
ssize_t reset_logs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
    struct klist_iter iter;
    struct packet_log *plog;
    struct klist_node *knode;

    // Initialize the iterator
    klist_iter_init(&packet_logs, &iter);

    // Iterate over the klist and remove each node
    while ((knode = klist_next(&iter)))
    {
        plog = container_of(knode, struct packet_log, node);
        klist_del(&plog->node);
        // Free the memory of the container structure
        kfree(plog);
    }

    klist_iter_exit(&iter);
    logs_num = 0;
    printk(KERN_INFO "Packet logs have been reset.\n");
    return count;
}


// Read the logs
ssize_t read_logs(struct file *filp, char __user *user_buf, size_t count, loff_t *f_pos)
{
    char *kernel_buf;
    size_t buf_size = 4096; // Allocate a buffer large enough to hold logs
    size_t offset = 0;
    struct klist_iter iter;
    struct packet_log *plog;
    struct klist_node *knode;
    char log_entry[256]; // Temporary buffer for each log entry
    int written;
    log_row_t *log;

    // Allocate kernel buffer
    kernel_buf = kmalloc(buf_size, GFP_KERNEL);
    if (!kernel_buf)
        return -ENOMEM;

    // Initialize the klist iterator
    klist_iter_init(&packet_logs, &iter);

    // Iterate over the klist
    while ((knode = klist_next(&iter)))
    {
        plog = container_of(knode, struct packet_log, node);
        log = &plog->log_object;

        // Format the log entry
        written = snprintf(log_entry, sizeof(log_entry), "%lu %pI4 %pI4 %u %u %u %u %d %u\n",
                           log->timestamp,
                           &log->src_ip, &log->dst_ip,
                           log->src_port, log->dst_port,
                           log->protocol, log->action, log->reason, log->count);

        // Check if we have enough space in the buffer
        if (offset + written >= buf_size)
            break;

        // Copy the formatted log entry into the kernel buffer
        strncpy(kernel_buf + offset, log_entry, written);
        offset += written;
    }

    // Finalize the klist iterator
    klist_iter_exit(&iter);

    // Check if there's anything to read based on *f_pos
    if (*f_pos >= offset)
    {
        kfree(kernel_buf);
        return 0; // EOF
    }

    // Copy data to user space, starting from *f_pos
    written = min(count, offset - *f_pos);
    if (copy_to_user(user_buf, kernel_buf + *f_pos, written))
    {
        kfree(kernel_buf);
        return -EFAULT;
    }

    // Update the file position
    *f_pos += written;

    // Free kernel buffer
    kfree(kernel_buf);

    return written;
}

void print_packet_logs(void) {
    struct klist_iter iter;
    struct klist_node *knode;
    struct packet_log *entry;

    printk(KERN_INFO "=== Printing Packet Logs ===\n");

    // Initialize the iterator for the klist
    klist_iter_init(&packet_logs, &iter);

    // Iterate over the klist
    while ((knode = klist_next(&iter))) {
        // Retrieve the parent structure from the node
        entry = container_of(knode, struct packet_log, node);

        // Print the log object details
        printk(KERN_INFO
               "Log Entry: Timestamp=%lu, Protocol=%u, Action=%u, "
               "Src_IP=%pI4, Dst_IP=%pI4, Src_Port=%u, Dst_Port=%u, "
               "Reason=%u, Count=%u\n",
               entry->log_object.timestamp,
               entry->log_object.protocol,
               entry->log_object.action,
               &entry->log_object.src_ip,
               &entry->log_object.dst_ip,
               ntohs(entry->log_object.src_port),
               ntohs(entry->log_object.dst_port),
               entry->log_object.reason,
               entry->log_object.count);
    }

    // Exit the iterator
    klist_iter_exit(&iter);

    printk(KERN_INFO "=== End of Packet Logs ===\n");
}

void print_connection(  connection_rule_row *entry){
            printk(KERN_INFO
               "Src_IP=%pI4, Dst_IP=%pI4, Src_Port=%u, Dst_Port=%u, MITM_Proc_port=%u "
               "State=%u",
               &entry->connection_rule_srv.packet.src_ip,
               &entry->connection_rule_srv.packet.dst_ip,
               ntohs(entry->connection_rule_srv.packet.src_port),
               ntohs(entry->connection_rule_srv.packet.dst_port),
               ntohs(entry->connection_rule_srv.mitm_proc_port),
               entry->connection_rule_srv.state);
            printk(KERN_INFO
               "Src_IP=%pI4, Dst_IP=%pI4, Src_Port=%u, Dst_Port=%u, MITM_Proc_port=%u"
               "State=%u",
               &entry->connection_rule_cli.packet.src_ip,
               &entry->connection_rule_cli.packet.dst_ip,
               ntohs(entry->connection_rule_cli.packet.src_port),
               ntohs(entry->connection_rule_cli.packet.dst_port),
               ntohs(entry->connection_rule_cli.mitm_proc_port),
               entry->connection_rule_cli.state);
}

void print_connections_table(void) {
    struct klist_iter iter;
    struct klist_node *knode;
     connection_rule_row *entry;

    printk(KERN_INFO "=== Printing Connecitnos Table Logs ===\n");

    // Initialize the iterator for the klist
    klist_iter_init(&connections_table, &iter);

    // Iterate over the klist
    while ((knode = klist_next(&iter))) {
        entry = container_of(knode,  connection_rule_row, node);
        print_connection(entry);
    }

    // Exit the iterator
    klist_iter_exit(&iter);

    printk(KERN_INFO "=== End of Connectinos Table ===\n");
}


static ssize_t read_connections_table(struct device *dev, struct device_attribute *attr, char *buf) {
    struct klist_iter iter;
    struct klist_node *knode;
     connection_rule_row *entry;
    size_t offset = 0;
    char temp_buffer[128];
    ssize_t len;

    klist_iter_init(&connections_table, &iter);

    while ((knode = klist_next(&iter)) != NULL) {
        entry = container_of(knode,  connection_rule_row, node);
        len = snprintf(temp_buffer, sizeof(temp_buffer),
                       "%pI4,%u,%pI4,%u,%u,%u\n",
                       &entry->connection_rule_srv.packet.src_ip,
                       ntohs(entry->connection_rule_srv.packet.src_port),
                       &entry->connection_rule_srv.packet.dst_ip,
                       ntohs(entry->connection_rule_srv.packet.dst_port),
                       ntohs(entry->connection_rule_srv.mitm_proc_port),
                       entry->connection_rule_srv.state);

        if (len < 0 || offset + len >= PAGE_SIZE) {
            break;
        }

        memcpy(buf + offset, temp_buffer, len);
        offset += len;

        len = snprintf(temp_buffer, sizeof(temp_buffer),
                       "%pI4,%u,%pI4,%u,%u,%u\n",
                       &entry->connection_rule_cli.packet.src_ip,
                       ntohs(entry->connection_rule_cli.packet.src_port),
                       &entry->connection_rule_cli.packet.dst_ip,
                       ntohs(entry->connection_rule_cli.packet.dst_port),
                       ntohs(entry->connection_rule_cli.mitm_proc_port),
                       entry->connection_rule_cli.state);

        if (len < 0 || offset + len >= PAGE_SIZE) {
            break;
        }

        memcpy(buf + offset, temp_buffer, len);
        offset += len;
    }

    klist_iter_exit(&iter);

    return offset;
}




void add_or_update_log_entry(log_row_t *new_entry) {
    struct klist_iter iter;
    struct klist_node *knode;
    struct packet_log *existing_entry;
    int found = 0;

    if (new_entry->ignore) return;

    // Initialize an iterator for the klist
    klist_iter_init(&packet_logs, &iter);

    // Iterate over the klist to find a matching entry
    while ((knode = klist_next(&iter))) {
        existing_entry = container_of(knode, struct packet_log, node);

        // Check if the existing entry matches the new_entry's fields
        if (existing_entry->log_object.src_ip == new_entry->src_ip &&
            existing_entry->log_object.dst_ip == new_entry->dst_ip &&
            existing_entry->log_object.src_port == new_entry->src_port &&
            existing_entry->log_object.dst_port == new_entry->dst_port &&
            existing_entry->log_object.protocol == new_entry->protocol && 
            existing_entry->log_object.action == new_entry->action) {
            
            // Match found: update timestamp and increment count
            existing_entry->log_object.timestamp = new_entry->timestamp;
            existing_entry->log_object.count++;
            found = 1;
            break;
        }
    }

    // Exit the iterator
    klist_iter_exit(&iter);

    if (!found) {
        // No match found: create a new entry and add it to the klist
        struct packet_log *new_log = kmalloc(sizeof(struct packet_log), GFP_KERNEL);
        if (!new_log)
            return; // Handle memory allocation failure

        // Copy the new_entry into the new log_object
        memcpy(&new_log->log_object, new_entry, sizeof(log_row_t));

        // Add the new log entry to the klist
        klist_add_tail(&new_log->node, &packet_logs);
        logs_num += 1;
    }
}

static tcp_data_t* get_tcp_data(struct sk_buff *skb) {
    struct tcphdr *tcph;
    tcp_data_t* tcp_data;

    // Allocate memory for tcp_data
    tcp_data = kmalloc(sizeof(tcp_data_t), GFP_KERNEL);
    if (!tcp_data) {
        printk(KERN_ERR "@get_tcp_data Memory allocation failed\n");
        return NULL;
    }

    tcph = tcp_hdr(skb);
    if (!tcph){
        printk(KERN_ERR "@get_tcp_data Could not read TCP Header ");
        return NULL;
    }
    tcp_data->src_port = (tcph->source);
    tcp_data->dst_port = (tcph->dest);
    tcp_data->ack = (tcph->ack ? ACK_YES : ACK_NO);
    tcp_data->syn = (tcph->syn ? SYN_YES : SYN_NO);
    tcp_data->fin = (tcph->fin ? FIN_YES : FIN_NO);
    tcp_data->rst = (tcph->rst ? RST_YES : RST_NO);
    return tcp_data;
}


static  connection_rule_row *find_connection_row_by_proxy(packet_identifier_t* packet_identifier_local_out, __be16 mitm_proc_port, direction_t dir) {
    struct klist_iter iter;
    struct klist_node *knode;
    connection_rule_row *row;
    connection_rule_row *original_row = NULL;

    klist_iter_init(&connections_table, &iter);

    // Iterate over the klist to find a matching entry
    while ((knode = klist_next(&iter))) {
        row = container_of(knode,  connection_rule_row, node);
        if (dir == DIRECTION_IN){
            if (row->connection_rule_srv.mitm_proc_port == mitm_proc_port ||
                row->connection_rule_cli.mitm_proc_port == mitm_proc_port) {
                klist_iter_exit(&iter);
                original_row = row; 
                break;
            }
        } else if (dir == DIRECTION_OUT) {
            if (row->connection_rule_cli.packet.src_ip == packet_identifier_local_out->dst_ip &&
                row->connection_rule_cli.packet.src_port == packet_identifier_local_out->dst_port) {
                original_row = row;
                break;
            }
        }
    }

    klist_iter_exit(&iter);
    if (!original_row) {
        printk(KERN_ERR "Original packet not found");
        print_connections_table();
        print_packet_identifier(packet_identifier_local_out);
    }
    return original_row; // No match found
}

static void extract_transport_fields(struct sk_buff *skb, __u8 protocol, __be16 *src_port,
                                    __be16 *dst_port, __u8 *syn, __u8 *ack, __u8 *fin, __u8 *rst,
                                    int* is_christmas_packet) { 
    struct tcphdr *tcp_header;
    struct udphdr *udp_header;
    struct icmphdr *icmp_header;

    // Initialize output parameters
    *src_port = 0;
    *dst_port = 0;
    *ack = ACK_NO;
    *is_christmas_packet = 0; // Default to false

    // Extract transport-layer fields based on protocol
    if (protocol == PROT_TCP) {
        tcp_header = tcp_hdr(skb);
        if (tcp_header) {
            *src_port = (tcp_header->source);
            *dst_port = (tcp_header->dest);
            *ack = (tcp_header->ack ? ACK_YES : ACK_NO);
            *syn = (tcp_header->syn ? SYN_YES : SYN_NO);
            *fin = (tcp_header->fin ? FIN_YES : FIN_NO);
            *rst = (tcp_header->rst ? RST_YES : RST_NO);

            // Check if the packet is a Christmas tree packet
            if (tcp_header->fin && tcp_header->urg && tcp_header->psh) {
                *is_christmas_packet = 1; // Mark as true
            }
        }
    } else if (protocol == PROT_UDP) {
        udp_header = udp_hdr(skb);
        if (udp_header) {
            *src_port = (udp_header->source);
            *dst_port = (udp_header->dest);
        }
    } else if (protocol == PROT_ICMP) {
        icmp_header = icmp_hdr(skb);
        if (icmp_header) {
            *src_port = icmp_header->type; // Use type as src_port equivalent
            *dst_port = icmp_header->code; // Use code as dst_port equivalent
        }
    } else{

    }
}

static  connection_rule_row* find_connection_row(packet_identifier_t packet_identifier){
    struct klist_iter iter;
    struct klist_node *knode;
     connection_rule_row *existing_entry;
    int counter = 0;

    // Initialize an iterator for the klist
    klist_iter_init(&connections_table, &iter);

    // Iterate over the klist to find a matching entry
    while ((knode = klist_next(&iter))) {
        existing_entry = container_of(knode,  connection_rule_row, node);
        if (compare_packets(existing_entry->connection_rule_cli.packet, packet_identifier) ||
            compare_packets(existing_entry->connection_rule_srv.packet, packet_identifier)){
            return existing_entry;
        }
        counter++;
    }

    // Exit the iterator
    klist_iter_exit(&iter);
    return NULL;
}


static void reverse_packet_identifier(const packet_identifier_t *packet, packet_identifier_t *reversed) {
    reversed->src_ip = packet->dst_ip;
    reversed->dst_ip = packet->src_ip;
    reversed->src_port = packet->dst_port;
    reversed->dst_port = packet->src_port;
}

static int handle_restart_existing_connection(connection_rule_row* found_connection, packet_identifier_t packet_identifier) {
    int sender_client;
    if (is_active_connection(found_connection)) {
        printk(KERN_ERR "initiate_connection Error: Connection already exists.");
        return NF_DROP;
    } else {
        printk(KERN_ERR "initiate_connection: Restarting existing connection");
        sender_client = compare_packets(packet_identifier, found_connection->connection_rule_cli.packet);
        found_connection->connection_rule_cli.state = sender_client ? STATE_SYN_SENT: STATE_LISTEN;
        found_connection->connection_rule_srv.state = sender_client ? STATE_LISTEN: STATE_SYN_SENT;
        return NF_ACCEPT;
    }   
}

static int initiate_connection(packet_identifier_t packet_identifier) {
        connection_rule_row* found_connection = find_connection_row(packet_identifier);
        packet_identifier_t *reversed_packet_identifier;
        connection_rule_row *new_rule_sender;
        if (found_connection != NULL)
            return handle_restart_existing_connection(found_connection, packet_identifier);

        // Allocate memory for reversed_packet_identifier
        reversed_packet_identifier = kmalloc(sizeof(packet_identifier_t), GFP_KERNEL);
        if (!reversed_packet_identifier) {
            printk(KERN_ERR "Memory allocation failed for reversed_packet_identifier\n");
            return NF_DROP;
        }
        reverse_packet_identifier(&packet_identifier, reversed_packet_identifier);

        // Allocate memory for new_rule_sender and new_rule_reciever
        new_rule_sender = kmalloc(sizeof( connection_rule_row), GFP_KERNEL);
        if (!new_rule_sender) {
            printk(KERN_ERR "Memory allocation failed for new_rule_sender\n");
            kfree(reversed_packet_identifier);
            return NF_DROP;
        }

        // Initialize the state rules
        new_rule_sender->connection_rule_cli.state = STATE_SYN_SENT;
        new_rule_sender->connection_rule_srv.state = STATE_LISTEN;

        // Copy packet identifiers
        memcpy(&new_rule_sender->connection_rule_cli.packet, &packet_identifier, sizeof(packet_identifier_t));
        memcpy(&new_rule_sender->connection_rule_srv.packet, reversed_packet_identifier, sizeof(packet_identifier_t));

        // Free reversed_packet_identifier after use
        kfree(reversed_packet_identifier);

        klist_add_tail(&new_rule_sender->node, &connections_table);

    print_connections_table();
    return NF_ACCEPT;
}


static int comp_packet_to_static_rules(packet_identifier_t packet_identifier, __u8 protocol, __u8 ack, direction_t direction) {
    int i;
    for (i = 0; i < RULES_COUNT; i++) {
        rule_t *rule = &FW_RULES[i];
        // printk(KERN_CRIT "Comparing against %s", rule->rule_name);
        if (rule->direction != DIRECTION_ANY && rule->direction != direction){
            // printk(KERN_CRIT "Dropped at direction");
            continue;
        }
        if (rule->src_ip != IP_ANY && (packet_identifier.src_ip & rule->src_prefix_mask) != (rule->src_ip & rule->src_prefix_mask)){
            // printk(KERN_CRIT "Dropped at src_ip");
            continue;
        }
        if (rule->dst_ip != IP_ANY && (packet_identifier.dst_ip & rule->dst_prefix_mask) != (rule->dst_ip & rule->dst_prefix_mask)){
            // printk(KERN_CRIT "Dropped at dst_ip");
            continue;
        }
        if (rule->src_port != PORT_ANY && rule->src_port != packet_identifier.src_port){
            if (rule->src_port != PORT_ABOVE_1023){
                // printk(KERN_CRIT "Dropped at port src_port != PORT_ABOVE_1023");
                continue;
            }
            if (packet_identifier.src_port < 1023){
                // printk(KERN_CRIT "Dropped at port src_port < 1023");
                continue;
            }
        }
        if (rule->dst_port != PORT_ANY && rule->dst_port != packet_identifier.dst_port){
            if (rule->dst_port != PORT_ABOVE_1023){
                // printk(KERN_CRIT "Dropped at dst_port  != PORT_ABOVE_1023");
                continue;
            }
            if (packet_identifier.dst_port < 1023){
                // printk(KERN_CRIT "Dropped at dst_port  <1023");
                continue;
            }
        }
        if (rule->protocol != PROT_ANY && rule->protocol != protocol){
            // printk(KERN_CRIT "Dropped at protocol");
            continue;
        }
        if (protocol == PROT_TCP && rule->ack != ACK_ANY && rule->ack != ack){
            // printk(KERN_CRIT "Dropped at ack");
            continue;
        }
        return i;
    }
    return -1;
} 


static ssize_t modify_mitm_port(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
    char input[64]; // Buffer for user input
    char *token, *cur;
    struct klist_iter iter;
    struct klist_node *knode;
     connection_rule_row *row;
    int i = 0;
    packet_identifier_t packet_identifier;

    char cli_ip[16], srv_ip[16]; // Buffers for IP addresses
    int cli_port, srv_port, mitm_port;     // Variables for ports
    int ret;
    __be32 src_ip;

    // Check if the input starts with '#'
    if (buf[0] == '#') {
        printk(KERN_INFO "\n\n -- PORT COMMAND --\n");
        // Parse the input string according to the given format
        ret = sscanf(buf, "#%15[^,],%d,%15[^,],%d\n", cli_ip, &cli_port, srv_ip, &srv_port);
        if (ret != 4) { // Ensure all four values are parsed successfully
            pr_err("Invalid input format. Expected format: \"#{},{},{},{}\\n\"\n");
            return -EINVAL; // Return error if parsing fails
        }
        packet_identifier.dst_ip = ip_string_to_be32(cli_ip);
        packet_identifier.src_ip = ip_string_to_be32(srv_ip);
        packet_identifier.dst_port = htons(cli_port);
        packet_identifier.src_port = htons(srv_port);
        if(!initiate_connection(packet_identifier)){
                printk(KERN_ERR "Connection could not be intiated");
                return -EINVAL;
        } 
        print_packet_identifier(&packet_identifier);
        return count; // Indicate success
    }


    // Copy input for parsing
    if (count >= sizeof(input)) {
        pr_err("Input too long\n");
        return -EINVAL;
    }
    strncpy(input, buf, count);
    input[count] = '\0';

    // Parse user input
    cur = input;
    while ((token = strsep(&cur, ",")) != NULL) {
        if (i == 0)
            src_ip = ip_string_to_be32(token); // Convert IP string to __be32
        else if (i == 1)
            cli_port = htons(simple_strtoul(token, NULL, 10)); // Convert to __be16
        else if (i == 2)
            mitm_port = htons(simple_strtoul(token, NULL, 10)); // Convert to __be16
        else
            break;
        i++;
    }

    if (i != 3) {
        pr_err("Invalid input format. Expected: <src_ip>,<src_port>,<mitm_port>\n");
        return -EINVAL;
    }

    // Search for the matching rule in the connection table
    klist_iter_init(&connections_table, &iter);

    while ((knode = klist_next(&iter))) {
        row = container_of(knode,  connection_rule_row, node);
        if (row->connection_rule_cli.packet.src_ip == src_ip &&
            row->connection_rule_cli.packet.src_port == cli_port) {
            // Update the MITM port in the connection_rule_srv.packet
            row->connection_rule_srv.mitm_proc_port = mitm_port;
            pr_info("MITM port updated successfully: %pI4:%d -> %d\n",
                    &src_ip, ntohs(cli_port), ntohs(mitm_port));
            klist_iter_exit(&iter);
            return count; // Indicate success
        }
    }

    klist_iter_exit(&iter);
    printk(KERN_ERR "No matching connection rule found for: %pI4:%d\n", &src_ip, ntohs(srv_ip));
    return -ENOENT; // No entry found
}



static int handle_fin_state( connection_rule_row* connection, connection_rule_t* rule, 
                            int sender, int rule_owner, connection_rule_t* other_rule, __u8 ack, __u8 fin){
    int packet_sent = (sender == rule_owner);
    char* terminator = (sender == 0) ? "srv": "cli";
        switch (rule->state) {
            case STATE_ESTABLISHED:
                if (fin == FIN_YES && (packet_sent)) {
                    printk(KERN_INFO "%s terminating the session", terminator);
                    rule->state = STATE_FIN_WAIT_1;
                    print_connections_table();
                    return NF_ACCEPT;
                }
                if (fin == FIN_NO && packet_sent )
                {
                    printk(KERN_INFO "STATCE_MACHINE_%s: Accepting for Established -> Close_Wait", terminator);
                    rule->state = STATE_CLOSE_WAIT;
                    print_connections_table();
                    return NF_ACCEPT;
                }
                break;
            case STATE_FIN_WAIT_1:
                if (packet_sent) { // Handle simultanuous closing.....
                    printk(KERN_INFO "STATCE_MACHINE_%s: Accepting for Wait_1 -> Closing", terminator);
                    rule->state = STATE_CLOSING;
                    print_connections_table();
                    return NF_ACCEPT;
                }
                else if (fin == FIN_NO && !packet_sent  && (other_rule->state <= STATE_LAST_ACK)) {
                    printk(KERN_INFO "STATCE_MACHINE_%s: Accepting for Wait_1 -> Wait_2", terminator);
                    rule->state = STATE_FIN_WAIT_2;
                    print_connections_table();
                    return NF_ACCEPT;
                }
                else if (fin == FIN_NO && !packet_sent  && (other_rule->state > STATE_LAST_ACK)) {
                    printk(KERN_INFO "STATCE_MACHINE_%s: Accepting for Wait_1 -> CLOSED", terminator);
                    rule->state = STATE_CLOSED;
                    print_connections_table();
                    return NF_ACCEPT;
                }
                break;

            case STATE_FIN_WAIT_2:
                if (packet_sent) { // Received fin and responded with ack.
                    printk(KERN_INFO "STATCE_MACHINE_%s: Accepting for Wait_2 -> CLOSED", terminator);
                    rule->state = STATE_CLOSED;
                    print_connections_table();
                    return NF_ACCEPT;
                }
                break;

            case STATE_CLOSING:
                if (!packet_sent) {
                    printk(KERN_INFO "STATCE_MACHINE_%s: Accepting for Closing -> CLOSED", terminator);
                    rule->state = STATE_CLOSED;
                    print_connections_table();
                    return NF_ACCEPT;
                }
                break;
            case STATE_CLOSE_WAIT:
                if (fin == FIN_YES && packet_sent) { // Received fin and responded with ack.
                        printk(KERN_INFO "STATCE_MACHINE_%s: Accepting for Close_wait -> Last_ACK", terminator);
                        rule->state = STATE_LAST_ACK;
                        print_connections_table();
                        return NF_ACCEPT;
                    }
                    break;
            case STATE_LAST_ACK:
                if (!packet_sent) {
                    printk(KERN_INFO "STATCE_MACHINE_%s: Accepting for Last_ACK -> Closed", terminator);
                        rule->state = STATE_CLOSED;
                        print_connections_table();
                        return NF_ACCEPT;
                    }
                    break;

            default:
                printk(KERN_INFO "\n\n*** STATCE_MACHINE_%s: Dropping by default *** \n\n", terminator);
                return NF_DROP;
        }
        return NF_DROP;
        
}

// Handles TCP state machine and changes the state accordingly. 
// Returns verdict NF_ACCEPT (allow packet) or NF_DROP (drop packet)
static int handle_tcp_state_machine(packet_identifier_t packet_identifier, 
                                     connection_rule_row* found_connection, 
                                    __u8 syn, __u8 ack, __u8 rst, __u8 fin) {
    connection_rule_t* srv_rule = &found_connection->connection_rule_srv;
    connection_rule_t* cli_rule = &found_connection->connection_rule_cli;
    int sender_client = compare_packets(packet_identifier, cli_rule->packet);
    int srv_verdict, cli_verdict;
    printk(KERN_INFO "\n\n Inside TCP State Machin \n\n");
    print_connection(found_connection);
    printk (KERN_INFO "TCP Packet flags:\n SYN = %d   ACK = %d   RST = %d   FIN = %d", syn, ack, rst, fin);
    // Handle RST (Reset): Always drop connection on RST
    if (rst == RST_YES) {
        srv_rule->state = STATE_CLOSED;
        cli_rule->state = STATE_CLOSED;
        printk(KERN_INFO "STATCE_MACHINE_srv: Accepting for rst = 1");
        print_connections_table();
        return NF_ACCEPT;
    }

    // Handle server-side state transitions
    switch (srv_rule->state) {
        case STATE_LISTEN:
            if (syn == SYN_YES && ack == ACK_YES && !sender_client) {
                printk(KERN_INFO "STATCE_MACHINE_srv: Accepting for Listen -> Syn_received");
                srv_rule->state = STATE_SYN_RECEIVED;
                print_connections_table();
                srv_verdict = NF_ACCEPT;
            }
            break;
        case STATE_SYN_SENT:
            if ((cli_rule->state == STATE_SYN_RECEIVED || cli_rule->state == STATE_ESTABLISHED) && 
                !sender_client && syn == SYN_NO && ack == ACK_YES) {
                    printk(KERN_INFO "STATCE_MACHINE_cli: Accepting for STATE_SYN_SENT -> Established");
                print_connections_table();
                srv_rule->state = STATE_ESTABLISHED;
                srv_verdict = NF_ACCEPT;
            }
            break;

        case STATE_SYN_RECEIVED:
            if (ack == ACK_YES && syn == SYN_NO && sender_client) {
                printk(KERN_INFO "STATCE_MACHINE_srv: Accepting for Syn_received -> Established");
                srv_rule->state = STATE_ESTABLISHED;
                print_connections_table();
                srv_verdict = NF_ACCEPT;
            }
            break;
        case STATE_ESTABLISHED:
            if (ack == ACK_YES && fin == FIN_NO && cli_rule->state == STATE_ESTABLISHED){
                printk(KERN_INFO "STATCE_MACHINE_srv: accepting data packet");
                srv_verdict = NF_ACCEPT;
                break;
            }
        default:
            srv_verdict = handle_fin_state(found_connection, srv_rule, sender_client, 0, cli_rule, ack, fin);
    }

    // Handle client-side state transitions
    switch (cli_rule->state) {
        case STATE_LISTEN:
            if (syn == SYN_YES && ack == ACK_YES && sender_client) {
                printk(KERN_INFO "STATCE_MACHINE_srv: Accepting for Listen -> Syn_received");
                cli_rule->state = STATE_SYN_RECEIVED;
                print_connections_table();
                cli_verdict = NF_ACCEPT;
            }
            break;
        case STATE_SYN_RECEIVED:
            if (ack == ACK_YES && syn == SYN_NO && !sender_client) {
                printk(KERN_INFO "STATCE_MACHINE_srv: Accepting for Syn_received -> Established");
                cli_rule->state = STATE_ESTABLISHED;
                print_connections_table();
                cli_verdict = NF_ACCEPT;
            }
            break;
        case STATE_SYN_SENT:
            if ((srv_rule->state == STATE_SYN_RECEIVED || srv_rule->state == STATE_ESTABLISHED) && 
                sender_client && syn == SYN_NO && ack == ACK_YES) {
                    printk(KERN_INFO "STATCE_MACHINE_cli: Accepting for STATE_SYN_SENT -> Established");
                print_connections_table();
                cli_rule->state = STATE_ESTABLISHED;
                cli_verdict = NF_ACCEPT;
            }
            break;
        case STATE_ESTABLISHED:
            if (ack == ACK_YES && fin == FIN_NO && srv_rule->state == STATE_ESTABLISHED){
                printk(KERN_INFO "STATCE_MACHINE_cli: accepting data packet");
                srv_verdict = NF_ACCEPT;
                break;
            }
        default:
            cli_verdict = handle_fin_state(found_connection, cli_rule, sender_client, 1, srv_rule, ack, fin);
    }

    return (srv_verdict == NF_ACCEPT || cli_verdict == NF_ACCEPT) ? NF_ACCEPT : NF_DROP;
}


static void tcp_handle_syn(packet_identifier_t packet_identifier, log_row_t* pt_log_entry, int *pt_verdict,
                           __u8 syn, direction_t direction) {
    int found_rule_index;
    printk(KERN_INFO "TCP packet with ack = 0");
    if(direction == DIRECTION_OUT) {
        printk(KERN_ERR "\n\nSuspicious outbound syn - DROPPING\n\n");
        pt_log_entry->action =NF_DROP;
        pt_log_entry->reason = REASON_INVALID_CONNECTION;
        *pt_verdict = NF_DROP;
        return;
    }

    found_rule_index = comp_packet_to_static_rules(packet_identifier, PROT_TCP, ACK_NO, direction);
    if (found_rule_index >= 0) {
        pt_log_entry->action = FW_RULES[found_rule_index].action;      
        pt_log_entry->reason = found_rule_index;   
        *pt_verdict = FW_RULES[found_rule_index].action;
    } else {
        pt_log_entry->action = NF_DROP;
        pt_log_entry->reason = REASON_NO_MATCHING_RULE;   
        printk(KERN_INFO "\nDropping - No static match");
        *pt_verdict = NF_DROP;
    }
}

static void tcp_handle_ack(packet_identifier_t packet_identifier, log_row_t* pt_log_entry, int *pt_verdict,
                            __u8 syn, __u8 ack, __u8 rst, __u8 fin) {
    connection_rule_row* found_connection;
    if(packet_identifier.src_port == HTTP_PORT || packet_identifier.src_port == FTP_PORT || packet_identifier.src_port == SMTP_PORT )
        found_connection = find_connection_row_by_proxy(NULL, packet_identifier.dst_port, DIRECTION_IN);
    else 
        found_connection = find_connection_row(packet_identifier);
    printk(KERN_INFO "**Handling a dynamic packet..");
    // TESTING with the || (srv->cli syn packet) !!!! modify it by checking the LOCAL_PROC_PORT
    if (found_connection == NULL){
        printk (KERN_INFO "\n\nNo connecition found in the table. DROPPING.\n\n");
        pt_log_entry->action = NF_DROP;
        pt_log_entry->reason = REASON_NO_CONNECTION;   
        *pt_verdict = NF_DROP;
    } else {
        printk (KERN_INFO "Connection found. Comparing agains TCP state machine.\n");
        // Syn packet for Active FTP conenction
        if (syn == SYN_YES && ack == ACK_NO){
            *pt_verdict = NF_ACCEPT;
        } else {
            *pt_verdict = handle_tcp_state_machine(packet_identifier, found_connection, syn, ACK_YES, rst, fin);
         }
        if (*pt_verdict)
            pt_log_entry->reason = REASON_VALID_CONNECTION;   
        else
            pt_log_entry->reason = REASON_INVALID_TCP_STATE;   
        pt_log_entry->action = *pt_verdict;
    }
}

static void handle_new_connection(packet_identifier_t packet_identifier, log_row_t* pt_log_entry, 
                                 int *pt_verdict) {
            printk(KERN_INFO "Initiating a new connection");
            // Create a new connection
            if(!initiate_connection(packet_identifier)){
                printk(KERN_ERR "Connection could not be intiated");
                pt_log_entry->action = NF_DROP;
                pt_log_entry->reason = REASON_ILLEGAL_VALUE;
                *pt_verdict = NF_DROP;
            } 
}

static int modify_packet(struct sk_buff *skb, __be32 saddr, __be16 sport, __be32 daddr, __be16 dport){
    struct iphdr *iph;
    struct tcphdr *tcph;
    int tcplen;

    iph = ip_hdr(skb);
    tcph = tcp_hdr(skb);

    if (daddr)
        iph->daddr = daddr;
    if (dport)
        tcph->dest = dport;
    if (saddr)
        iph->saddr = saddr;
    if (sport)
        tcph->source = sport;

    /* Fix IP header checksum */
    iph->check = 0;
    iph->check = ip_fast_csum((u8 *)iph, iph->ihl);
    skb->ip_summed = CHECKSUM_NONE;
    skb->csum_valid = 0;

    /* Linearize the skb */
    if (skb_linearize(skb) < 0) {
        return -1;
    }

    /* Re-take headers. The linearize may change skb's pointers */
    iph = ip_hdr(skb);
    tcph = tcp_hdr(skb);

    /* Fix TCP header checksum */
    tcplen = (ntohs(iph->tot_len) - ((iph->ihl) << 2));
    tcph->check = 0;
    tcph->check = tcp_v4_check(tcplen, iph->saddr, iph->daddr, csum_partial((char *)tcph, tcplen, 0));
    return 0;
}


static int handle_mitm_pre_routing(struct sk_buff *skb, packet_identifier_t packet_identifier, 
                                   const struct nf_hook_state *state, app_prot_t app_prot) {
    __be32 local_ip;
    __be16 local_port; 
    if (app_prot == PROT_HTTP) local_port = LOC_HTTP_PORT; 
    if (app_prot == PROT_FTP) local_port = LOC_FTP_PORT; 
    if (app_prot == PROT_SMTP) local_port = LOC_SMTP_PORT; 

    direction_t dir = get_direction_incoming(state);
    int ret = 0;
    // •	Client-to-server, inbound, pre-routing
    if (dir == DIRECTION_IN){
        local_ip = (in_aton(FW_IN_IP));
        ret = modify_packet(skb, 0, 0, local_ip, local_port);
    } 
    // •	Server-to-client, inbound, pre-routing
    else { 
        local_ip = (in_aton(FW_OUT_IP));
        ret = modify_packet(skb, 0, 0, local_ip, 0);
    }
    printk(KERN_CRIT "MITM - Modifed CLI --> LOCAL:%d\n", ntohs(local_port));
    print_tcp_packet(skb);
    return ret;
}

static int handle_mitm_local_out(struct sk_buff *skb, packet_identifier_t* packet_identifier,
                                tcp_data_t* tcp_data, direction_t dir) {
    __be32 original_ip;
    __be16 original_port;
    __be16 mimt_proc_port;
    connection_rule_row* conn;
    packet_identifier_t original_packet_identifier;
    log_row_t log_entry;
    int ret = 0;

    mimt_proc_port = tcp_data->src_port;
    conn = find_connection_row_by_proxy(packet_identifier, mimt_proc_port, dir);
    if (!conn){
        printk(KERN_ERR "\nError @ Local_out -> Client: Could not find connection by MITM_PORT\n");
        return -1;
    }

    printk(KERN_INFO "Modifying packet @ local_out");
    
    // •	cli-to-server, outbound, local-out,
    if (dir == DIRECTION_IN){
        original_packet_identifier = conn->connection_rule_cli.packet;
        original_ip = (original_packet_identifier.src_ip); // Client's IP
        ret = modify_packet(skb, original_ip, 0, 0, 0);
    } 
    // •	Server-to-client, outbound, local-out,
    else { 
        original_packet_identifier = conn->connection_rule_srv.packet;
        original_port = original_packet_identifier.src_port; // Server's port
        original_ip = (original_packet_identifier.src_ip); // Server's IP
        ret = modify_packet(skb, original_ip, original_port, 0, 0);
        handle_tcp_state_machine(original_packet_identifier, conn, tcp_data->syn, tcp_data->ack, tcp_data->rst, tcp_data->fin);
    }
    if (dir == DIRECTION_OUT && ret >= 0){
        log_entry = init_log_entry(original_packet_identifier, PROT_TCP);
        log_entry.action = NF_ACCEPT;
        log_entry.reason = REASON_VALID_CONNECTION;
        add_or_update_log_entry(&log_entry);
    }
    return ret;
}



static void handle_tcp_pre_routing(struct sk_buff *skb, const struct nf_hook_state *state, 
                       packet_identifier_t packet_identifier, log_row_t* pt_log_entry, int *pt_verdict,
                        __u8 syn, __u8 ack, __u8 rst, __u8 fin, direction_t direction) {
    int ret = 0;
    if (syn == SYN_YES && ack == ACK_NO){
        if(direction == DIRECTION_OUT && packet_identifier.src_port == CONN_FTP_PORT)
            tcp_handle_ack(packet_identifier, pt_log_entry, pt_verdict, syn, ack, rst, fin);
        else {
            tcp_handle_syn(packet_identifier, pt_log_entry, pt_verdict, ack, direction);
            if (*pt_verdict)
                handle_new_connection(packet_identifier, pt_log_entry, pt_verdict);
        }
        
    } else 
        tcp_handle_ack(packet_identifier, pt_log_entry, pt_verdict, syn, ack, rst, fin);
    

    // Proxy stuff 

    if(*pt_verdict && ((packet_identifier.dst_port == (HTTP_PORT) || 
                      (packet_identifier.src_port == (HTTP_PORT) )))){
        printk(KERN_INFO "Handling an HTTP Packet ...");
        ret = handle_mitm_pre_routing(skb, packet_identifier, state, PROT_HTTP);
        if (direction == DIRECTION_OUT) pt_log_entry->ignore = 1;
    } else if(*pt_verdict &&( (packet_identifier.dst_port == (FTP_PORT)) || 
                      (packet_identifier.src_port == (FTP_PORT) )) ){
        printk(KERN_INFO "Handling an FTP Packet ...");
        ret = handle_mitm_pre_routing(skb, packet_identifier, state, PROT_FTP);
        if (direction == DIRECTION_OUT) pt_log_entry->ignore = 1;
    } else if(*pt_verdict && ((packet_identifier.dst_port == SMTP_PORT) || 
                       (packet_identifier.src_port == SMTP_PORT) )){
        printk(KERN_INFO "Handling an SMTP Packet ...");
        ret = handle_mitm_pre_routing(skb, packet_identifier, state, PROT_SMTP);
        if (direction == DIRECTION_OUT) pt_log_entry->ignore = 1;
    }

    if(ret < 0) {
        printk(KERN_ERR "__ CHECKSUM ERROR. DROPPING __");
        *pt_verdict = NF_DROP;
        pt_log_entry->action = NF_DROP;
        pt_log_entry->reason = REASON_MITM_ERR;
    }
}

static void hanlde_non_tcp_pre_routing(packet_identifier_t packet_identifier, log_row_t* log_entry, int *verdict,
                           __u8 protocol, __u8 direction) {
        int found_rule_index = comp_packet_to_static_rules(packet_identifier, protocol, ACK_NO, direction);
        if (found_rule_index >= 0) {
            log_entry->action = FW_RULES[found_rule_index].action;      
            log_entry->reason = found_rule_index;   
            *verdict = FW_RULES[found_rule_index].action;
        } else {
            log_entry->action = NF_DROP;
            log_entry->reason = REASON_NO_MATCHING_RULE;   
            printk(KERN_INFO "\nDropping - No static match");
            *verdict = NF_DROP;
        }
}

// Given a TCP/UDP/ICMP packet
static int get_packet_verdict_pre_routing(struct sk_buff *skb, const struct nf_hook_state *state) {
    packet_identifier_t packet_identifier;
    log_row_t log_entry;
    __u8 ack, syn, fin, rst;
    struct iphdr *ip_header;
    direction_t direction;
    __be32 src_ip = 0, dst_ip = 0;
    __be16 src_port = 0, dst_port = 0;
    __u8 protocol = 0;
    int is_christmas_packet = 0;
    int verdict = NF_DROP;

    memset(&log_entry, 0, sizeof(log_row_t)); // Initialize to zero
    direction = get_direction_incoming(state);

    ip_header = ip_hdr(skb);
    if (!ip_header){
        printk(KERN_INFO "Accepting a non-IP packet.");
        return NF_ACCEPT;
    }

    src_ip = ip_header->saddr;
    dst_ip = ip_header->daddr;
    protocol = ip_header->protocol;

    if (protocol != PROT_ICMP &&  protocol != PROT_TCP && protocol != PROT_ICMP){
        printk(KERN_INFO "Accepting an unsupported protocol.");
        return NF_ACCEPT;
    }

    printk(KERN_INFO "Protocol: %u", protocol);
    extract_transport_fields(skb, protocol, &src_port, &dst_port, &syn, &ack, &fin, &rst, &is_christmas_packet);

    if (protocol == PROT_TCP){
        printk (KERN_INFO "TCP Packet flags:\n SYN = %d   ACK = %d   RST = %d   FIN = %d", syn, ack, rst, fin);
    }

    packet_identifier.src_ip = src_ip;
    packet_identifier.dst_ip = dst_ip;
    packet_identifier.src_port = src_port;
    packet_identifier.dst_port = dst_port;
    
    printk(KERN_INFO "Processing this packet:");
    print_packet_identifier(&packet_identifier);

    log_entry = init_log_entry(packet_identifier, protocol);  

    if (is_christmas_packet) {
        log_entry.reason = REASON_XMAS_PACKET;
        log_entry.action = NF_DROP;
        add_or_update_log_entry(&log_entry);
        return NF_DROP;
    }


    if (protocol == PROT_TCP ) 
        handle_tcp_pre_routing(skb, state, packet_identifier, &log_entry, &verdict, syn, ack, rst, fin, direction);
    else
        hanlde_non_tcp_pre_routing(packet_identifier, &log_entry, &verdict, protocol, direction);
    
    add_or_update_log_entry(&log_entry);
    return verdict;
}

static unsigned int module_hook_local_out(void *priv, struct sk_buff *skb, const struct nf_hook_state *state) {
    struct iphdr *ip_header;
    tcp_data_t* tcp_data;
    packet_identifier_t packet_identifier;
    direction_t dir = get_direction_outgoing(state);
    int ret = 0;

    ip_header = ip_hdr(skb);
    if (!ip_header || !(ip_header->protocol == PROT_TCP))
        return NF_ACCEPT;

    tcp_data = get_tcp_data(skb);
    if (!tcp_data) {
        printk(KERN_ERR "Accepting non-TCP packets");
        return NF_ACCEPT;
    }
    packet_identifier.src_ip = ip_header->saddr;
    packet_identifier.dst_ip = ip_header->daddr;
    packet_identifier.src_port = tcp_data->src_port;
    packet_identifier.dst_port = tcp_data->dst_port;

    if(tcp_data->src_port == LOC_HTTP_PORT   || tcp_data->dst_port == HTTP_PORT || 
        tcp_data->src_port == LOC_FTP_PORT   || tcp_data->dst_port == FTP_PORT  ||
        tcp_data->src_port  == LOC_SMTP_PORT || tcp_data->dst_port == SMTP_PORT){
        printk(KERN_INFO "\n\n********************\n\n");
        printk(KERN_INFO "Packet @ LOCAL_OUT");
        printk(KERN_INFO "\n");
        printk(KERN_INFO "packet identifier:\n");
        print_tcp_packet(skb);
        ret = handle_mitm_local_out(skb, &packet_identifier, tcp_data, dir);
        if (ret < 0){
            printk(KERN_CRIT "Dropping local_out packet\n");
            return NF_DROP;
        }
        printk(KERN_CRIT "\nMITM - Modifed @ local out to:\n");
        print_tcp_packet(skb);
    }
    return NF_ACCEPT;
}



static unsigned int module_hook(void *priv, struct sk_buff *skb, const struct nf_hook_state *state) {
    unsigned int verdict = NF_DROP;
    struct iphdr *ip_header;
    ip_header = ip_hdr(skb);
    if (!ip_header) {
        printk(KERN_INFO "\nAccepting for NON-IPv4 packets\n");
        return NF_ACCEPT; // Accept non-IPv4 packets (e.g., IPv6)
    }

    // Check for loopback packets (127.0.0.1/8)
    if ((ntohl(ip_header->saddr) & 0xFF000000) == 0x7F000000) {
        printk(KERN_INFO "\nAccepting for 127.0.0.1\n");
        return NF_ACCEPT; // Accept loopback packets without logging
    }

    // Accept any non-TCP, UDP, or ICMP protocol without logging
    if (ip_header->protocol != PROT_TCP && ip_header->protocol != PROT_UDP && ip_header->protocol != PROT_ICMP) {
        return NF_ACCEPT;
    }

    printk(KERN_INFO "\n\n************\nRecieved a new packet *************\n\n\n");

    verdict = get_packet_verdict_pre_routing(skb, state);
    printk(KERN_INFO "\n\n\nEnd packet <- %s \n************\n\n", verdict ? "Accept": "Drop");
    return verdict;
}



static DEVICE_ATTR(rules, S_IWUSR | S_IRUGO , display_rules, modify_rules);
static DEVICE_ATTR(reset, S_IWUSR, NULL, reset_logs);
static DEVICE_ATTR(conns, S_IRUSR, read_connections_table, NULL);
static DEVICE_ATTR(mitm, S_IWUSR, NULL, modify_mitm_port);

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read = read_logs,
};


// Initialization function; handles error registering the hooks with cleanups and an indicative return value
static int __init fw_init(void) {    
    int ret;
    printk(KERN_INFO "\n\n\n\n\nLoading firewall module...!\n __V1.02__\n\n\n\n");
    // ******
    // Devices setup
    // ******

    //create char device
	major_number = register_chrdev(0, "fw_log", &fops);
    printk(KERN_INFO "Major number %d\n", major_number);
	if (major_number < 0)
		return -1;
		
	//create sysfs class
	sysfs_class = class_create(THIS_MODULE, "fw");
	if (IS_ERR(sysfs_class))
	{
		unregister_chrdev(major_number, "fw_log");
		return -1;
	}
	
	//create sysfs device
	sysfs_device = device_create(sysfs_class, NULL, MKDEV(major_number, 0), NULL, "rules");	
	if (IS_ERR(sysfs_device))
	{
		class_destroy(sysfs_class);
		unregister_chrdev(major_number, "fw_log");
		return -1;
	}
	
	//create sysfs file attributes	
	if (device_create_file(sysfs_device, (const struct device_attribute *)&dev_attr_rules.attr))
	{
		device_destroy(sysfs_class, MKDEV(major_number, 0));
		class_destroy(sysfs_class);
		unregister_chrdev(major_number, "fw_log");
		return -1;
	}

    log_device = device_create(sysfs_class, NULL, MKDEV(major_number, 1), NULL, "log");
    if (IS_ERR(log_device))
    {
        device_destroy(sysfs_class, MKDEV(major_number, 0));
        class_destroy(sysfs_class);
        unregister_chrdev(major_number, "fw_log");
        return -1;
    }

    // Create the "reset" sysfs attribute for the "log" device
    if (device_create_file(log_device, (const struct device_attribute *)&dev_attr_reset.attr))
    {
        device_destroy(sysfs_class, MKDEV(major_number, 1));
        device_destroy(sysfs_class, MKDEV(major_number, 0));
        class_destroy(sysfs_class);
        unregister_chrdev(major_number, "fw_log");
        return -1;
    }


    conns_device = device_create(sysfs_class, NULL, MKDEV(major_number, 2), NULL, "conns");
    if (IS_ERR(conns_device))
    {
        device_destroy(sysfs_class, MKDEV(major_number, 0));
        device_destroy(sysfs_class, MKDEV(major_number, 1));
        class_destroy(sysfs_class);
        unregister_chrdev(major_number, "fw_log");
        return -1;
    }

    // Create the "conns" sysfs attribute for the "conns" device
    if (device_create_file(conns_device, (const struct device_attribute *)&dev_attr_conns.attr))
    {
        device_destroy(sysfs_class, MKDEV(major_number, 2));
        device_destroy(sysfs_class, MKDEV(major_number, 1));
        device_destroy(sysfs_class, MKDEV(major_number, 0));
        class_destroy(sysfs_class);
        unregister_chrdev(major_number, "fw_log");
        return -1;
    }

    mitm_device = device_create(sysfs_class, NULL, MKDEV(major_number, 3), NULL, "mitm");
    if (IS_ERR(mitm_device))
    {
        device_destroy(sysfs_class, MKDEV(major_number, 0));
        device_destroy(sysfs_class, MKDEV(major_number, 1));
        device_destroy(sysfs_class, MKDEV(major_number, 2));
        class_destroy(sysfs_class);
        unregister_chrdev(major_number, "fw_log");
        return -1;
    }

    // Create the "mitm" sysfs attribute for the "mitm" device
    if (device_create_file(mitm_device, (const struct device_attribute *)&dev_attr_mitm.attr))
    {
        device_destroy(sysfs_class, MKDEV(major_number, 3));
        device_destroy(sysfs_class, MKDEV(major_number, 2));
        device_destroy(sysfs_class, MKDEV(major_number, 1));
        device_destroy(sysfs_class, MKDEV(major_number, 0));
        class_destroy(sysfs_class);
        unregister_chrdev(major_number, "fw_log");
        return -1;
    }

    // ******
    // Netfilter Hooks
    // ******

    // Set up the Netfilter hook for forwarding packets
    netfilter_ops_fw.hook = module_hook;
    netfilter_ops_fw.pf = PF_INET;
    netfilter_ops_fw.hooknum = NF_INET_PRE_ROUTING;
    netfilter_ops_fw.priority = NF_IP_PRI_FIRST;

    ret = nf_register_net_hook(&init_net, &netfilter_ops_fw);
    if (ret) {
        printk(KERN_ERR "firewall: Failed to register forwarding hook. Error: %d\n", ret);
        device_destroy(sysfs_class, MKDEV(major_number, 1));
        device_destroy(sysfs_class, MKDEV(major_number, 0));
        class_destroy(sysfs_class);
        unregister_chrdev(major_number, "fw_log");
        return ret;
    }

    // Set up the Netfilter hook for forwarding packets
    netfilter_ops_fw_local_out.hook = module_hook_local_out;
    netfilter_ops_fw_local_out.pf = PF_INET;
    netfilter_ops_fw_local_out.hooknum = NF_INET_LOCAL_OUT;
    netfilter_ops_fw_local_out.priority = NF_IP_PRI_FIRST;

    ret = nf_register_net_hook(&init_net, &netfilter_ops_fw_local_out);
    if (ret) {
        printk(KERN_ERR "firewall: Failed to register LOCAL_OUT hook. Error: %d\n", ret);
        device_destroy(sysfs_class, MKDEV(major_number, 1));
        device_destroy(sysfs_class, MKDEV(major_number, 0));
        class_destroy(sysfs_class);
        unregister_chrdev(major_number, "fw_log");
        nf_unregister_net_hook(&init_net, &netfilter_ops_fw);
        return ret;
    }
    
    return 0;
}

static void __exit fw_exit(void)
{
    printk(KERN_INFO "Removing firewall module...\n");
    // ****** Device Cleanup ******
    if (sysfs_device)
    {
        device_remove_file(sysfs_device, (const struct device_attribute *)&dev_attr_rules.attr);
        device_destroy(sysfs_class, MKDEV(major_number, 0));
    }

    // Remove the "reset" sysfs attribute and device if they exist
    if (log_device)
    {
        device_remove_file(log_device, (const struct device_attribute *)&dev_attr_reset.attr);
        device_destroy(sysfs_class, MKDEV(major_number, 1));
    }

    if (conns_device)
    {
        device_remove_file(conns_device, (const struct device_attribute *)&dev_attr_conns.attr);
        device_destroy(sysfs_class, MKDEV(major_number, 2));
    }

    if (mitm_device)
    {
        device_remove_file(mitm_device, (const struct device_attribute *)&dev_attr_mitm.attr);
        device_destroy(sysfs_class, MKDEV(major_number, 3));
    }

    // Destroy the sysfs class (only after all devices are cleaned up)
    if (sysfs_class)
        class_destroy(sysfs_class);

    // Unregister the character device
    unregister_chrdev(major_number, "fw_log");

    // ****** Netfilter Cleanup ******
    nf_unregister_net_hook(&init_net, &netfilter_ops_fw);
    nf_unregister_net_hook(&init_net, &netfilter_ops_fw_local_out);

    printk(KERN_INFO "firewall module removed successfully.\n");
}

module_init(fw_init);
module_exit(fw_exit);




#include <stdio.h>
#include <stdlib.h> // For exit() function
#include "PanTompkins.h"

int main(int argc, char* argv[]) {

	// --------------Input Arguments ------------------ //
	if (argc == 1 || argc > 3)
	{
		printf("\nProvide an input ecg filename!\n");
		printf("=================================\n");
		printf("Usage: PanTompkinsCMD FILENAME VERBOSITY\n\n");
		printf("Example: PanTompkinsCMD ecg.txt 1\n");
		printf("Reads ecg.txt and prints the results to both console and output file.\n\n");
		printf("Example: PanTompkinsCMD ecg.txt \n");
		printf("Reads ecg.txt but does not print to console and only prints to the file.\n");
		printf("Program prints the results in output.csv\n");
		exit(1);
	}


	int16_t delay, Rcount,s1, s2, s3, s4, s5, ThF1;
	uint16_t ThI1, SPKI, NPKI;
	int32_t RLoc, c, SampleCount;
	SampleCount = 0;

	Rcount = 0;
	errno_t err, err1;


	// -------------- Reading Input File ------------------ //
	FILE *fptr, *fptr_out;
	err  = fopen_s(&fptr, argv[1], "r");
	err1  = fopen_s(&fptr_out, "output.csv", "w");
	if( err == 0 || err1 == 0)
	{
      printf( "The file %s was opened\n", argv[1]);

	  // -------header --------//
	  fprintf_s(fptr_out, "Input,LPFilter,HPFilter,DerivativeF,SQRFilter,MVAFilter,RBeat,RunningThI1,SignalLevel,NoiseLevel,RunningThF\n");
	}
	else
	{
      printf( "The file %s was not opened\n", argv[1]);
	  exit(1);
	}



	int verbosity = atoi(argv[2]);

	
	PT_init();															// Always Initialize the Algorithm before use ---> This prepares all filters and parameters

	// ------ Pass the signal sample by sample mimicing a real-time scenario ----------- //
	while (fscanf_s(fptr, "%ld", &c) != EOF) {
		++SampleCount;
		
		delay = PT_StateMachine((int16_t) c);							// This is the main function of the algorithm

		// ------- A positive delay to current sample is returned in case of beat detection ----------- //
		if (delay != 0)
		{
			RLoc = SampleCount - (int32_t) delay;
			++Rcount;
		}
		else
		{
			RLoc = 0;
		}

		// -------- Toolbox comes with many helper functions for debugging, see PanTompkins.c for more details ---------- //
		s1 = PT_get_LPFilter_output();
		s2 = PT_get_HPFilter_output();
		s3 = PT_get_DRFilter_output();
		s4 = PT_get_SQRFilter_output();
		s5 = PT_get_MVFilter_output();

		ThI1 = PT_get_ThI1_output();
		SPKI = PT_get_SKPI_output();
		NPKI = PT_get_NPKI_output();
		ThF1 = PT_get_ThF1_output();
		
		if (verbosity)
			printf("%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n", c, s1, s2, s3, s4, s5, RLoc, ThI1, SPKI, NPKI, ThF1);

		fprintf_s(fptr_out, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n", c, s1, s2, s3, s4, s5, RLoc, ThI1, SPKI, NPKI, ThF1);
		
	}
	printf("%d beats detected\n", Rcount);
	fclose(fptr);
	fclose(fptr_out);
	return 0;
}

static struct PT_struct PT_data;
static struct PT_struct *const PT_dptr = &PT_data;


static int16_t Prev_valBP, 
Prev_Prev_valBP, Best_PeakBP, Prev_valDR, Prev_Prev_valDR, 
Best_PeakDR, Old_PeakDR, Count_SinceRR, RR1_p, RR2_p, 
RR1_sum, RR2_sum, BlankTimeCnt, SBcntI, SB_peakBP, SB_peakDR, 
y_h, st_mean_pkBP;

static uint16_t MV_sum, PEAKI_temp, st_mx_pk, st_mean_pk,
Prev_val, Prev_Prev_val, SB_peakI;


#if (FILTER_FORM == 2)
static int16_t LP_y_new, LP_y_old;
#endif


/**********************************************************************************

    Fuction Name: PT_init


    Parameter:
     Input:   none

     Returns: none

    Description: initializes the PanTompkins (PT) data structure and RR interval,
	and filter Buffers.

 *******************************************************************************/

void PT_init( void )
{
	/**************************************************
	Initialize Pan_Tompkins structure.
	**************************************************/

	memset(&PT_data, 0, sizeof(PT_data));

	PT_dptr->PT_state		= START_UP;

	PT_dptr->Recent_RR_M = PT_dptr->RR_M =  PT1000MS;

	PT_dptr->RR_Low_L		= RR92PERCENT;
	PT_dptr->RR_High_L		= RR116PERCENT;
	PT_dptr->RR_Missed_L	= RR166PERCENT;

	PT_dptr->LP_pointer		= 0;
	PT_dptr->HP_pointer		= 0;
	PT_dptr->MVA_pointer	= 0;

	PT_dptr->HR_State = REGULAR_HR;


	/**************************************************
	Initialize filter buffers
	**************************************************/
	int8_t idex;

	for (idex = 0; idex < LP_BUFFER_SIZE; idex++)
		PT_dptr->LP_buf[idex]		= 0;							//  LP filter buffer
	for (idex = 0; idex < HP_BUFFER_SIZE; idex++)
		PT_dptr->HP_buf[idex]		= 0;							//  HP filter buffer
	for (idex = 0; idex < DR_BUFFER_SIZE; idex++)
		PT_dptr->DR_buf[idex]		= 0;							//  DR filter buffer
	for (idex = 0; idex < MVA_BUFFER_SIZE; idex++)
		PT_dptr->MVA_buf[idex]		= 0;							//  MVA filter buffer
	for (idex = 0; idex < RR_BUFFER_SIZE; idex++) {
		PT_dptr->RR_AVRG1_buf[idex] = 
			PT_dptr->RR_AVRG2_buf[idex] = PT1000MS;					//  Normal	and extreme RR buffers
	}

	/**************************************************
	Initialize all static variables 
	**************************************************/
	Prev_val = Prev_Prev_val = 0;									// Place holders for peak detector in Integrated Sig
	Prev_valBP = Prev_Prev_valBP = Best_PeakBP = 0;					// Place holders for peak detector in BP signal
	Prev_valDR = Prev_Prev_valDR = Best_PeakDR = Old_PeakDR = 0;	// Place holders for peak detector in Derivative signal (Used for T-wave discrimination)
	Count_SinceRR = 0;												// Nr of samples since last qrs peak
	RR1_p = RR2_p = 0;												// Pointers to RR average 1 and 2 resepectively
	MV_sum = 0;														// sum for moving average filter
	RR1_sum = RR2_sum = PT1000MS << 3;								// Sum of RR1 and RR2 buffers
	BlankTimeCnt = 0;												// Counter for blank-time.
	SBcntI = 0;														// For searchback index in Integ Signal
	SB_peakI = 0;													// For searchback in Integ sig
	SB_peakBP = SB_peakDR = 0;										// For searchback peak holders in BP and slope signal
	st_mx_pk = 0;													// Used in learning phase 1 to estimate thresholds
	y_h = 0;														// recusrively used in HP filter

#if (FILTER_FORM == 2)
	LP_y_new = LP_y_old = 0;										// Parameters for DirectForm || LP filter
#endif
}

/**********************************************************************************

	Fuction Name: PT_StateMachine

	Parameter:
	 Input	:	datum		- Most recent sample of ECG from ADC.

	 Returns:	BeatDelay	- If non-zero a qrs has been detected with BeatDelay samples.

	Description: Pan-Tompkins State Machine implementation. This state-machine goes through
	each step of the Pan-Tompkins algorithm, namely, BP filtering, derivative filtering, 
	squaring and integration. After signal enhancement, BP and integrated signal's peaks 
	are analyzed and compared to two adaptive thresholds to determine whether a beat has occured.
	The thresholds themselves is computed adaptively from noise and signal estimation. An efficient
	search-back strategy and T-wave discrimination is also implemented that do not require any 
	buffers. Once a beat is detected, the function returns a non-zero delay indicating the QRS
	peak delay to the current sample.

 **********************************************************************************/

int16_t PT_StateMachine(int16_t datum)
{
	int16_t BeatDelay = 0;

	uint16_t PEAKI ;

	// ------- Preprocessing filtering and Peak detection --------- //
	LPFilter(&datum);										// LowPass filtering
	HPFilter();												// HighPass filtering

	PeakDtcBP(PT_dptr->HPF_val);							// Store BP signal highest peak
	
	DerivFilter();
	PeakDtcDR(PT_dptr->DRF_val);							// Store the highest slope for T wave discrimination

	SQRFilter();											//Squaring

	MVAFilter();
	PEAKI = PeakDtcI();

	// ---- Integrated Peak detection checks and blankTime ---- //
	if (!PEAKI && BlankTimeCnt)								// No beat, decrement BlankTime
	{
		if (--BlankTimeCnt == 0)							// If blanktime over place the oldest peak
			PEAKI = PEAKI_temp;
	}
	else if (PEAKI && !BlankTimeCnt)						// If no peak for peak for last 200msec, save the current peak
	{
		BlankTimeCnt = PT200MS;
		PEAKI_temp   = PEAKI;
		PEAKI = 0;
	}
	else if(PEAKI)											// If a bigger peak comes along, store it
	{
		if (PEAKI > PEAKI_temp)
		{
			BlankTimeCnt = PT200MS;
			PEAKI_temp = PEAKI;
			PEAKI = 0;
		}
		else if (--BlankTimeCnt == 0)
			PEAKI = PEAKI_temp;
		else
			PEAKI = 0;
	}

	// -- Run Different Phases of the Algo -> Learning Ph1, 2 and decision --//
	++Count_SinceRR;
	if (PT_dptr->PT_state == START_UP || PT_dptr->PT_state == LEARN_PH_1)		
	{ 
		if (PEAKI > 0)
			LearningPhase1(&PEAKI, &Best_PeakBP);
	}
	// ---- Once learning Phase 1 done, start storing beats ---- //
	else										
	{
		// ---- Is the peak taller than ThI1 and ThF1? ---- //
		if (PEAKI > PT_dptr->ThI1 && Best_PeakBP > PT_dptr->ThF1)
		{

			// ---- Initiated phase 2 ---- //
			if (PT_dptr->PT_state == LEARN_PH_2)
			{
				// ----- Update Integ & BP Th ------ //
				UpdateThI(&PEAKI, 0);
				UpdateThF(&Best_PeakBP, 0);

				// --- First RR interval --- //
				BeatDelay = GENERAL_DELAY + PT200MS;
				Count_SinceRR = 0;
				Old_PeakDR = Best_PeakDR;
				Best_PeakDR = 0;
				Best_PeakBP = 0;

				// --- Now we can compute RR intervals --- //
				PT_dptr->PT_state = DETECTING;

			}
			// ------ Learning phases are done! -------- //
			else
			{
			// --- T-Wave Test if RR < 360msec, is current slope lower 0.5prev_slope then noise --- //
				if (Count_SinceRR < PT360MS && (Best_PeakDR < (Old_PeakDR >> 2)))
				{
					// ----- Update Integ & BP Th ------ //
					UpdateThI(&PEAKI, 1);
					UpdateThF(&Best_PeakBP, 1);

				}
				else
				{
					// ----- Update Integ & BP Th && RR buffers ------ //
					UpdateThI(&PEAKI, 0);
					UpdateThF(&Best_PeakBP, 0);
					UpdateRR(Count_SinceRR);

					// --- Reset parameters --- //
					BeatDelay = GENERAL_DELAY + PT200MS;
					Count_SinceRR = 0;
					Old_PeakDR = Best_PeakDR;									// Store the derivative for T-wave test
					Best_PeakDR = Best_PeakBP = 0;

					SBcntI = 0;
					SB_peakBP = 0;
					SB_peakDR = 0;
					SB_peakI = 0;

				}
			}
		}
		// ------ If the peak is noise ------- //
		else if (PEAKI > 0)
		{
			// ----- Update Integ & BP Th ------ //
			UpdateThI(&PEAKI, 1);
			UpdateThF(&Best_PeakBP, 1);

			// ----- Store the peak for searchback ------ //
			if (PEAKI > SB_peakI && Count_SinceRR >= PT360MS)
			{
				SB_peakI = PEAKI;											// Store Integ Sig peak 
				SB_peakBP = Best_PeakBP;									// Store BP Sig peak
				SB_peakDR = Best_PeakDR;									// Derivative of SB point
				SBcntI = Count_SinceRR;										// Store Indice
			}

		}

	}

	// -- Do search-back if we have no beats in PT_dptr->RR_Missed_L -- //
	if (Count_SinceRR > PT_dptr->RR_Missed_L && SB_peakI > PT_dptr->ThI2 && PT_dptr->PT_state == DETECTING)
	{
		// ---- Checking the BP signal ---- //
		if (SB_peakBP > PT_dptr->ThF2)
		{
			// ----- Update Integ & BP Th && RR buffers ------ //
			UpdateThI(&SB_peakI, 0);
			UpdateThF(&SB_peakBP, 0);
			UpdateRR(SBcntI);

			// --- Reset parameters --- //
			BeatDelay = Count_SinceRR = Count_SinceRR - SBcntI;
			BeatDelay += (GENERAL_DELAY + PT200MS);
			Old_PeakDR = SB_peakDR;		// Store the derivative for T-wave test
			Best_PeakDR = Best_PeakBP = 0;

			SBcntI = 0;
			SB_peakBP = 0;
			SB_peakDR = 0;
			SB_peakI = 0;
		}
	}

	// ---- Emergency and Faulty Condition Reset ---- //
	// If algorithm doest not find a beat in 4sec, then it resets itself
	// and starts learning phases.
	if (Count_SinceRR > PT4000MS) {
		PT_init();
	}

	return (BeatDelay);
	
}


/**********************************************************************************

	Fuction Name: LearningPhase1

	Parameter:
	 Input	:	pkI - Pointer to the integrated signal peak
				pkBP- Pointer BP signal peak

	 Returns:	none - Updates the static values (st_mx_pk, st_mean_pk) and (st_mean_pkBP).

	Description: Computes the maximum peak in the past 2 seconds and also the mean of the
	peaks iteratively in both Integrated Signal and BP signal.

 **********************************************************************************/

void LearningPhase1(uint16_t *pkI, int16_t *pkBP)
{
	//---- Recursively compute the average and max of peaks ------ //
	if (*pkI > st_mx_pk) st_mx_pk = *pkI;

	// ---- If the very first time calling this function --- //
	if (PT_dptr->PT_state == START_UP) {
		PT_dptr->PT_state = LEARN_PH_1;
		st_mean_pk = *pkI;
		st_mean_pkBP = *pkBP; 
	}
	// ----- Continue averaging once still in learning ----- //
	else if(Count_SinceRR < PT2000MS){
		st_mean_pk = (st_mean_pk + *pkI) >> 1;
		st_mean_pkBP = (st_mean_pkBP + *pkBP) >> 1;
	}
	else {
		PT_dptr->PT_state = LEARN_PH_2;
		// ---- Integrated Signal Thresholds ------- //
		PT_dptr->SPKI = (st_mx_pk >> 1);
		PT_dptr->NPKI = (st_mean_pk >> 3);
		PT_dptr->ThI1 = PT_dptr->NPKI + ((PT_dptr->SPKI - PT_dptr->NPKI) >> 2);
		PT_dptr->ThI2 = PT_dptr->ThI1 >> 1;

		// -------- BP Signal Thresholds ---------- //
		PT_dptr->SPKF = (Best_PeakBP >> 1);
		PT_dptr->NPKF = (st_mean_pkBP >> 3);
		PT_dptr->ThF1 = PT_dptr->NPKF + ((PT_dptr->SPKF - PT_dptr->NPKF) >> 2);
		PT_dptr->ThF2 = PT_dptr->ThF1 >> 1;

	}
}

/**********************************************************************************

    Fuction Name: LPFilter

    Parameter:
     Input	:	none - Pointer to the input datum.

     Returns:	none - Updates the static value PT_dptr->LPF_val in place.

    Description: Low-pass filters the signal based on Pan-Tompkins Eq. 3,
	y[n] = 2*y[n-1] - y[n-2] + x[n] - 2 * x[n - 6] + x[n - 12] . This
	function implements the filter both in Direct Form I and II. Select the
	type employed by setting FILTER_FORM to 1 or 2. Delay of the filter is 5.

 **********************************************************************************/

void LPFilter(int16_t *val)
{
	// -- To avoid using modulo employ half-pointer -- //
	int16_t half_pointer, w;

	half_pointer = PT_dptr->LP_pointer - (LP_BUFFER_SIZE >> 1);

	if (half_pointer < 0) 
		half_pointer += LP_BUFFER_SIZE;

	

		// ------- Filter based on selected Form ------- //
#if (FILTER_FORM == 1)
		w = *val + (PT_dptr->LP_buf[1] << 1) - PT_dptr->LP_buf[0];
		*val = w - (PT_dptr->LP_buf[half_pointer] << 1) + PT_dptr->LP_buf[PT_dptr->LP_pointer];
		PT_dptr->LP_buf[PT_dptr->LP_pointer] = w;
#else
		w = (LP_y_old << 1) - LP_y_new + *val - (PT_dptr->LP_buf[half_pointer] << 1) + PT_dptr->LP_buf[PT_dptr->LP_pointer];
		LP_y_new = LP_y_old;
		LP_y_old = w;
		PT_dptr->LP_buf[PT_dptr->LP_pointer] = *val;
#endif
		// --- Avoid signal overflow by gaining down ---- //
		if (w >= 0)
			PT_dptr->LPF_val = w >> 5;
		else
			PT_dptr->LPF_val = (w >> 5) | 0xF800;

		if (++PT_dptr->LP_pointer == LP_BUFFER_SIZE) 
			PT_dptr->LP_pointer = 0;
}


/**********************************************************************************

Fuction Name: HPFilter

Parameter:
Input	:	none - Employs Current_Sample in place.

Returns:	none - Updates the static value PT_dptr->HPF_val  in place.

Description: High-pass filters the signal based on Pan-Tompkins Eq. 2.4 (Errata),
y[n] = y[n-1] + x[n-32]/32 - x[n]/32 + x[n - 16] - x[n - 17] . This
function implements the filter both in Direct Form I and II. Select the
type employed by setting FILTER_FORM to 1 or 2. Delay 16 samples.

**********************************************************************************/
void HPFilter(void)
{
	// -- To avoid using modulo employ half-pointer -- //
	int16_t half_pointer, h_prev_pointer;
	half_pointer = PT_dptr->HP_pointer - (HP_BUFFER_SIZE >> 1);

	if (half_pointer < 0)
		half_pointer += HP_BUFFER_SIZE;
	
	if (!half_pointer)
		h_prev_pointer = HP_BUFFER_SIZE - 1;
	else
		h_prev_pointer = half_pointer - 1;



	// ------- Filter based on selected Form ------- //
#if (FILTER_FORM == 1)
	y_h = PT_dptr->LPF_val + PT_dptr->HP_buf[0];
	PT_dptr->LPF_val = ((PT_dptr->HP_buf[PT_dptr->HP_pointer] - y_h) >> 5) + PT_dptr->HP_buf[half_pointer] - PT_dptr->HP_buf[h_prev_pointer];
	PT_dptr->HP_buf[PT_dptr->HP_pointer] = y_h;
#else
	y_h += (PT_dptr->HP_buf[PT_dptr->HP_pointer] >> 5) - (PT_dptr->LPF_val >> 5) + PT_dptr->HP_buf[half_pointer] - PT_dptr->HP_buf[h_prev_pointer];
	PT_dptr->HP_buf[PT_dptr->HP_pointer] = PT_dptr->LPF_val;
	
#endif
	// ------- Again slightly gaining down --------- //
	if (y_h >= 0)
		PT_dptr->HPF_val = (y_h >> 1);
	else
		PT_dptr->HPF_val = (y_h >> 1) | 0xF800;

	if (++PT_dptr->HP_pointer == HP_BUFFER_SIZE) PT_dptr->HP_pointer = 0;
}

/**********************************************************************************

Fuction Name: DerivFilter

Parameter:
Input	:	none - Employs Current_Sample.

Returns	:	none - Updates the value Current_Sample in place.

Description: Computes the signal derivative based on Pan-Tompkins Eq. 2.6 (Errata),
y[n] = 1/8(2x[n] + x[n - 1] - x[n - 3] - 2x[n - 4]) . Delay 2 samples.

**********************************************************************************/

void DerivFilter(void)
{
	// --- Since it is only a 5 point derivative filter we avoid using pointers and half pointers for further efficieny ---- //
	int16_t w;

	w = PT_dptr->DR_buf[0] - PT_dptr->DR_buf[2];
	w += ((PT_dptr->HPF_val - PT_dptr->DR_buf[3]) << 1);
	w >>= 3;
	PT_dptr->DR_buf[3] = PT_dptr->DR_buf[2];
	PT_dptr->DR_buf[2] = PT_dptr->DR_buf[1];
	PT_dptr->DR_buf[1] = PT_dptr->DR_buf[0];
	PT_dptr->DR_buf[0] = PT_dptr->HPF_val;
	PT_dptr->DRF_val = w;
}

/**********************************************************************************

Fuction Name: SQRFilter

Parameter:
Input	:	none - Employs Current_Sample.

Returns	:	none - Updates the value Current_Sample in place.

Description: Squares the signal based on Pan-Tompkins Eq. 10,
y[n] = x[n]^2. No delay.

**********************************************************************************/
void SQRFilter(void)
{
	// ------------ Avoiding Overflow -------------- //
	uint16_t temp;
	if (PT_dptr->DRF_val > SQR_LIM_VAL || PT_dptr->DRF_val < (-SQR_LIM_VAL))
		PT_dptr->SQF_val = UINT16_MAX;
	else
	{
		if (PT_dptr->DRF_val < 0)
			temp = (uint16_t)(-PT_dptr->DRF_val);
		else
			temp = (uint16_t)(PT_dptr->DRF_val);
		PT_dptr->SQF_val = temp*temp;
	}

	if (PT_dptr->SQF_val > SQR_LIM_OUT)
		PT_dptr->SQF_val = SQR_LIM_OUT;
}


/**********************************************************************************

Fuction Name: MVAFilter

Parameter:
Input	:	none - Employs Current_Sample.

Returns	:	none - Updates the value Current_Sample in place.

Description: Computes the rolling moving average of the input signal
based on Eq. 11 of Pan-Tompkins, y[n] = (1/N)[sum(x[1]+...+x[N])]. Delay 15 Samples.

**********************************************************************************/
void MVAFilter(void)
{
	//---- The MV_sum can easily overflow so we limit the bound by uint16 precision ------ //
	if (MV_sum < (UINT16_MAX - PT_dptr->SQF_val))
		MV_sum += PT_dptr->SQF_val;
	else
		MV_sum = UINT16_MAX;

	if (MV_sum > PT_dptr->MVA_buf[PT_dptr->MVA_pointer])
		MV_sum -= PT_dptr->MVA_buf[PT_dptr->MVA_pointer];
	else
		MV_sum = 0;

	PT_dptr->MVA_buf[PT_dptr->MVA_pointer] = PT_dptr->SQF_val;

	PT_dptr->MVA_val = MV_sum/(uint16_t) MVA_BUFFER_SIZE;

	if (PT_dptr->MVA_val > MVA_LIM_VAL)
		PT_dptr->MVA_val = MVA_LIM_VAL;

	if (++PT_dptr->MVA_pointer == MVA_BUFFER_SIZE) 
		PT_dptr->MVA_pointer = 0;
}


/**********************************************************************************

Fuction Name: PeakDtcI

Parameter:
Input	:	none - Employs Current_Sample.

Returns	:	p	 - The local maxima in intergrated signal.

Description: This is a simple peak detector for fiducial point detection in the integrated signal.
If the signal changes sign the value of the peak is asssumed ot be a peak.
if x[n-1] <= x[n] > x[n+1], then x[n] is a peak.

**********************************************************************************/
uint16_t PeakDtcI(void)
{
	uint16_t p;
	// ---------- Local maxima or not --------- //
	if (PT_dptr->MVA_val <= Prev_val && Prev_val > Prev_Prev_val) {
		p = Prev_val;
	}
	else {
		p = 0;
	}
	Prev_Prev_val = Prev_val;
	Prev_val = PT_dptr->MVA_val;

	return (p);
}

/**********************************************************************************

Fuction Name: PeakDtcDR

Parameter:
Input	:	none - Input from derivative filter

Returns	:	p	 - Stores the beat in Best_PeakDR for T-wave dsicrimation.

Description: This is a simple peak detector for fiducial point detection in Derivative Signal,
the strategy is to store the highest slope in the signal preceding the qrs so that if the next qrs is
suspicious to be a real beat could be compared against this. This helps us not to need to store a buffer.
For T-wave discrimination see T-wave identification of the paper.
if x[n-1] <= x[n] > x[n+1], then x[n] is a peak.

**********************************************************************************/
void PeakDtcDR(int16_t DR_sample)
{
	if (DR_sample < 0) DR_sample = -DR_sample;
	// ---------- Local maxima or not --------- //
	if (DR_sample <= Prev_valDR && Prev_valDR > Prev_Prev_valDR) {
		//-- For T-wave discrimination store the highest slope -- //
		if (Prev_valDR > Best_PeakDR) Best_PeakDR = Prev_valDR;
	}
	Prev_Prev_valDR = Prev_valDR;
	Prev_valDR = DR_sample;
}

/**********************************************************************************

Fuction Name: PeakDtcBP

Parameter:
Input	:	none - Input from BP signal.

Returns	:	none - Returns a local maxima in Best_PeakBP.

Description: This is a simple peak detector for fiducial point detection in BP Signal. 
Once a peak is detected in Integrated signal, the maximum peak in BP signal is also compared 
against adaptive thresholds.
if x[n-1] <= x[n] > x[n+1], then x[n] is a peak.

**********************************************************************************/
void PeakDtcBP(int16_t DR_sample)
{
	if (DR_sample < 0) DR_sample = -DR_sample;
	// ---------- Local maxima or not --------- //
	if (DR_sample <= Prev_valBP && Prev_valBP > Prev_Prev_valBP) {
		//-- For T-wave discrimination store the highest slope -- //
		if (Prev_valBP > Best_PeakBP) Best_PeakBP = Prev_valBP;
	}
	Prev_Prev_valBP = Prev_valBP;
	Prev_valBP = DR_sample;
}


/**********************************************************************************

Fuction Name: UpdateRR

Parameter:
Input	:	qrs		- The most recent RR interval.

Returns	:	none	- Updates the normal and selected RR values and updates the buffers.

Description: The most recent RR interval is passed to the function, if the RR interval is within
the normal range, RR_LOW_LIM, RR_HIGH_LIM, RR_MISSED_LIM, RR_AVRG2_buf is updated, otherwise
RR_AVRG1_buf is updated which is the average of the most recents beats. Note that two buffers
are employed for robust mean computation (Eq. 24-28). If the peak is irregular the thresholds
are reduced by 50%.

RR_Low_Lim		= 0.92*RR_M = ((92/100) * RR_M) = RR_M - (2/25)*RR_M
RR_High_Lim		= 1.16*RR_M = ((116/100) * RR_M) = RR_M + (4/25)*RR_M
RR_Missed_Lim	= 1.66*RR_M = ((166/100) * RR_M) = RR_M + (33/50)*RR_M

**********************************************************************************/
void UpdateRR(int16_t qrs)
{   
	// ---------- Update most 8 Recent RR mean Interval------------- //
	RR1_sum += qrs;
	RR1_sum -= PT_dptr->RR_AVRG1_buf[RR1_p];

	PT_dptr->RR_AVRG1_buf[RR1_p] = qrs;
	PT_dptr->Recent_RR_M = RR1_sum/RR_BUFFER_SIZE; 
	if (++RR1_p == RR_BUFFER_SIZE) 
		RR1_p = 0;



	// ------ Update Selected Beat RR mean if qrs in range --------- //
	if (qrs >= PT_dptr->RR_Low_L && qrs <= PT_dptr->RR_High_L) {
		// ------ Update selective RR mean ----- //
		RR2_sum += qrs;
		RR2_sum -= PT_dptr->RR_AVRG2_buf[RR2_p];

		PT_dptr->RR_AVRG2_buf[RR2_p] = qrs;
		PT_dptr->RR_M = RR2_sum / RR_BUFFER_SIZE;
		if (++RR2_p == RR_BUFFER_SIZE) 
			RR2_p = 0;

		// --------- Update Limits ------------ //
		PT_dptr->RR_Low_L = PT_dptr->Recent_RR_M - (PT_dptr->Recent_RR_M << 1) / 25;
		PT_dptr->RR_High_L = PT_dptr->Recent_RR_M + (PT_dptr->Recent_RR_M << 2) / 25;
		PT_dptr->RR_Missed_L = PT_dptr->RR_M + (PT_dptr->RR_M * 33) / 50;
		PT_dptr->HR_State = REGULAR_HR;
	}
	// -------- Irregular heart-rate ---------- //
	else {
		PT_dptr->RR_Missed_L = PT_dptr->Recent_RR_M + (PT_dptr->Recent_RR_M * 33) / 50;
		PT_dptr->ThI1 >>= 1;
		PT_dptr->ThF1 >>= 1;
		PT_dptr->HR_State = IRREGULAR_HR;
	}
	
}


/**********************************************************************************

Fuction Name: UpdateThI

Parameter:
Input	:	PEAKI	- Pointer to the overal peak
			NOISE_F	- flag that indicates whether the peak is noise or not.

Returns	:	none	- Recieves PEAKI and updates Signal peak estimate (SPKI), Noise peak
peak estimate (NPKI)

Description: This function recursively updates the adaptive noise and signal thresholds in
the Integrated signal. Implements Eq 12-16.

**********************************************************************************/
void UpdateThI( uint16_t *PEAKI, int8_t NOISE_F)
{
	// ------ Update Noise & Signal Estimate ------ //
	if (NOISE_F) {
		PT_dptr->NPKI -= PT_dptr->NPKI >> 3;
		PT_dptr->NPKI += *PEAKI >> 3;
	}
	else {
		PT_dptr->SPKI -= PT_dptr->SPKI >> 3;
		PT_dptr->SPKI += *PEAKI >> 3;
	}

	// --------- Update Thresholds ---------------- //
	PT_dptr->ThI1 = PT_dptr->NPKI + ((PT_dptr->SPKI - PT_dptr->NPKI) >> 2);
	PT_dptr->ThI2 = PT_dptr->ThI1 >> 1;
}


/**********************************************************************************

Fuction Name: UpdateThF

Parameter:
Input	:	PEAKF	- Pointer to the overal peak
			NOISE_F	- Flag that indicates whether the peak is noise or not.

Returns	:	none	- Recieves PEAKF and updates Signal peak estimate in BP signal(SPKF), Noise peak
peak estimate (NPKF)

Description: This function recursively updates the adaptive noise and signal thresholds in 
the BP signal. Implements Eq 17-21.

**********************************************************************************/
void UpdateThF(int16_t *PEAKF, int8_t NOISE_F)
{
	// ------ Update Noise & Signal Estimate ------ //
	if (NOISE_F) {
		PT_dptr->NPKF -= PT_dptr->NPKF >> 3;
		PT_dptr->NPKF += *PEAKF >> 3;
	}
	else {
		PT_dptr->SPKF -= PT_dptr->SPKF >> 3;
		PT_dptr->SPKF += *PEAKF >> 3;
	}

	// --------- Update Thresholds ---------------- //
	PT_dptr->ThF1 = PT_dptr->NPKF + ((PT_dptr->SPKF - PT_dptr->NPKF) >> 2);
	PT_dptr->ThF2 = PT_dptr->ThF1 >> 1;
}



/**************************************************
Helper functions for debugging and easy management.
One could use this to debug the algorithm in real-time or
query any parameter in the algorithm such as outputs of
the filters, thresholds, running heart-rate and etc.
***************************************************/

// ------Returns the state machine's state- SEE header for understanding underlying states ------ //
int16_t PT_get_State_output(void) {
	return (PT_dptr->PT_state);
}



// ------Returns LP filter value ------ //
int16_t PT_get_LPFilter_output(void) {
	return (PT_dptr->LPF_val);
}

// ------Returns HP filter value ------ //
int16_t PT_get_HPFilter_output(void) {
	return (PT_dptr->HPF_val);
}

// ------Returns Dr filter value ------ //
int16_t PT_get_DRFilter_output(void) {
	return (PT_dptr->DRF_val);
}

// ------Returns MVA filter value ------ //
uint16_t PT_get_MVFilter_output(void) {
	return (PT_dptr->MVA_val);
}

// ------Returns SQR filter value ------ //
uint16_t PT_get_SQRFilter_output(void) {
	return (PT_dptr->SQF_val);
}



/************************************
Returns instantanous heart rate per minute.

Input - Fs : Sampling Frequency of the signal
*************************************/
int16_t PT_get_ShortTimeHR_output(int16_t Fs) {
	return (60 / (PT_dptr->Recent_RR_M / Fs));
}

/************************************
Returns robust heart rate per minute

Input - Fs : Sampling Frequency of the signal
*************************************/
int16_t PT_get_LongTimeHR_output(int16_t Fs) {
	return (60 / (PT_dptr->RR_M / Fs));
}


// ------Returns the main threshold integrated signal Th value ------ //
uint16_t PT_get_ThI1_output(void) {
	return (PT_dptr->ThI1);
}

// ------Returns the main threshold BP signal Th value ------ //
int16_t PT_get_ThF1_output(void) {
	return (PT_dptr->ThF1);
}

// ------Returns Signal Level Estimate in Integrated Signal ----- //
uint16_t PT_get_SKPI_output(void) {
	return (PT_dptr->SPKI);
}

// ------Returns Noise Level Estimate in Integrated Signal ------ //
uint16_t PT_get_NPKI_output(void) {
	return (PT_dptr->NPKI);
}

// ------Returns Signal Level Estimate in BP Signal ------ //
int16_t PT_get_SPKF_output(void) {
	return (PT_dptr->SPKF);
}

// ------Returns Noise Level Estimate in BP Signal ------ //
int16_t PT_get_NPKF_output(void) {
	return (PT_dptr->NPKF);
}

// ------Returns HR state -> Regular:0, Irregular:1 ------ //
int16_t PT_get_HRState_output(void) {
	return (PT_dptr->HR_State);
}


#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "freertos/semphr.h"
#include "esp_err.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event_loop.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "sdkconfig.h"
#include "lwip/err.h"
#include "lwip/sys.h"
#include "esp_http_server.h"
#include "esp_camera.h"
#include "esp_eth.h"
#include "tcpip_adapter.h"


#include "soc/i2s_reg.h"
#include "soc/i2s_struct.h"
#include "soc/io_mux_reg.h"


/*
ESP/I2S interface specs for the camera:
D0-D7 = must be stable on rising edge of pixelclock
PCLK = rising edge of pixelclock triggers Data Capture
HREF = horizontal reference (HSYNC), must be "high" for Data to be captuered
VSYNC = vertical sync must be "high" for Data to be captured.
*/
//esp32-cam PIN Map for OV7670:(same pinmap as ov2640!!)
#define CAM_PIN_PWDN    32   // power supply switch for cam 
#define CAM_PIN_RESET   -1   // camreset is tight to high=inactive on the board
#define CAM_PIN_XCLK    0
#define CAM_PIN_SIOD    26
#define CAM_PIN_SIOC    27

#define CAM_PIN_D7      35
#define CAM_PIN_D6      34
#define CAM_PIN_D5      39
#define CAM_PIN_D4      36
#define CAM_PIN_D3      21
#define CAM_PIN_D2      19
#define CAM_PIN_D1      18
#define CAM_PIN_D0      5
#define CAM_PIN_VSYNC   25
#define CAM_PIN_HSYNC   23
#define CAM_PIN_PCLK    22


// the camera config structure to be used with the camera driver
static camera_config_t camera_config =
{
    .pin_pwdn  = CAM_PIN_PWDN,
    .pin_reset = CAM_PIN_RESET,
    .pin_xclk = CAM_PIN_XCLK,
    .pin_sscb_sda = CAM_PIN_SIOD,
    .pin_sscb_scl = CAM_PIN_SIOC,

    .pin_d7 = CAM_PIN_D7,
    .pin_d6 = CAM_PIN_D6,
    .pin_d5 = CAM_PIN_D5,
    .pin_d4 = CAM_PIN_D4,
    .pin_d3 = CAM_PIN_D3,
    .pin_d2 = CAM_PIN_D2,
    .pin_d1 = CAM_PIN_D1,
    .pin_d0 = CAM_PIN_D0,
    .pin_vsync = CAM_PIN_VSYNC,
    .pin_href = CAM_PIN_HSYNC,
    .pin_pclk = CAM_PIN_PCLK,

    //XCLK 20MHz(or 10MHz for OV2640 double FPS by setting pll x 4)
    .xclk_freq_hz = 20000000,
//   .ledc_timer = LEDC_TIMER_0,  // not using LED dimming
//   .ledc_channel = LEDC_CHANNEL_0,

    .pixel_format = PIXFORMAT_RGB565,//YUV422,GRAYSCALE,RGB565,JPEG       this is the output format!!!!!!!!!!!!
    .frame_size = FRAMESIZE_VGA,//640x480 biggest size for ov7670

    .jpeg_quality = 10, //not used
    .fb_count = 2 //number of framebuffers to use for capturing, if > 1, i2s runs in continuous mode.
};

// you may specify your APs credential here (or from sysconfig) being hardcoded !! ?? if you want that.Otherwise just edit logintable via serial on startup!
//#define CONFIG_ESP_WIFI_SSID "dummy"
//#define CONFIG_ESP_WIFI_PASSWORD "bunny"

static const char *TAG = "espcam";
uint8_t wifi_retrys = 0;
/* wifi_status:
0=not initialized;
1= normal run, we are connected;
2=disconnected due to invalid ssid/pass;
3=disconnected to to connection loss
4=undefined, we issued a connect() and are waiting for an event to happen
*/
uint8_t wifi_status=0;


//protos:
void camserver(void);

esp_err_t wifi_handler(void *ctx, system_event_t *event);
void wifi_connect(char *ssid, char *passwd);
int wifi_try(char *ssid, char *passwd);
int wifi_startup(void);


void editlogintab(void);
void strcopy( char *s, char *d, int len);
//serial io
void putcc(char c);
char getcc(void);
void getss(char *buf);
void putss(const char *ps);





void app_main(void)
{
    esp_err_t ret;
// init:
    gpio_set_direction(33, GPIO_MODE_OUTPUT); // Debug Led
    gpio_set_level(33, 0); // turn debug led on during boot

    ret = nvs_flash_init(); //needed for wifi and PHY and stored AP logins
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    ESP_LOGI(TAG, "Hit SPACE to enter +++LoginEdit+++...2secs");
    vTaskDelay(2000/portTICK_PERIOD_MS);
    if (fgetc(stdin) == 0x20) editlogintab();

// get the camera going
    ESP_LOGI(TAG, "Init Camera.........");
    ret=esp_camera_init(&camera_config);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG,"Boot: camera init failed....Restarting System now...............>>>>>>\n");
        fflush(stdout);
        esp_restart();
    }

// set framesize to standard VGA
    sensor_t * s = esp_camera_sensor_get();
    s->set_framesize(s, (framesize_t)FRAMESIZE_VGA);

//    vTaskDelay(1000/portTICK_PERIOD_MS);  // wait a little before starting wifi to get the debug print done

    if (wifi_startup() == 0) //wifi takes a bit with its logging output...
    {
        ESP_LOGE(TAG, "Could not find a known Wifi Network!!!");
        vTaskDelay(10000/portTICK_PERIOD_MS);
        esp_restart(); // keep trying by reseting the system
    }
    gpio_set_level(33, 1); // turn debug led off, boot done

    camserver(); //this task becomes the webserver for control

    // we shouldnt get here.
}



//event handler wifi. this function executes in a different task!
esp_err_t wifi_handler(void *ctx, system_event_t *event)
{
    switch(event->event_id)
    {
    case SYSTEM_EVENT_STA_START: // we entered STA wifi mode
        esp_wifi_connect(); // start scanning...and connect...or sta_disconnect
        break;
    case SYSTEM_EVENT_STA_GOT_IP:  // if connect, we got ip
        ESP_LOGI(TAG, "+++CONNECTED+++: got ip:%s",ip4addr_ntoa(&event->event_info.got_ip.ip_info.ip));
        wifi_retrys = 0;
        wifi_status=1; //online
        break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
        ESP_LOGI(TAG,"STA_DISCONNECTED,reason:%d\n", event->event_info.disconnected.reason);

        if (wifi_status != 3)
        {
            switch (event->event_info.disconnected.reason)
            {
            case 201:	//15=invalid password or not present; 201=ssid not found
            case 15:	// if ssid is 0, we will not get here as wifi will just scan.
                wifi_status=2; // we disconnected due to invalid ssid or passwd
                break;
            default:
                wifi_status=3; // we lost connection to AP, lets retry. or esp_wifi_disconnect() was called
                break;

            }
        }

        if (wifi_status == 3) // just reset, any reconnect upsets the lwip stack
        {
               vTaskDelay(10000/portTICK_PERIOD_MS);
                esp_restart(); // we just reset the board as the TCPserver will likely hang. also we can connect to different AP then.
 
        }

        break;
    default:
        //ESP_LOGI(TAG,"got unknown wifi event:%d!!",event->event_id); // some events are happening, nothing to worry.
        break;
    }
    return ESP_OK;
}

// wifi connect to router with credentials supplied in config
void wifi_connect(char *ssid, char *passwd)
{
    wifi_config_t wifi_config;
    int ret;

    // from here, we set the APs credentials and start the connection process.
    // to change ssid/passwd and reconnect
    memset(&wifi_config, 0, sizeof(wifi_config_t));
    snprintf((char*)wifi_config.sta.ssid, 32, "%s", ssid);
    snprintf((char*)wifi_config.sta.password, 64, "%s", passwd);
    ESP_LOGI(TAG, "...connecting to AP SSID:%s PASSWD:%s",ssid, passwd);

    if (wifi_status) // wifi is already running, so here we just set the changed ssid/passwd parameters and (re)connect to that AP
    {
        // we assume we are disconnected at this stage!
        if (esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config)  != ESP_OK) // set ssid and passwd of wanted AccessPoint to connect to
        {
            ret=6;
            goto wifierr;
        }

        if (esp_wifi_connect() != ESP_OK) // connect with a new ssid/passwd
        {
            ret=7;
            goto wifierr;
        }
        wifi_status=4; //undefined

        return;
    }

// do first time wifi init stuff:

    if (esp_event_loop_init(wifi_handler, NULL) != ESP_OK) // start the event loop task
    {
        ret=1;
        goto wifierr;
    }

    tcpip_adapter_init(); // init lwIP/TCPIP stack. from 4.1 its esp_netif_init().

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    if (esp_wifi_init(&cfg) != ESP_OK) // WiFi control structure, RX/TX buffer, WiFi NVS structure etc, start WiFi task.
    {
        ret=2;
        goto wifierr;
    }
    if (esp_wifi_set_mode(WIFI_MODE_STA) != ESP_OK) // set Station mode(clientmode)
    {
        ret=3;
        goto wifierr;
    }

    if (esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config)  != ESP_OK) // set ssid and passwd of wanted AccessPoint to connect to
    {
        ret=4;
        goto wifierr;
    }
    if (esp_wifi_start() != ESP_OK) // startup the Wifi process..ie. it starts scanning and will connect
    {
        ret=5;
        goto wifierr;
    }
    esp_wifi_set_ps(WIFI_PS_NONE); // disable powersave. this will make ping go much faster: DEFAULT POWERMODE IS.WIFI_PS_MIN_MODEM
    wifi_status=4; //undefined
    return;
wifierr:
    ESP_LOGE(TAG, "Wifi connect error : %d",ret);
}

/* try to connect to an AccessPoint with given credentials
exit:
0=fail;
1=OK, we are connected
*/
int wifi_try(char *ssid, char *passwd)
{
    int count;

    count=100; // 10 sec timeout

    wifi_connect(ssid,passwd);
    while (count--) //try for 1 secs
    {
        vTaskDelay(100/portTICK_PERIOD_MS);
        switch (wifi_status)
        {
        case 1:
            return 1; //online
        case 2:
        case 3:
            return 0; // disconnected
        default:
            break;
        }
    }
    return 0;
}

/* WIFI login credentials saved in NVS:

The NVS-interface is similar to operating files on a computer:
open the file (nvs_open), write a file (nvs_set_xxx), save document(nvs_commit), close the file (nvs_close)
open the file (nvs_open), reading the file (nvs_get_xxx), close the file (nvs_close)

This function reads a table of ssid_name/password pairs from nvs.
"lastindex"  will supply its logindata to wifi_connect, as its most likely to be used again.
else or on fail, it will interate through all stored name/passwd entrys until successfull wifi connect happens, and store its index in "lastindex".

if all fail, it will supply the name/passwd from the config data.
if that fails too, it will remain in a loop, blinking the onboard statusLED (indicating NoWifiConnect).
The user must then update the logintable via serial interface.

exit: 0=fail,1=ok, wifi is up
on fail, we just run without wifi.?!
*/
#define FILENAME "LoginData"
#define DATANAME "LoginTab"
#define nentrys 10
#define nlength 32
//tableformat: tab[number of strings][length of each string]
struct logintable
{
    int lastindex; // range: 0 to n-1
    // 10 entrys of name/passwd Login-pairs of max length 19 each. (last char is 0-terminator)
    char name[nentrys][nlength]; //array of 10 names at 20chars length
    char pass[nentrys][nlength]; // array of 10 passwds at 20chars length
};

int wifi_startup(void)
{
    nvs_handle filehandle=0;
    size_t bytes = 0;
    esp_err_t ret;
    void *pmem=NULL;
    struct logintable *ptab;
    int i;

    // Open
    ret = nvs_open(FILENAME, NVS_READWRITE, &filehandle); // open a file in nvs, existing or not.
    if (ret != ESP_OK) 		goto reterror; // this should not happen as we allready inited nvs in main.

    pmem = malloc(sizeof(struct logintable));

    if (!pmem)
    {
        ret = -1;
        goto reterror; // malloc failed
    }

    ret = nvs_get_blob(filehandle, DATANAME, NULL, &bytes); // just get the size of the stored filedata. This fails if the record is not found

    if ((bytes != sizeof(struct logintable))||(ret !=ESP_OK)) // if DATANAME hasnt been stored before(0) or has different size
    {
        memset(pmem,0,sizeof(struct logintable)); // clear memory
        bytes = sizeof(struct logintable);
        ret = nvs_set_blob(filehandle, DATANAME, pmem, bytes); // save empty table
        if (ret != ESP_OK) goto reterror;
    }
    else // read in the table
    {
        ret = nvs_get_blob(filehandle, DATANAME, pmem, &bytes);
        if (ret != ESP_OK) goto reterror;
    }
    nvs_close(filehandle); // we need to close it, as wifi will also uses NVS
    filehandle = 0;

    // now the table is in memory (or empty), lets check if last used AP credentials work.
    ptab = pmem;
    if (ptab->lastindex < nentrys)
    {
        i = ptab->lastindex;
        if (ptab->name[i][0]) //...and name exists!
        {
            ret = wifi_try(&ptab->name[i][0], &ptab->pass[i][0]); // connect to last known AP
            if (ret) goto retok; // success
        }
    }

    // now walk through the table and test each entry for valid wifi connect
    for (i=0; i<nentrys; i++)
    {
        if (ptab->name[i][0]) // if first char is not zero, so there is a name in it
        {
            ret = wifi_try(&ptab->name[i][0], &ptab->pass[i][0]);
            if (ret) goto retok; // success
        }
    }

    ret = 0;// we could not connect the wifi from the table and give up here!

    // all entrys failed, now try the name/pass given by the configuration or sourcecode, if there

#ifdef 	CONFIG_ESP_WIFI_SSID
    if (strlen(CONFIG_ESP_WIFI_SSID))
    {
        ESP_LOGI(TAG, "trying to connect to hardcoded ssid");

        if (wifi_try(CONFIG_ESP_WIFI_SSID, CONFIG_ESP_WIFI_PASSWORD))
            ret = 1;
    }
#endif

    goto doreturn;


retok:
//check, lastindex is different to i, ie. a different login was used as last time. update NVS then.
    if (ptab->lastindex != i)
    {
        ptab->lastindex = i;
        ret = nvs_open(FILENAME, NVS_READWRITE, &filehandle);
        if (ret != ESP_OK) 		goto reterror;
        bytes = sizeof(struct logintable);
        ret = nvs_set_blob(filehandle, DATANAME, pmem, bytes); // save empty table
        if (ret != ESP_OK) goto reterror;
        ESP_LOGI(TAG, "updated lastindex!!");
    }

    ret = 1; //OK
    goto doreturn;
reterror:
    if (ret != ESP_OK) ESP_LOGE(TAG, "Fatal error occurred in wifi_startup(): %d ; %s",ret, esp_err_to_name(ret));
    ret = 0; //error
doreturn:
    if (pmem) free(pmem);
    if (filehandle) nvs_close(filehandle);
    return ret;

}



void putcc(char c)
{
    fputc(c, stdout);
}

char getcc(void)
{
    char c;

    while (1)
    {
        vTaskDelay(10/portTICK_PERIOD_MS); //min 10 for watchdog not to trigger!
        c = fgetc(stdin);
        if (c!=0xFF) break;
    }
    putcc(c);
    return c;
}

void getss(char *buf)
{
    char *ps, c;
    ps=buf;
    while (1)
    {
        c=getcc();
        if (( c == 0x0d)||(c==0x0a)) // CR LF
            break;
        *ps++=c;
    }
    *ps=0;
    putcc(0x0d);
    putcc(0x0a);
}

void putss(const char *ps)
{
    while (*ps)
    {
        putcc(*ps++);
    }
}

// string copy where len is the total fieldlength including 0.
void strcopy( char *s, char *d, int len)
{
    len--;
    while (len--&&*s) *d++=*s++;
    *d=0;
}


const char *menue="***Menue***\n"
                  "l-list entrys\n"
                  "e<num>-edit entry\n"
                  "d<num>-delete entry\n"
                  "s-save changes\n"
                  "q-quit\n"
                  ;
const char *prompt="\nespcam>";


/* edit the NVS table for ssid/passwd's
This is called on startup if a SPACE kay was pressed after Reset.
*/
void editlogintab(void)
{
    char buf[100],c;

    nvs_handle filehandle=0;
    size_t bytes = 0;
    esp_err_t ret;
    void *pmem=NULL;
    struct logintable *ptab;
    int i,flag=0;

    // Open
    ret = nvs_open(FILENAME, NVS_READWRITE, &filehandle); // open a file in nvs, existing or not.
    if (ret != ESP_OK) 		ESP_LOGI(TAG, "nvs_open failed!!!");

    pmem = malloc(sizeof(struct logintable));

    if (!pmem)
    {
        ESP_LOGI(TAG, "malloc failed!!!");
    }

    ret = nvs_get_blob(filehandle, DATANAME, NULL, &bytes); // just get the size of the stored filedata. This fails if the record is not found

    if ((bytes != sizeof(struct logintable))||(ret !=ESP_OK)) // if DATANAME hasnt been stored before(0) or has different size
    {
        memset(pmem,0,sizeof(struct logintable)); // clear memory
        bytes = sizeof(struct logintable);
        ret = nvs_set_blob(filehandle, DATANAME, pmem, bytes); // save empty table
        if (ret != ESP_OK) ESP_LOGI(TAG, "nvs_set_blob failed!!!");
    }
    else // read in the table
    {
        ret = nvs_get_blob(filehandle, DATANAME, pmem, &bytes);
        if (ret != ESP_OK) 	ESP_LOGI(TAG, "nvs_get_blob failed!!!");
    }
    ptab = pmem;

    putss(menue);
    putss(prompt);

    while(1) // menue loop
    {
        c = getcc();
        switch(c)
        {
        case 'l': //list
            putss("\nList Logintable:\n");
            sprintf(buf,"LastUsed Entry: %d\n",ptab->lastindex);
            putss(buf);
            for (i=0; i<nentrys; i++)
            {
                sprintf(buf,"%d: %s   %s\n",i,&ptab->name[i][0], &ptab->pass[i][0]);
                putss(buf);
            }
            break;

        case 'e': //edit
            putss("\nEdit:Enter entry (0 to 9):");
            c = getcc();
            c -= 0x30;
            if (c>9) break;
            i=c;
            putss("\nEnter SSID:");
            getss(buf);
            strcopy(buf,&ptab->name[i][0],nlength);
            putss("Enter PASSWD:");
            getss(buf);
            strcopy(buf,&ptab->pass[i][0],nlength);
            ptab->lastindex = 0xff; // invalidate after edit
            break;

        case 'd': //delete
            putss("\nDelete:Enter entry (0 to 9):");
            c = getcc();
            c -= 0x30;
            if (c>9) break;
            i=c;
            ptab->name[i][0]=0;
            ptab->pass[i][0]=0;
            ptab->lastindex = 0xff; // invalidate after edit
            putss("Deleted");
            break;

        case 's': //save
            bytes = sizeof(struct logintable);
            ret = nvs_set_blob(filehandle, DATANAME, pmem, bytes); // save changed table
            if (ret != ESP_OK) ESP_LOGI(TAG, "nvs_set_blob failed!!!");
            putss("\nSaved!");
            break;

        case 'q': //quit
            flag=1;
            break;

        default:
            putss(menue);
        }
        putss(prompt);


        if (flag) break;
    }

    if (pmem) free(pmem);
    if (filehandle) nvs_close(filehandle);

}



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "LCD.h"

/* *****************************************************************
Name:		initLCD
Inputs:		none
Outputs:	none
Description:Configures the Data / command 
			ports and initializes the LCD
******************************************************************** */
void initLCD(void)
{
	/* Configure the data ports and pins */
	configLCDPorts();

	/* Initialize the LCD controller as determined by instructions */
	lcd_init_4f();
	
	_delay_ms(100);
}

/* *****************************************************************
Name:		configLCDPorts
Inputs:		none
Outputs:	none
Description:maps the data and control pins to the uC i/o ports
******************************************************************** */
void configLCDPorts(void)
{
	/* configure the microprocessor pins for the data lines */
	lcd_Data_DDR |= (1<<lcd_D7_bit) | (1<<lcd_D6_bit) | (1<<lcd_D5_bit) | (1<<lcd_D4_bit);
	
	/* configure the microprocessor pins for the control lines */
	lcd_Ctlr_DDR |= (1<<lcd_RW_bit) | (1<<lcd_RS_bit) | (1<<lcd_E_bit);
	
	/* Turn on LCD */
	DDRB |= (1<<lcd_ONOFF_bit);
}


/* *****************************************************************
Name:		lcd_init_4f
Inputs:		none
Outputs:	none
Description:initializes the LCD for 4-bit data interface; uses the 
			busy flag instead of time delay when possible
******************************************************************** */
void lcd_init_4f(void)
{
	/* Power-up delay */
	_delay_ms(50);                                 // initial 40 mSec delay

	/* IMPORTANT - At this point the LCD module is in the 8-bit mode and it is expecting to receive
	   8 bits of data, one bit on each of its 8 data lines, each time the 'E' line is pulsed.
	
	 Since the LCD module is wired for the 4-bit mode, only the upper four data lines are connected to
	 the microprocessor and the lower four data lines are typically left open.  Therefore, when
	 the 'E' line is pulsed, the LCD controller will read whatever data has been set up on the upper
	 four data lines and the lower four data lines will be high (due to internal pull-up circuitry).
	
	 Fortunately the 'FunctionReset' instruction does not care about what is on the lower four bits so
	 this instruction can be sent on just the four available data lines and it will be interpreted
	 properly by the LCD controller.  The 'lcd_write_4' subroutine will accomplish this if the
	 control lines have previously been configured properly. */

	/* Set up the RS, E, and RW lines for the 'lcd_write_4' function. */
	set_RS_LOW_Instr;	// Select the Instruction Register (RS low)
	disable_E_Pin;		// Make sure E is initially low
	set_RW_LOW_write;	// write to LCD module (RW low)

	/* Reset the LCD controller */
	lcd_write_4(lcd_FunctionReset);		// First part of reset sequence
	_delay_us(10);                      // Delay of 10 us
	
	lcd_write_4(lcd_FunctionReset);		// Second part of reset sequence
	_delay_us(200);						// Delay of 200 us

	lcd_write_4(lcd_FunctionReset);		// Third part of reset sequence
	_delay_us(80);						// This delay is omitted in the data sheet

	/* Preliminary Function Set instruction - used only to set the 4-bit mode.
	 The number of lines or the font cannot be set at this time since the controller is still in the
	 8-bit mode, but the data transfer mode can be changed since this parameter is determined by one
	 of the upper four bits of the instruction. */
	
	lcd_write_4(lcd_FunctionSet4bit);	// Set 4-bit mode
	// From this point on the busy flag is available

	// Function Set instruction
	lcd_check_BF_4();    // Makes sure LCD controller is ready
                         
	lcd_write_instruction_4f(lcd_FunctionSet4bit);  // Set mode, lines, and font

	/*The next three instructions are specified in the data sheet as part of the initialization routine,
	  so it is a good idea (but probably not necessary) to do them just as specified and then redo them
	  later if the application requires a different configuration.*/

	/* Display On/Off Control instruction */
	lcd_check_BF_4();
	lcd_write_instruction_4f(lcd_DisplayOff);       // Turn display OFF

	/* Clear Display instruction */
	lcd_check_BF_4();
	lcd_write_instruction_4f(lcd_Clear);            // Clear display RAM
	
	/* Entry Mode Set instruction */
	lcd_check_BF_4();
	lcd_write_instruction_4f(lcd_EntryMode);        // Set desired shift characteristics
	/*This is the end of the LCD controller initialization as specified in the data sheet, but the display
	  has been left in the OFF condition.  This is a good time to turn the display back ON. */

	/* Display On/Off Control instruction */
	lcd_check_BF_4();
	lcd_write_instruction_4f(lcd_DisplayOn);        // turn the display ON
}

/* *****************************************************************
Name:		updateLCDScreen
Inputs:		two pointers to a uint8 type data and 2 values, one for each row
Outputs:	none
Description:commands writing on LCD line by line 
******************************************************************** */
void updateLCDScreen(uint8_t row, char * s1, uint8_t data, char * s2)
{
	/* convert data to string [buf] */
	char data2char[4] = "   ";
	char charRow[17];
	char emptyString[] = "                 ";	//17 empty spaces
	
	if (data != NONE)	{ itoa(data, data2char, 10);}
	if (strcmp(s1, "NONE") == 0 ) { s1 = ""; }
	if (strcmp(s2, "NONE") == 0 ) { s2 = ""; }
	
	/* Create the strings to be displayed */
	snprintf( charRow, sizeof charRow, "%s%s%s%s", s1, data2char, s2, emptyString );
	if (strcmp(s1, "CLEAR") == 0 ) { snprintf( charRow, sizeof charRow, "%s", emptyString ); };
		
	switch(row) {
		case 1: /* ======= Line 1 ======= */
			lcd_write_instruction_4f(lcd_SetCursor | lcd_LineOne);
			break;
		case 2: /* ======= Line 2 ======= */
			lcd_write_instruction_4f(lcd_SetCursor | lcd_LineTwo);
			break;
	}
	lcd_write_string_4f((unsigned char*) charRow);
}

/* *****************************************************************
Name:		lcd_write_string_4f
Inputs:		string to be displayed (stringData)
Outputs:	none
Description:writes a string of characters on LCD; uses the busy flag
******************************************************************** */
void lcd_write_string_4f(uint8_t stringData[])
{
    volatile int i = 0;                             // Character counter
    while (stringData[i] != 0)
    {
        lcd_check_BF_4();                           // Make sure LCD controller is ready    
        lcd_write_character_4f(stringData[i]);
        i++;
    }
}


/* *****************************************************************
Name:		lcd_write_character_4f
Inputs:		character to be displayed (theChar)
Outputs:	none
Description:sends a byte to the LCD data register, configures RW 
			(busy flag is implemented)
******************************************************************** */
void lcd_write_character_4f(uint8_t theChar)
{
    set_RW_LOW_write;					// Write to LCD module (RW low)
    set_RS_HIGH_Data;					// Select the Data Register (RS high)
    disable_E_Pin;						// Make sure E is initially low
    lcd_write_4(theChar);				// Write the upper 4-bits of the data
    lcd_write_4(theChar << 4);			// Write the lower 4-bits of the data
}

/* *****************************************************************
Name:		lcd_write_instruction_4f
Inputs:		character to be displayed (theChar)
Outputs:	none
Description:sends a byte to the LCD instruction register, configures RW 
			(busy flag is implemented)
******************************************************************** */
void lcd_write_instruction_4f(uint8_t theInstruction)
{
    set_RW_LOW_write;					// Write to LCD module (RW low)
    set_RS_LOW_Instr;					// Select the Data Register (RS high)
    disable_E_Pin;						// Make sure E is initially low
    lcd_write_4(theInstruction);		// Write the upper 4-bits of the data
    lcd_write_4(theInstruction << 4);	// Write the lower 4-bits of the data
}


/* *****************************************************************
Name:		lcd_write_4
Inputs:		(theByte) is a byte with the desired 4 bits in the upper nibble
Outputs:	none
Description:sends 4 bits to the LCD module; 
			RS is configured for the expected register
			E is low, RW is low
			uses either time delays or the busy flag
******************************************************************** */
void lcd_write_4(uint8_t theNibble)
{
	uint8_t mask[4] = {0};
	for (uint8_t i = 0; i < 4; i++)
	{
		if (theNibble & 1 << (7 - i))
		{
			mask[i] = 1;
		}
	}
	
	/* Clear bits in first step */
	lcd_Data_Port &= ~((1 << lcd_D7_bit) | (1 << lcd_D6_bit) | (1 << lcd_D5_bit) | (1 << lcd_D4_bit));

	/* Set bits where necessary */
	lcd_Data_Port |= ((mask[0]) << lcd_D7_bit | (mask[1]) << lcd_D6_bit | (mask[2]) << lcd_D5_bit | (mask[3]) << lcd_D4_bit);

    /* Write the data */
    enable_E_Pin;                   // Enable pin high
    _delay_us(1);                   // implement 'Data set-up time' (80 nS) and 'Enable pulse width' (230 nS)
    disable_E_Pin;                  // Enable pin low
    _delay_us(1);                   // implement 'Data hold time' (10 nS) and 'Enable cycle time' (500 nS)
}


/* *****************************************************************
Name:		lcd_check_BF_4
Inputs:		none
Outputs:	none
Description:checks busy flag and wait until LCD is ready 
			Desired information is the higher nibble, however both are read
			data is read while 'E' is high
******************************************************************** */
void lcd_check_BF_4(void)
{
	
    uint8_t busy_flag_copy;             // busy flag 'mirror'

    set_D7_input;						// set D7 data direction to input
    set_RS_LOW_Instr;					// select the Instruction Register (RS low)
    set_RW_HIGH_read;					// read from LCD module (RW high)

    do
    {
        busy_flag_copy = 0;                         // initialize busy flag 'mirror'
        lcd_Ctlr_Port |= (1<<lcd_E_bit);            // Enable pin high
        _delay_us(1);                               // implement 'Delay data time' (160 nS) and 'Enable pulse width' (230 nS)

        busy_flag_copy |= (lcd_D7_pin & (1<<lcd_D7_bit));  // get actual busy flag status

        lcd_Ctlr_Port &= ~(1<<lcd_E_bit);           // Enable pin low
        _delay_us(1);                               // implement 'Address hold time' (10 nS), 'Data hold time' (10 nS), and 'Enable cycle time' (500 nS )
        
// read and discard alternate nibbles (D3 information)
        lcd_Ctlr_Port |= (1<<lcd_E_bit);            // Enable pin high
        _delay_us(1);                               // implement 'Delay data time' (160 nS) and 'Enable pulse width' (230 nS)
        lcd_Ctlr_Port &= ~(1<<lcd_E_bit);           // Enable pin low
        _delay_us(1);                               // implement 'Address hold time (10 nS), 'Data hold time' (10 nS), and 'Enable cycle time' (500 nS )

    } while (busy_flag_copy);                       // check again if busy flag was high

// arrive here if busy flag is clear -  clean up and return 
    set_RW_LOW_write;               // write to LCD module (RW low)
    set_D7_output;                  // reset D7 data direction to output	
}


#include <stdio.h>
/*******************************/
/*** Created by Ovidiu Sabau ***/
/***	7th January 2022	 ***/
/*******************************/

/*----------------- Include -------------------*/
#include "LCD.h"

/*-------------- Main function ----------------*/
int main(void)
{
	uint8_t temperature = 16; //C
	uint8_t rel_humidity = 42; //%
	
	initLCD();
	//updateLCDScreen(row on LCD, "Text 1", number, "Text 2");		
	updateLCDScreen(1, "Hello there!", NONE, "NONE"); _delay_ms(1000);
	updateLCDScreen(1, "CLEAR", NONE, "NONE");
	
	_delay_ms(1000);
	
	updateLCDScreen(1, "Temperature: ", temperature, "C");
	updateLCDScreen(2, "Humidity: ", rel_humidity, "%");

	return 0;
}
#include <stdio.h>
/*
** $Id: lapi.c $
** Lua API
** See Copyright Notice in lua.h
*/

#define lapi_c
#define LUA_CORE

#include "lprefix.h"


#include <limits.h>
#include <stdarg.h>
#include <string.h>

#include "lua.h"

#include "lapi.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lgc.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"
#include "lundump.h"
#include "lvm.h"



const char lua_ident[] =
  "$LuaVersion: " LUA_COPYRIGHT " $"
  "$LuaAuthors: " LUA_AUTHORS " $";



/*
** Test for a valid index (one that is not the 'nilvalue').
** '!ttisnil(o)' implies 'o != &G(L)->nilvalue', so it is not needed.
** However, it covers the most common cases in a faster way.
*/
#define isvalid(L, o)	(!ttisnil(o) || o != &G(L)->nilvalue)


/* test for pseudo index */
#define ispseudo(i)		((i) <= LUA_REGISTRYINDEX)

/* test for upvalue */
#define isupvalue(i)		((i) < LUA_REGISTRYINDEX)


static TValue *index2value (lua_State *L, int idx) {
  CallInfo *ci = L->ci;
  if (idx > 0) {
    StkId o = ci->func + idx;
    api_check(L, idx <= L->ci->top - (ci->func + 1), "unacceptable index");
    if (o >= L->top) return &G(L)->nilvalue;
    else return s2v(o);
  }
  else if (!ispseudo(idx)) {  /* negative index */
    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
    return s2v(L->top + idx);
  }
  else if (idx == LUA_REGISTRYINDEX)
    return &G(L)->l_registry;
  else {  /* upvalues */
    idx = LUA_REGISTRYINDEX - idx;
    api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
    if (ttislcf(s2v(ci->func)))  /* light C function? */
      return &G(L)->nilvalue;  /* it has no upvalues */
    else {
      CClosure *func = clCvalue(s2v(ci->func));
      return (idx <= func->nupvalues) ? &func->upvalue[idx-1]
                                      : &G(L)->nilvalue;
    }
  }
}


static StkId index2stack (lua_State *L, int idx) {
  CallInfo *ci = L->ci;
  if (idx > 0) {
    StkId o = ci->func + idx;
    api_check(L, o < L->top, "unacceptable index");
    return o;
  }
  else {    /* non-positive index */
    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
    api_check(L, !ispseudo(idx), "invalid index");
    return L->top + idx;
  }
}


LUA_API int lua_checkstack (lua_State *L, int n) {
  int res;
  CallInfo *ci;
  lua_lock(L);
  ci = L->ci;
  api_check(L, n >= 0, "negative 'n'");
  if (L->stack_last - L->top > n)  /* stack large enough? */
    res = 1;  /* yes; check is OK */
  else {  /* no; need to grow stack */
    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
    if (inuse > LUAI_MAXSTACK - n)  /* can grow without overflow? */
      res = 0;  /* no */
    else  /* try to grow stack */
      res = luaD_growstack(L, n, 0);
  }
  if (res && ci->top < L->top + n)
    ci->top = L->top + n;  /* adjust frame top */
  lua_unlock(L);
  return res;
}


LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
  int i;
  if (from == to) return;
  lua_lock(to);
  api_checknelems(from, n);
  api_check(from, G(from) == G(to), "moving among independent states");
  api_check(from, to->ci->top - to->top >= n, "stack overflow");
  from->top -= n;
  for (i = 0; i < n; i++) {
    setobjs2s(to, to->top, from->top + i);
    to->top++;  /* stack already checked by previous 'api_check' */
  }
  lua_unlock(to);
}


LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
  lua_CFunction old;
  lua_lock(L);
  old = G(L)->panic;
  G(L)->panic = panicf;
  lua_unlock(L);
  return old;
}


LUA_API lua_Number lua_version (lua_State *L) {
  UNUSED(L);
  return LUA_VERSION_NUM;
}



/*
** basic stack manipulation
*/


/*
** convert an acceptable stack index into an absolute index
*/
LUA_API int lua_absindex (lua_State *L, int idx) {
  return (idx > 0 || ispseudo(idx))
         ? idx
         : cast_int(L->top - L->ci->func) + idx;
}


LUA_API int lua_gettop (lua_State *L) {
  return cast_int(L->top - (L->ci->func + 1));
}


LUA_API void lua_settop (lua_State *L, int idx) {
  CallInfo *ci;
  StkId func, newtop;
  ptrdiff_t diff;  /* difference for new top */
  lua_lock(L);
  ci = L->ci;
  func = ci->func;
  if (idx >= 0) {
    api_check(L, idx <= ci->top - (func + 1), "new top too large");
    diff = ((func + 1) + idx) - L->top;
    for (; diff > 0; diff--)
      setnilvalue(s2v(L->top++));  /* clear new slots */
  }
  else {
    api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
    diff = idx + 1;  /* will "subtract" index (as it is negative) */
  }
  api_check(L, L->tbclist < L->top, "previous pop of an unclosed slot");
  newtop = L->top + diff;
  if (diff < 0 && L->tbclist >= newtop) {
    lua_assert(hastocloseCfunc(ci->nresults));
    luaF_close(L, newtop, CLOSEKTOP, 0);
  }
  L->top = newtop;  /* correct top only after closing any upvalue */
  lua_unlock(L);
}


LUA_API void lua_closeslot (lua_State *L, int idx) {
  StkId level;
  lua_lock(L);
  level = index2stack(L, idx);
  api_check(L, hastocloseCfunc(L->ci->nresults) && L->tbclist == level,
     "no variable to close at given level");
  luaF_close(L, level, CLOSEKTOP, 0);
  level = index2stack(L, idx);  /* stack may be moved */
  setnilvalue(s2v(level));
  lua_unlock(L);
}


/*
** Reverse the stack segment from 'from' to 'to'
** (auxiliary to 'lua_rotate')
** Note that we move(copy) only the value inside the stack.
** (We do not move additional fields that may exist.)
*/
static void reverse (lua_State *L, StkId from, StkId to) {
  for (; from < to; from++, to--) {
    TValue temp;
    setobj(L, &temp, s2v(from));
    setobjs2s(L, from, to);
    setobj2s(L, to, &temp);
  }
}


/*
** Let x = AB, where A is a prefix of length 'n'. Then,
** rotate x n == BA. But BA == (A^r . B^r)^r.
*/
LUA_API void lua_rotate (lua_State *L, int idx, int n) {
  StkId p, t, m;
  lua_lock(L);
  t = L->top - 1;  /* end of stack segment being rotated */
  p = index2stack(L, idx);  /* start of segment */
  api_check(L, (n >= 0 ? n : -n) <= (t - p + 1), "invalid 'n'");
  m = (n >= 0 ? t - n : p - n - 1);  /* end of prefix */
  reverse(L, p, m);  /* reverse the prefix with length 'n' */
  reverse(L, m + 1, t);  /* reverse the suffix */
  reverse(L, p, t);  /* reverse the entire segment */
  lua_unlock(L);
}


LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
  TValue *fr, *to;
  lua_lock(L);
  fr = index2value(L, fromidx);
  to = index2value(L, toidx);
  api_check(L, isvalid(L, to), "invalid index");
  setobj(L, to, fr);
  if (isupvalue(toidx))  /* function upvalue? */
    luaC_barrier(L, clCvalue(s2v(L->ci->func)), fr);
  /* LUA_REGISTRYINDEX does not need gc barrier
     (collector revisits it before finishing collection) */
  lua_unlock(L);
}


LUA_API void lua_pushvalue (lua_State *L, int idx) {
  lua_lock(L);
  setobj2s(L, L->top, index2value(L, idx));
  api_incr_top(L);
  lua_unlock(L);
}



/*
** access functions (stack -> C)
*/


LUA_API int lua_type (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return (isvalid(L, o) ? ttype(o) : LUA_TNONE);
}


LUA_API const char *lua_typename (lua_State *L, int t) {
  UNUSED(L);
  api_check(L, LUA_TNONE <= t && t < LUA_NUMTYPES, "invalid type");
  return ttypename(t);
}


LUA_API int lua_iscfunction (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return (ttislcf(o) || (ttisCclosure(o)));
}


LUA_API int lua_isinteger (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return ttisinteger(o);
}


LUA_API int lua_isnumber (lua_State *L, int idx) {
  lua_Number n;
  const TValue *o = index2value(L, idx);
  return tonumber(o, &n);
}


LUA_API int lua_isstring (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return (ttisstring(o) || cvt2str(o));
}


LUA_API int lua_isuserdata (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return (ttisfulluserdata(o) || ttislightuserdata(o));
}


LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
  const TValue *o1 = index2value(L, index1);
  const TValue *o2 = index2value(L, index2);
  return (isvalid(L, o1) && isvalid(L, o2)) ? luaV_rawequalobj(o1, o2) : 0;
}


LUA_API void lua_arith (lua_State *L, int op) {
  lua_lock(L);
  if (op != LUA_OPUNM && op != LUA_OPBNOT)
    api_checknelems(L, 2);  /* all other operations expect two operands */
  else {  /* for unary operations, add fake 2nd operand */
    api_checknelems(L, 1);
    setobjs2s(L, L->top, L->top - 1);
    api_incr_top(L);
  }
  /* first operand at top - 2, second at top - 1; result go to top - 2 */
  luaO_arith(L, op, s2v(L->top - 2), s2v(L->top - 1), L->top - 2);
  L->top--;  /* remove second operand */
  lua_unlock(L);
}


LUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {
  const TValue *o1;
  const TValue *o2;
  int i = 0;
  lua_lock(L);  /* may call tag method */
  o1 = index2value(L, index1);
  o2 = index2value(L, index2);
  if (isvalid(L, o1) && isvalid(L, o2)) {
    switch (op) {
      case LUA_OPEQ: i = luaV_equalobj(L, o1, o2); break;
      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;
      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;
      default: api_check(L, 0, "invalid option");
    }
  }
  lua_unlock(L);
  return i;
}


LUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {
  size_t sz = luaO_str2num(s, s2v(L->top));
  if (sz != 0)
    api_incr_top(L);
  return sz;
}


LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {
  lua_Number n = 0;
  const TValue *o = index2value(L, idx);
  int isnum = tonumber(o, &n);
  if (pisnum)
    *pisnum = isnum;
  return n;
}


LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {
  lua_Integer res = 0;
  const TValue *o = index2value(L, idx);
  int isnum = tointeger(o, &res);
  if (pisnum)
    *pisnum = isnum;
  return res;
}


LUA_API int lua_toboolean (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return !l_isfalse(o);
}


LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
  TValue *o;
  lua_lock(L);
  o = index2value(L, idx);
  if (!ttisstring(o)) {
    if (!cvt2str(o)) {  /* not convertible? */
      if (len != NULL) *len = 0;
      lua_unlock(L);
      return NULL;
    }
    luaO_tostring(L, o);
    luaC_checkGC(L);
    o = index2value(L, idx);  /* previous call may reallocate the stack */
  }
  if (len != NULL)
    *len = vslen(o);
  lua_unlock(L);
  return svalue(o);
}


LUA_API lua_Unsigned lua_rawlen (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  switch (ttypetag(o)) {
    case LUA_VSHRSTR: return tsvalue(o)->shrlen;
    case LUA_VLNGSTR: return tsvalue(o)->u.lnglen;
    case LUA_VUSERDATA: return uvalue(o)->len;
    case LUA_VTABLE: return luaH_getn(hvalue(o));
    default: return 0;
  }
}


LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  if (ttislcf(o)) return fvalue(o);
  else if (ttisCclosure(o))
    return clCvalue(o)->f;
  else return NULL;  /* not a C function */
}


static void *touserdata (const TValue *o) {
  switch (ttype(o)) {
    case LUA_TUSERDATA: return getudatamem(uvalue(o));
    case LUA_TLIGHTUSERDATA: return pvalue(o);
    default: return NULL;
  }
}


LUA_API void *lua_touserdata (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return touserdata(o);
}


LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return (!ttisthread(o)) ? NULL : thvalue(o);
}


/*
** Returns a pointer to the internal representation of an object.
** Note that ANSI C does not allow the conversion of a pointer to
** function to a 'void*', so the conversion here goes through
** a 'size_t'. (As the returned pointer is only informative, this
** conversion should not be a problem.)
*/
LUA_API const void *lua_topointer (lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  switch (ttypetag(o)) {
    case LUA_VLCF: return cast_voidp(cast_sizet(fvalue(o)));
    case LUA_VUSERDATA: case LUA_VLIGHTUSERDATA:
      return touserdata(o);
    default: {
      if (iscollectable(o))
        return gcvalue(o);
      else
        return NULL;
    }
  }
}



/*
** push functions (C -> stack)
*/


LUA_API void lua_pushnil (lua_State *L) {
  lua_lock(L);
  setnilvalue(s2v(L->top));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
  lua_lock(L);
  setfltvalue(s2v(L->top), n);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
  lua_lock(L);
  setivalue(s2v(L->top), n);
  api_incr_top(L);
  lua_unlock(L);
}


/*
** Pushes on the stack a string with given length. Avoid using 's' when
** 'len' == 0 (as 's' can be NULL in that case), due to later use of
** 'memcmp' and 'memcpy'.
*/
LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
  TString *ts;
  lua_lock(L);
  ts = (len == 0) ? luaS_new(L, "") : luaS_newlstr(L, s, len);
  setsvalue2s(L, L->top, ts);
  api_incr_top(L);
  luaC_checkGC(L);
  lua_unlock(L);
  return getstr(ts);
}


LUA_API const char *lua_pushstring (lua_State *L, const char *s) {
  lua_lock(L);
  if (s == NULL)
    setnilvalue(s2v(L->top));
  else {
    TString *ts;
    ts = luaS_new(L, s);
    setsvalue2s(L, L->top, ts);
    s = getstr(ts);  /* internal copy's address */
  }
  api_incr_top(L);
  luaC_checkGC(L);
  lua_unlock(L);
  return s;
}


LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
                                      va_list argp) {
  const char *ret;
  lua_lock(L);
  ret = luaO_pushvfstring(L, fmt, argp);
  luaC_checkGC(L);
  lua_unlock(L);
  return ret;
}


LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
  const char *ret;
  va_list argp;
  lua_lock(L);
  va_start(argp, fmt);
  ret = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  luaC_checkGC(L);
  lua_unlock(L);
  return ret;
}


LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
  lua_lock(L);
  if (n == 0) {
    setfvalue(s2v(L->top), fn);
    api_incr_top(L);
  }
  else {
    CClosure *cl;
    api_checknelems(L, n);
    api_check(L, n <= MAXUPVAL, "upvalue index too large");
    cl = luaF_newCclosure(L, n);
    cl->f = fn;
    L->top -= n;
    while (n--) {
      setobj2n(L, &cl->upvalue[n], s2v(L->top + n));
      /* does not need barrier because closure is white */
      lua_assert(iswhite(cl));
    }
    setclCvalue(L, s2v(L->top), cl);
    api_incr_top(L);
    luaC_checkGC(L);
  }
  lua_unlock(L);
}


LUA_API void lua_pushboolean (lua_State *L, int b) {
  lua_lock(L);
  if (b)
    setbtvalue(s2v(L->top));
  else
    setbfvalue(s2v(L->top));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
  lua_lock(L);
  setpvalue(s2v(L->top), p);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API int lua_pushthread (lua_State *L) {
  lua_lock(L);
  setthvalue(L, s2v(L->top), L);
  api_incr_top(L);
  lua_unlock(L);
  return (G(L)->mainthread == L);
}



/*
** get functions (Lua -> stack)
*/


static int auxgetstr (lua_State *L, const TValue *t, const char *k) {
  const TValue *slot;
  TString *str = luaS_new(L, k);
  if (luaV_fastget(L, t, str, slot, luaH_getstr)) {
    setobj2s(L, L->top, slot);
    api_incr_top(L);
  }
  else {
    setsvalue2s(L, L->top, str);
    api_incr_top(L);
    luaV_finishget(L, t, s2v(L->top - 1), L->top - 1, slot);
  }
  lua_unlock(L);
  return ttype(s2v(L->top - 1));
}


/*
** Get the global table in the registry. Since all predefined
** indices in the registry were inserted right when the registry
** was created and never removed, they must always be in the array
** part of the registry.
*/
#define getGtable(L)  \
	(&hvalue(&G(L)->l_registry)->array[LUA_RIDX_GLOBALS - 1])


LUA_API int lua_getglobal (lua_State *L, const char *name) {
  const TValue *G;
  lua_lock(L);
  G = getGtable(L);
  return auxgetstr(L, G, name);
}


LUA_API int lua_gettable (lua_State *L, int idx) {
  const TValue *slot;
  TValue *t;
  lua_lock(L);
  t = index2value(L, idx);
  if (luaV_fastget(L, t, s2v(L->top - 1), slot, luaH_get)) {
    setobj2s(L, L->top - 1, slot);
  }
  else
    luaV_finishget(L, t, s2v(L->top - 1), L->top - 1, slot);
  lua_unlock(L);
  return ttype(s2v(L->top - 1));
}


LUA_API int lua_getfield (lua_State *L, int idx, const char *k) {
  lua_lock(L);
  return auxgetstr(L, index2value(L, idx), k);
}


LUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {
  TValue *t;
  const TValue *slot;
  lua_lock(L);
  t = index2value(L, idx);
  if (luaV_fastgeti(L, t, n, slot)) {
    setobj2s(L, L->top, slot);
  }
  else {
    TValue aux;
    setivalue(&aux, n);
    luaV_finishget(L, t, &aux, L->top, slot);
  }
  api_incr_top(L);
  lua_unlock(L);
  return ttype(s2v(L->top - 1));
}


static int finishrawget (lua_State *L, const TValue *val) {
  if (isempty(val))  /* avoid copying empty items to the stack */
    setnilvalue(s2v(L->top));
  else
    setobj2s(L, L->top, val);
  api_incr_top(L);
  lua_unlock(L);
  return ttype(s2v(L->top - 1));
}


static Table *gettable (lua_State *L, int idx) {
  TValue *t = index2value(L, idx);
  api_check(L, ttistable(t), "table expected");
  return hvalue(t);
}


LUA_API int lua_rawget (lua_State *L, int idx) {
  Table *t;
  const TValue *val;
  lua_lock(L);
  api_checknelems(L, 1);
  t = gettable(L, idx);
  val = luaH_get(t, s2v(L->top - 1));
  L->top--;  /* remove key */
  return finishrawget(L, val);
}


LUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {
  Table *t;
  lua_lock(L);
  t = gettable(L, idx);
  return finishrawget(L, luaH_getint(t, n));
}


LUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {
  Table *t;
  TValue k;
  lua_lock(L);
  t = gettable(L, idx);
  setpvalue(&k, cast_voidp(p));
  return finishrawget(L, luaH_get(t, &k));
}


LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
  Table *t;
  lua_lock(L);
  t = luaH_new(L);
  sethvalue2s(L, L->top, t);
  api_incr_top(L);
  if (narray > 0 || nrec > 0)
    luaH_resize(L, t, narray, nrec);
  luaC_checkGC(L);
  lua_unlock(L);
}


LUA_API int lua_getmetatable (lua_State *L, int objindex) {
  const TValue *obj;
  Table *mt;
  int res = 0;
  lua_lock(L);
  obj = index2value(L, objindex);
  switch (ttype(obj)) {
    case LUA_TTABLE:
      mt = hvalue(obj)->metatable;
      break;
    case LUA_TUSERDATA:
      mt = uvalue(obj)->metatable;
      break;
    default:
      mt = G(L)->mt[ttype(obj)];
      break;
  }
  if (mt != NULL) {
    sethvalue2s(L, L->top, mt);
    api_incr_top(L);
    res = 1;
  }
  lua_unlock(L);
  return res;
}


LUA_API int lua_getiuservalue (lua_State *L, int idx, int n) {
  TValue *o;
  int t;
  lua_lock(L);
  o = index2value(L, idx);
  api_check(L, ttisfulluserdata(o), "full userdata expected");
  if (n <= 0 || n > uvalue(o)->nuvalue) {
    setnilvalue(s2v(L->top));
    t = LUA_TNONE;
  }
  else {
    setobj2s(L, L->top, &uvalue(o)->uv[n - 1].uv);
    t = ttype(s2v(L->top));
  }
  api_incr_top(L);
  lua_unlock(L);
  return t;
}


/*
** set functions (stack -> Lua)
*/

/*
** t[k] = value at the top of the stack (where 'k' is a string)
*/
static void auxsetstr (lua_State *L, const TValue *t, const char *k) {
  const TValue *slot;
  TString *str = luaS_new(L, k);
  api_checknelems(L, 1);
  if (luaV_fastget(L, t, str, slot, luaH_getstr)) {
    luaV_finishfastset(L, t, slot, s2v(L->top - 1));
    L->top--;  /* pop value */
  }
  else {
    setsvalue2s(L, L->top, str);  /* push 'str' (to make it a TValue) */
    api_incr_top(L);
    luaV_finishset(L, t, s2v(L->top - 1), s2v(L->top - 2), slot);
    L->top -= 2;  /* pop value and key */
  }
  lua_unlock(L);  /* lock done by caller */
}


LUA_API void lua_setglobal (lua_State *L, const char *name) {
  const TValue *G;
  lua_lock(L);  /* unlock done in 'auxsetstr' */
  G = getGtable(L);
  auxsetstr(L, G, name);
}


LUA_API void lua_settable (lua_State *L, int idx) {
  TValue *t;
  const TValue *slot;
  lua_lock(L);
  api_checknelems(L, 2);
  t = index2value(L, idx);
  if (luaV_fastget(L, t, s2v(L->top - 2), slot, luaH_get)) {
    luaV_finishfastset(L, t, slot, s2v(L->top - 1));
  }
  else
    luaV_finishset(L, t, s2v(L->top - 2), s2v(L->top - 1), slot);
  L->top -= 2;  /* pop index and value */
  lua_unlock(L);
}


LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
  lua_lock(L);  /* unlock done in 'auxsetstr' */
  auxsetstr(L, index2value(L, idx), k);
}


LUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {
  TValue *t;
  const TValue *slot;
  lua_lock(L);
  api_checknelems(L, 1);
  t = index2value(L, idx);
  if (luaV_fastgeti(L, t, n, slot)) {
    luaV_finishfastset(L, t, slot, s2v(L->top - 1));
  }
  else {
    TValue aux;
    setivalue(&aux, n);
    luaV_finishset(L, t, &aux, s2v(L->top - 1), slot);
  }
  L->top--;  /* pop value */
  lua_unlock(L);
}


static void aux_rawset (lua_State *L, int idx, TValue *key, int n) {
  Table *t;
  lua_lock(L);
  api_checknelems(L, n);
  t = gettable(L, idx);
  luaH_set(L, t, key, s2v(L->top - 1));
  invalidateTMcache(t);
  luaC_barrierback(L, obj2gco(t), s2v(L->top - 1));
  L->top -= n;
  lua_unlock(L);
}


LUA_API void lua_rawset (lua_State *L, int idx) {
  aux_rawset(L, idx, s2v(L->top - 2), 2);
}


LUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {
  TValue k;
  setpvalue(&k, cast_voidp(p));
  aux_rawset(L, idx, &k, 1);
}


LUA_API void lua_rawseti (lua_State *L, int idx, lua_Integer n) {
  Table *t;
  lua_lock(L);
  api_checknelems(L, 1);
  t = gettable(L, idx);
  luaH_setint(L, t, n, s2v(L->top - 1));
  luaC_barrierback(L, obj2gco(t), s2v(L->top - 1));
  L->top--;
  lua_unlock(L);
}


LUA_API int lua_setmetatable (lua_State *L, int objindex) {
  TValue *obj;
  Table *mt;
  lua_lock(L);
  api_checknelems(L, 1);
  obj = index2value(L, objindex);
  if (ttisnil(s2v(L->top - 1)))
    mt = NULL;
  else {
    api_check(L, ttistable(s2v(L->top - 1)), "table expected");
    mt = hvalue(s2v(L->top - 1));
  }
  switch (ttype(obj)) {
    case LUA_TTABLE: {
      hvalue(obj)->metatable = mt;
      if (mt) {
        luaC_objbarrier(L, gcvalue(obj), mt);
        luaC_checkfinalizer(L, gcvalue(obj), mt);
      }
      break;
    }
    case LUA_TUSERDATA: {
      uvalue(obj)->metatable = mt;
      if (mt) {
        luaC_objbarrier(L, uvalue(obj), mt);
        luaC_checkfinalizer(L, gcvalue(obj), mt);
      }
      break;
    }
    default: {
      G(L)->mt[ttype(obj)] = mt;
      break;
    }
  }
  L->top--;
  lua_unlock(L);
  return 1;
}


LUA_API int lua_setiuservalue (lua_State *L, int idx, int n) {
  TValue *o;
  int res;
  lua_lock(L);
  api_checknelems(L, 1);
  o = index2value(L, idx);
  api_check(L, ttisfulluserdata(o), "full userdata expected");
  if (!(cast_uint(n) - 1u < cast_uint(uvalue(o)->nuvalue)))
    res = 0;  /* 'n' not in [1, uvalue(o)->nuvalue] */
  else {
    setobj(L, &uvalue(o)->uv[n - 1].uv, s2v(L->top - 1));
    luaC_barrierback(L, gcvalue(o), s2v(L->top - 1));
    res = 1;
  }
  L->top--;
  lua_unlock(L);
  return res;
}


/*
** 'load' and 'call' functions (run Lua code)
*/


#define checkresults(L,na,nr) \
     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \
	"results from function overflow current stack size")


LUA_API void lua_callk (lua_State *L, int nargs, int nresults,
                        lua_KContext ctx, lua_KFunction k) {
  StkId func;
  lua_lock(L);
  api_check(L, k == NULL || !isLua(L->ci),
    "cannot use continuations inside hooks");
  api_checknelems(L, nargs+1);
  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
  checkresults(L, nargs, nresults);
  func = L->top - (nargs+1);
  if (k != NULL && yieldable(L)) {  /* need to prepare continuation? */
    L->ci->u.c.k = k;  /* save continuation */
    L->ci->u.c.ctx = ctx;  /* save context */
    luaD_call(L, func, nresults);  /* do the call */
  }
  else  /* no continuation or no yieldable */
    luaD_callnoyield(L, func, nresults);  /* just do the call */
  adjustresults(L, nresults);
  lua_unlock(L);
}



/*
** Execute a protected call.
*/
struct CallS {  /* data to 'f_call' */
  StkId func;
  int nresults;
};


static void f_call (lua_State *L, void *ud) {
  struct CallS *c = cast(struct CallS *, ud);
  luaD_callnoyield(L, c->func, c->nresults);
}



LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
                        lua_KContext ctx, lua_KFunction k) {
  struct CallS c;
  int status;
  ptrdiff_t func;
  lua_lock(L);
  api_check(L, k == NULL || !isLua(L->ci),
    "cannot use continuations inside hooks");
  api_checknelems(L, nargs+1);
  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
  checkresults(L, nargs, nresults);
  if (errfunc == 0)
    func = 0;
  else {
    StkId o = index2stack(L, errfunc);
    api_check(L, ttisfunction(s2v(o)), "error handler must be a function");
    func = savestack(L, o);
  }
  c.func = L->top - (nargs+1);  /* function to be called */
  if (k == NULL || !yieldable(L)) {  /* no continuation or no yieldable? */
    c.nresults = nresults;  /* do a 'conventional' protected call */
    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
  }
  else {  /* prepare continuation (call is already protected by 'resume') */
    CallInfo *ci = L->ci;
    ci->u.c.k = k;  /* save continuation */
    ci->u.c.ctx = ctx;  /* save context */
    /* save information for error recovery */
    ci->u2.funcidx = cast_int(savestack(L, c.func));
    ci->u.c.old_errfunc = L->errfunc;
    L->errfunc = func;
    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */
    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */
    luaD_call(L, c.func, nresults);  /* do the call */
    ci->callstatus &= ~CIST_YPCALL;
    L->errfunc = ci->u.c.old_errfunc;
    status = LUA_OK;  /* if it is here, there were no errors */
  }
  adjustresults(L, nresults);
  lua_unlock(L);
  return status;
}


LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
                      const char *chunkname, const char *mode) {
  ZIO z;
  int status;
  lua_lock(L);
  if (!chunkname) chunkname = "?";
  luaZ_init(L, &z, reader, data);
  status = luaD_protectedparser(L, &z, chunkname, mode);
  if (status == LUA_OK) {  /* no errors? */
    LClosure *f = clLvalue(s2v(L->top - 1));  /* get newly created function */
    if (f->nupvalues >= 1) {  /* does it have an upvalue? */
      /* get global table from registry */
      const TValue *gt = getGtable(L);
      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
      setobj(L, f->upvals[0]->v, gt);
      luaC_barrier(L, f->upvals[0], gt);
    }
  }
  lua_unlock(L);
  return status;
}


LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {
  int status;
  TValue *o;
  lua_lock(L);
  api_checknelems(L, 1);
  o = s2v(L->top - 1);
  if (isLfunction(o))
    status = luaU_dump(L, getproto(o), writer, data, strip);
  else
    status = 1;
  lua_unlock(L);
  return status;
}


LUA_API int lua_status (lua_State *L) {
  return L->status;
}


/*
** Garbage-collection function
*/
LUA_API int lua_gc (lua_State *L, int what, ...) {
  va_list argp;
  int res = 0;
  global_State *g;
  lua_lock(L);
  g = G(L);
  va_start(argp, what);
  switch (what) {
    case LUA_GCSTOP: {
      g->gcrunning = 0;
      break;
    }
    case LUA_GCRESTART: {
      luaE_setdebt(g, 0);
      g->gcrunning = 1;
      break;
    }
    case LUA_GCCOLLECT: {
      luaC_fullgc(L, 0);
      break;
    }
    case LUA_GCCOUNT: {
      /* GC values are expressed in Kbytes: #bytes/2^10 */
      res = cast_int(gettotalbytes(g) >> 10);
      break;
    }
    case LUA_GCCOUNTB: {
      res = cast_int(gettotalbytes(g) & 0x3ff);
      break;
    }
    case LUA_GCSTEP: {
      int data = va_arg(argp, int);
      l_mem debt = 1;  /* =1 to signal that it did an actual step */
      lu_byte oldrunning = g->gcrunning;
      g->gcrunning = 1;  /* allow GC to run */
      if (data == 0) {
        luaE_setdebt(g, 0);  /* do a basic step */
        luaC_step(L);
      }
      else {  /* add 'data' to total debt */
        debt = cast(l_mem, data) * 1024 + g->GCdebt;
        luaE_setdebt(g, debt);
        luaC_checkGC(L);
      }
      g->gcrunning = oldrunning;  /* restore previous state */
      if (debt > 0 && g->gcstate == GCSpause)  /* end of cycle? */
        res = 1;  /* signal it */
      break;
    }
    case LUA_GCSETPAUSE: {
      int data = va_arg(argp, int);
      res = getgcparam(g->gcpause);
      setgcparam(g->gcpause, data);
      break;
    }
    case LUA_GCSETSTEPMUL: {
      int data = va_arg(argp, int);
      res = getgcparam(g->gcstepmul);
      setgcparam(g->gcstepmul, data);
      break;
    }
    case LUA_GCISRUNNING: {
      res = g->gcrunning;
      break;
    }
    case LUA_GCGEN: {
      int minormul = va_arg(argp, int);
      int majormul = va_arg(argp, int);
      res = isdecGCmodegen(g) ? LUA_GCGEN : LUA_GCINC;
      if (minormul != 0)
        g->genminormul = minormul;
      if (majormul != 0)
        setgcparam(g->genmajormul, majormul);
      luaC_changemode(L, KGC_GEN);
      break;
    }
    case LUA_GCINC: {
      int pause = va_arg(argp, int);
      int stepmul = va_arg(argp, int);
      int stepsize = va_arg(argp, int);
      res = isdecGCmodegen(g) ? LUA_GCGEN : LUA_GCINC;
      if (pause != 0)
        setgcparam(g->gcpause, pause);
      if (stepmul != 0)
        setgcparam(g->gcstepmul, stepmul);
      if (stepsize != 0)
        g->gcstepsize = stepsize;
      luaC_changemode(L, KGC_INC);
      break;
    }
    default: res = -1;  /* invalid option */
  }
  va_end(argp);
  lua_unlock(L);
  return res;
}



/*
** miscellaneous functions
*/


LUA_API int lua_error (lua_State *L) {
  TValue *errobj;
  lua_lock(L);
  errobj = s2v(L->top - 1);
  api_checknelems(L, 1);
  /* error object is the memory error message? */
  if (ttisshrstring(errobj) && eqshrstr(tsvalue(errobj), G(L)->memerrmsg))
    luaM_error(L);  /* raise a memory error */
  else
    luaG_errormsg(L);  /* raise a regular error */
  /* code unreachable; will unlock when control actually leaves the kernel */
  return 0;  /* to avoid warnings */
}


LUA_API int lua_next (lua_State *L, int idx) {
  Table *t;
  int more;
  lua_lock(L);
  api_checknelems(L, 1);
  t = gettable(L, idx);
  more = luaH_next(L, t, L->top - 1);
  if (more) {
    api_incr_top(L);
  }
  else  /* no more elements */
    L->top -= 1;  /* remove key */
  lua_unlock(L);
  return more;
}


LUA_API void lua_toclose (lua_State *L, int idx) {
  int nresults;
  StkId o;
  lua_lock(L);
  o = index2stack(L, idx);
  nresults = L->ci->nresults;
  api_check(L, L->tbclist < o, "given index below or equal a marked one");
  luaF_newtbcupval(L, o);  /* create new to-be-closed upvalue */
  if (!hastocloseCfunc(nresults))  /* function not marked yet? */
    L->ci->nresults = codeNresults(nresults);  /* mark it */
  lua_assert(hastocloseCfunc(L->ci->nresults));
  lua_unlock(L);
}


LUA_API void lua_concat (lua_State *L, int n) {
  lua_lock(L);
  api_checknelems(L, n);
  if (n > 0)
    luaV_concat(L, n);
  else {  /* nothing to concatenate */
    setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));  /* push empty string */
    api_incr_top(L);
  }
  luaC_checkGC(L);
  lua_unlock(L);
}


LUA_API void lua_len (lua_State *L, int idx) {
  TValue *t;
  lua_lock(L);
  t = index2value(L, idx);
  luaV_objlen(L, L->top, t);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
  lua_Alloc f;
  lua_lock(L);
  if (ud) *ud = G(L)->ud;
  f = G(L)->frealloc;
  lua_unlock(L);
  return f;
}


LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
  lua_lock(L);
  G(L)->ud = ud;
  G(L)->frealloc = f;
  lua_unlock(L);
}


void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud) {
  lua_lock(L);
  G(L)->ud_warn = ud;
  G(L)->warnf = f;
  lua_unlock(L);
}


void lua_warning (lua_State *L, const char *msg, int tocont) {
  lua_lock(L);
  luaE_warning(L, msg, tocont);
  lua_unlock(L);
}



LUA_API void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue) {
  Udata *u;
  lua_lock(L);
  api_check(L, 0 <= nuvalue && nuvalue < USHRT_MAX, "invalid value");
  u = luaS_newudata(L, size, nuvalue);
  setuvalue(L, s2v(L->top), u);
  api_incr_top(L);
  luaC_checkGC(L);
  lua_unlock(L);
  return getudatamem(u);
}



static const char *aux_upvalue (TValue *fi, int n, TValue **val,
                                GCObject **owner) {
  switch (ttypetag(fi)) {
    case LUA_VCCL: {  /* C closure */
      CClosure *f = clCvalue(fi);
      if (!(cast_uint(n) - 1u < cast_uint(f->nupvalues)))
        return NULL;  /* 'n' not in [1, f->nupvalues] */
      *val = &f->upvalue[n-1];
      if (owner) *owner = obj2gco(f);
      return "";
    }
    case LUA_VLCL: {  /* Lua closure */
      LClosure *f = clLvalue(fi);
      TString *name;
      Proto *p = f->p;
      if (!(cast_uint(n) - 1u  < cast_uint(p->sizeupvalues)))
        return NULL;  /* 'n' not in [1, p->sizeupvalues] */
      *val = f->upvals[n-1]->v;
      if (owner) *owner = obj2gco(f->upvals[n - 1]);
      name = p->upvalues[n-1].name;
      return (name == NULL) ? "(no name)" : getstr(name);
    }
    default: return NULL;  /* not a closure */
  }
}


LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val = NULL;  /* to avoid warnings */
  lua_lock(L);
  name = aux_upvalue(index2value(L, funcindex), n, &val, NULL);
  if (name) {
    setobj2s(L, L->top, val);
    api_incr_top(L);
  }
  lua_unlock(L);
  return name;
}


LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val = NULL;  /* to avoid warnings */
  GCObject *owner = NULL;  /* to avoid warnings */
  TValue *fi;
  lua_lock(L);
  fi = index2value(L, funcindex);
  api_checknelems(L, 1);
  name = aux_upvalue(fi, n, &val, &owner);
  if (name) {
    L->top--;
    setobj(L, val, s2v(L->top));
    luaC_barrier(L, owner, val);
  }
  lua_unlock(L);
  return name;
}


static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
  static const UpVal *const nullup = NULL;
  LClosure *f;
  TValue *fi = index2value(L, fidx);
  api_check(L, ttisLclosure(fi), "Lua function expected");
  f = clLvalue(fi);
  if (pf) *pf = f;
  if (1 <= n && n <= f->p->sizeupvalues)
    return &f->upvals[n - 1];  /* get its upvalue pointer */
  else
    return (UpVal**)&nullup;
}


LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
  TValue *fi = index2value(L, fidx);
  switch (ttypetag(fi)) {
    case LUA_VLCL: {  /* lua closure */
      return *getupvalref(L, fidx, n, NULL);
    }
    case LUA_VCCL: {  /* C closure */
      CClosure *f = clCvalue(fi);
      if (1 <= n && n <= f->nupvalues)
        return &f->upvalue[n - 1];
      /* else */
    }  /* FALLTHROUGH */
    case LUA_VLCF:
      return NULL;  /* light C functions have no upvalues */
    default: {
      api_check(L, 0, "function expected");
      return NULL;
    }
  }
}


LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
                                            int fidx2, int n2) {
  LClosure *f1;
  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
  api_check(L, *up1 != NULL && *up2 != NULL, "invalid upvalue index");
  *up1 = *up2;
  luaC_objbarrier(L, f1, *up1);
}


#include <stdio.h>
/*
** $Id: lauxlib.c $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/

#define lauxlib_c
#define LUA_LIB

#include "lprefix.h"


#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


/*
** This file uses only the official API of Lua.
** Any function declared here could be written as an application function.
*/

#include "lua.h"

#include "lauxlib.h"


#if !defined(MAX_SIZET)
/* maximum value for size_t */
#define MAX_SIZET	((size_t)(~(size_t)0))
#endif


/*
** {======================================================
** Traceback
** =======================================================
*/


#define LEVELS1	10	/* size of the first part of the stack */
#define LEVELS2	11	/* size of the second part of the stack */



/*
** Search for 'objidx' in table at index -1. ('objidx' must be an
** absolute index.) Return 1 + string at top if it found a good name.
*/
static int findfield (lua_State *L, int objidx, int level) {
  if (level == 0 || !lua_istable(L, -1))
    return 0;  /* not found */
  lua_pushnil(L);  /* start 'next' loop */
  while (lua_next(L, -2)) {  /* for each pair in table */
    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */
      if (lua_rawequal(L, objidx, -1)) {  /* found object? */
        lua_pop(L, 1);  /* remove value (but keep name) */
        return 1;
      }
      else if (findfield(L, objidx, level - 1)) {  /* try recursively */
        /* stack: lib_name, lib_table, field_name (top) */
        lua_pushliteral(L, ".");  /* place '.' between the two names */
        lua_replace(L, -3);  /* (in the slot occupied by table) */
        lua_concat(L, 3);  /* lib_name.field_name */
        return 1;
      }
    }
    lua_pop(L, 1);  /* remove value */
  }
  return 0;  /* not found */
}


/*
** Search for a name for a function in all loaded modules
*/
static int pushglobalfuncname (lua_State *L, lua_Debug *ar) {
  int top = lua_gettop(L);
  lua_getinfo(L, "f", ar);  /* push function */
  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  if (findfield(L, top + 1, 2)) {
    const char *name = lua_tostring(L, -1);
    if (strncmp(name, LUA_GNAME ".", 3) == 0) {  /* name start with '_G.'? */
      lua_pushstring(L, name + 3);  /* push name without prefix */
      lua_remove(L, -2);  /* remove original name */
    }
    lua_copy(L, -1, top + 1);  /* copy name to proper place */
    lua_settop(L, top + 1);  /* remove table "loaded" and name copy */
    return 1;
  }
  else {
    lua_settop(L, top);  /* remove function and global table */
    return 0;
  }
}


static void pushfuncname (lua_State *L, lua_Debug *ar) {
  if (pushglobalfuncname(L, ar)) {  /* try first a global name */
    lua_pushfstring(L, "function '%s'", lua_tostring(L, -1));
    lua_remove(L, -2);  /* remove name */
  }
  else if (*ar->namewhat != '\0')  /* is there a name from code? */
    lua_pushfstring(L, "%s '%s'", ar->namewhat, ar->name);  /* use it */
  else if (*ar->what == 'm')  /* main? */
      lua_pushliteral(L, "main chunk");
  else if (*ar->what != 'C')  /* for Lua functions, use <file:line> */
    lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
  else  /* nothing left... */
    lua_pushliteral(L, "?");
}


static int lastlevel (lua_State *L) {
  lua_Debug ar;
  int li = 1, le = 1;
  /* find an upper bound */
  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }
  /* do a binary search */
  while (li < le) {
    int m = (li + le)/2;
    if (lua_getstack(L, m, &ar)) li = m + 1;
    else le = m;
  }
  return le - 1;
}


LUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,
                                const char *msg, int level) {
  luaL_Buffer b;
  lua_Debug ar;
  int last = lastlevel(L1);
  int limit2show = (last - level > LEVELS1 + LEVELS2) ? LEVELS1 : -1;
  luaL_buffinit(L, &b);
  if (msg) {
    luaL_addstring(&b, msg);
    luaL_addchar(&b, '\n');
  }
  luaL_addstring(&b, "stack traceback:");
  while (lua_getstack(L1, level++, &ar)) {
    if (limit2show-- == 0) {  /* too many levels? */
      int n = last - level - LEVELS2 + 1;  /* number of levels to skip */
      lua_pushfstring(L, "\n\t...\t(skipping %d levels)", n);
      luaL_addvalue(&b);  /* add warning about skip */
      level += n;  /* and skip to last levels */
    }
    else {
      lua_getinfo(L1, "Slnt", &ar);
      if (ar.currentline <= 0)
        lua_pushfstring(L, "\n\t%s: in ", ar.short_src);
      else
        lua_pushfstring(L, "\n\t%s:%d: in ", ar.short_src, ar.currentline);
      luaL_addvalue(&b);
      pushfuncname(L, &ar);
      luaL_addvalue(&b);
      if (ar.istailcall)
        luaL_addstring(&b, "\n\t(...tail calls...)");
    }
  }
  luaL_pushresult(&b);
}

/* }====================================================== */


/*
** {======================================================
** Error-report functions
** =======================================================
*/

LUALIB_API int luaL_argerror (lua_State *L, int arg, const char *extramsg) {
  lua_Debug ar;
  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
    return luaL_error(L, "bad argument #%d (%s)", arg, extramsg);
  lua_getinfo(L, "n", &ar);
  if (strcmp(ar.namewhat, "method") == 0) {
    arg--;  /* do not count 'self' */
    if (arg == 0)  /* error is in the self argument itself? */
      return luaL_error(L, "calling '%s' on bad self (%s)",
                           ar.name, extramsg);
  }
  if (ar.name == NULL)
    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : "?";
  return luaL_error(L, "bad argument #%d to '%s' (%s)",
                        arg, ar.name, extramsg);
}


LUALIB_API int luaL_typeerror (lua_State *L, int arg, const char *tname) {
  const char *msg;
  const char *typearg;  /* name for the type of the actual argument */
  if (luaL_getmetafield(L, arg, "__name") == LUA_TSTRING)
    typearg = lua_tostring(L, -1);  /* use the given type name */
  else if (lua_type(L, arg) == LUA_TLIGHTUSERDATA)
    typearg = "light userdata";  /* special name for messages */
  else
    typearg = luaL_typename(L, arg);  /* standard name */
  msg = lua_pushfstring(L, "%s expected, got %s", tname, typearg);
  return luaL_argerror(L, arg, msg);
}


static void tag_error (lua_State *L, int arg, int tag) {
  luaL_typeerror(L, arg, lua_typename(L, tag));
}


/*
** The use of 'lua_pushfstring' ensures this function does not
** need reserved stack space when called.
*/
LUALIB_API void luaL_where (lua_State *L, int level) {
  lua_Debug ar;
  if (lua_getstack(L, level, &ar)) {  /* check function at level */
    lua_getinfo(L, "Sl", &ar);  /* get info about it */
    if (ar.currentline > 0) {  /* is there info? */
      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
      return;
    }
  }
  lua_pushfstring(L, "");  /* else, no information available... */
}


/*
** Again, the use of 'lua_pushvfstring' ensures this function does
** not need reserved stack space when called. (At worst, it generates
** an error with "stack overflow" instead of the given message.)
*/
LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_concat(L, 2);
  return lua_error(L);
}


LUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {
  int en = errno;  /* calls to Lua API may change this value */
  if (stat) {
    lua_pushboolean(L, 1);
    return 1;
  }
  else {
    luaL_pushfail(L);
    if (fname)
      lua_pushfstring(L, "%s: %s", fname, strerror(en));
    else
      lua_pushstring(L, strerror(en));
    lua_pushinteger(L, en);
    return 3;
  }
}


#if !defined(l_inspectstat)	/* { */

#if defined(LUA_USE_POSIX)

#include <sys/wait.h>

/*
** use appropriate macros to interpret 'pclose' return status
*/
#define l_inspectstat(stat,what)  \
   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \
   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = "signal"; }

#else

#define l_inspectstat(stat,what)  /* no op */

#endif

#endif				/* } */


LUALIB_API int luaL_execresult (lua_State *L, int stat) {
  if (stat != 0 && errno != 0)  /* error with an 'errno'? */
    return luaL_fileresult(L, 0, NULL);
  else {
    const char *what = "exit";  /* type of termination */
    l_inspectstat(stat, what);  /* interpret result */
    if (*what == 'e' && stat == 0)  /* successful termination? */
      lua_pushboolean(L, 1);
    else
      luaL_pushfail(L);
    lua_pushstring(L, what);
    lua_pushinteger(L, stat);
    return 3;  /* return true/fail,what,code */
  }
}

/* }====================================================== */



/*
** {======================================================
** Userdata's metatable manipulation
** =======================================================
*/

LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
  if (luaL_getmetatable(L, tname) != LUA_TNIL)  /* name already in use? */
    return 0;  /* leave previous value on top, but return 0 */
  lua_pop(L, 1);
  lua_createtable(L, 0, 2);  /* create metatable */
  lua_pushstring(L, tname);
  lua_setfield(L, -2, "__name");  /* metatable.__name = tname */
  lua_pushvalue(L, -1);
  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
  return 1;
}


LUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {
  luaL_getmetatable(L, tname);
  lua_setmetatable(L, -2);
}


LUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {
  void *p = lua_touserdata(L, ud);
  if (p != NULL) {  /* value is a userdata? */
    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
      luaL_getmetatable(L, tname);  /* get correct metatable */
      if (!lua_rawequal(L, -1, -2))  /* not the same? */
        p = NULL;  /* value is a userdata with wrong metatable */
      lua_pop(L, 2);  /* remove both metatables */
      return p;
    }
  }
  return NULL;  /* value is not a userdata with a metatable */
}


LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
  void *p = luaL_testudata(L, ud, tname);
  luaL_argexpected(L, p != NULL, ud, tname);
  return p;
}

/* }====================================================== */


/*
** {======================================================
** Argument check functions
** =======================================================
*/

LUALIB_API int luaL_checkoption (lua_State *L, int arg, const char *def,
                                 const char *const lst[]) {
  const char *name = (def) ? luaL_optstring(L, arg, def) :
                             luaL_checkstring(L, arg);
  int i;
  for (i=0; lst[i]; i++)
    if (strcmp(lst[i], name) == 0)
      return i;
  return luaL_argerror(L, arg,
                       lua_pushfstring(L, "invalid option '%s'", name));
}


/*
** Ensures the stack has at least 'space' extra slots, raising an error
** if it cannot fulfill the request. (The error handling needs a few
** extra slots to format the error message. In case of an error without
** this extra space, Lua will generate the same 'stack overflow' error,
** but without 'msg'.)
*/
LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {
  if (l_unlikely(!lua_checkstack(L, space))) {
    if (msg)
      luaL_error(L, "stack overflow (%s)", msg);
    else
      luaL_error(L, "stack overflow");
  }
}


LUALIB_API void luaL_checktype (lua_State *L, int arg, int t) {
  if (l_unlikely(lua_type(L, arg) != t))
    tag_error(L, arg, t);
}


LUALIB_API void luaL_checkany (lua_State *L, int arg) {
  if (l_unlikely(lua_type(L, arg) == LUA_TNONE))
    luaL_argerror(L, arg, "value expected");
}


LUALIB_API const char *luaL_checklstring (lua_State *L, int arg, size_t *len) {
  const char *s = lua_tolstring(L, arg, len);
  if (l_unlikely(!s)) tag_error(L, arg, LUA_TSTRING);
  return s;
}


LUALIB_API const char *luaL_optlstring (lua_State *L, int arg,
                                        const char *def, size_t *len) {
  if (lua_isnoneornil(L, arg)) {
    if (len)
      *len = (def ? strlen(def) : 0);
    return def;
  }
  else return luaL_checklstring(L, arg, len);
}


LUALIB_API lua_Number luaL_checknumber (lua_State *L, int arg) {
  int isnum;
  lua_Number d = lua_tonumberx(L, arg, &isnum);
  if (l_unlikely(!isnum))
    tag_error(L, arg, LUA_TNUMBER);
  return d;
}


LUALIB_API lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number def) {
  return luaL_opt(L, luaL_checknumber, arg, def);
}


static void interror (lua_State *L, int arg) {
  if (lua_isnumber(L, arg))
    luaL_argerror(L, arg, "number has no integer representation");
  else
    tag_error(L, arg, LUA_TNUMBER);
}


LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int arg) {
  int isnum;
  lua_Integer d = lua_tointegerx(L, arg, &isnum);
  if (l_unlikely(!isnum)) {
    interror(L, arg);
  }
  return d;
}


LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int arg,
                                                      lua_Integer def) {
  return luaL_opt(L, luaL_checkinteger, arg, def);
}

/* }====================================================== */


/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/

/* userdata to box arbitrary data */
typedef struct UBox {
  void *box;
  size_t bsize;
} UBox;


static void *resizebox (lua_State *L, int idx, size_t newsize) {
  void *ud;
  lua_Alloc allocf = lua_getallocf(L, &ud);
  UBox *box = (UBox *)lua_touserdata(L, idx);
  void *temp = allocf(ud, box->box, box->bsize, newsize);
  if (l_unlikely(temp == NULL && newsize > 0)) {  /* allocation error? */
    lua_pushliteral(L, "not enough memory");
    lua_error(L);  /* raise a memory error */
  }
  box->box = temp;
  box->bsize = newsize;
  return temp;
}


static int boxgc (lua_State *L) {
  resizebox(L, 1, 0);
  return 0;
}


static const luaL_Reg boxmt[] = {  /* box metamethods */
  {"__gc", boxgc},
  {"__close", boxgc},
  {NULL, NULL}
};


static void newbox (lua_State *L) {
  UBox *box = (UBox *)lua_newuserdatauv(L, sizeof(UBox), 0);
  box->box = NULL;
  box->bsize = 0;
  if (luaL_newmetatable(L, "_UBOX*"))  /* creating metatable? */
    luaL_setfuncs(L, boxmt, 0);  /* set its metamethods */
  lua_setmetatable(L, -2);
}


/*
** check whether buffer is using a userdata on the stack as a temporary
** buffer
*/
#define buffonstack(B)	((B)->b != (B)->init.b)


/*
** Whenever buffer is accessed, slot 'idx' must either be a box (which
** cannot be NULL) or it is a placeholder for the buffer.
*/
#define checkbufferlevel(B,idx)  \
  lua_assert(buffonstack(B) ? lua_touserdata(B->L, idx) != NULL  \
                            : lua_touserdata(B->L, idx) == (void*)B)


/*
** Compute new size for buffer 'B', enough to accommodate extra 'sz'
** bytes.
*/
static size_t newbuffsize (luaL_Buffer *B, size_t sz) {
  size_t newsize = B->size * 2;  /* double buffer size */
  if (l_unlikely(MAX_SIZET - sz < B->n))  /* overflow in (B->n + sz)? */
    return luaL_error(B->L, "buffer too large");
  if (newsize < B->n + sz)  /* double is not big enough? */
    newsize = B->n + sz;
  return newsize;
}


/*
** Returns a pointer to a free area with at least 'sz' bytes in buffer
** 'B'. 'boxidx' is the relative position in the stack where is the
** buffer's box or its placeholder.
*/
static char *prepbuffsize (luaL_Buffer *B, size_t sz, int boxidx) {
  checkbufferlevel(B, boxidx);
  if (B->size - B->n >= sz)  /* enough space? */
    return B->b + B->n;
  else {
    lua_State *L = B->L;
    char *newbuff;
    size_t newsize = newbuffsize(B, sz);
    /* create larger buffer */
    if (buffonstack(B))  /* buffer already has a box? */
      newbuff = (char *)resizebox(L, boxidx, newsize);  /* resize it */
    else {  /* no box yet */
      lua_remove(L, boxidx);  /* remove placeholder */
      newbox(L);  /* create a new box */
      lua_insert(L, boxidx);  /* move box to its intended position */
      lua_toclose(L, boxidx);
      newbuff = (char *)resizebox(L, boxidx, newsize);
      memcpy(newbuff, B->b, B->n * sizeof(char));  /* copy original content */
    }
    B->b = newbuff;
    B->size = newsize;
    return newbuff + B->n;
  }
}

/*
** returns a pointer to a free area with at least 'sz' bytes
*/
LUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {
  return prepbuffsize(B, sz, -1);
}


LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
  if (l > 0) {  /* avoid 'memcpy' when 's' can be NULL */
    char *b = prepbuffsize(B, l, -1);
    memcpy(b, s, l * sizeof(char));
    luaL_addsize(B, l);
  }
}


LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
  luaL_addlstring(B, s, strlen(s));
}


LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
  lua_State *L = B->L;
  checkbufferlevel(B, -1);
  lua_pushlstring(L, B->b, B->n);
  if (buffonstack(B))
    lua_closeslot(L, -2);  /* close the box */
  lua_remove(L, -2);  /* remove box or placeholder from the stack */
}


LUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {
  luaL_addsize(B, sz);
  luaL_pushresult(B);
}


/*
** 'luaL_addvalue' is the only function in the Buffer system where the
** box (if existent) is not on the top of the stack. So, instead of
** calling 'luaL_addlstring', it replicates the code using -2 as the
** last argument to 'prepbuffsize', signaling that the box is (or will
** be) bellow the string being added to the buffer. (Box creation can
** trigger an emergency GC, so we should not remove the string from the
** stack before we have the space guaranteed.)
*/
LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
  lua_State *L = B->L;
  size_t len;
  const char *s = lua_tolstring(L, -1, &len);
  char *b = prepbuffsize(B, len, -2);
  memcpy(b, s, len * sizeof(char));
  luaL_addsize(B, len);
  lua_pop(L, 1);  /* pop string */
}


LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
  B->L = L;
  B->b = B->init.b;
  B->n = 0;
  B->size = LUAL_BUFFERSIZE;
  lua_pushlightuserdata(L, (void*)B);  /* push placeholder */
}


LUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {
  luaL_buffinit(L, B);
  return prepbuffsize(B, sz, -1);
}

/* }====================================================== */


/*
** {======================================================
** Reference system
** =======================================================
*/

/* index of free-list header (after the predefined values) */
#define freelist	(LUA_RIDX_LAST + 1)

/*
** The previously freed references form a linked list:
** t[freelist] is the index of a first free index, or zero if list is
** empty; t[t[freelist]] is the index of the second element; etc.
*/
LUALIB_API int luaL_ref (lua_State *L, int t) {
  int ref;
  if (lua_isnil(L, -1)) {
    lua_pop(L, 1);  /* remove from stack */
    return LUA_REFNIL;  /* 'nil' has a unique fixed reference */
  }
  t = lua_absindex(L, t);
  if (lua_rawgeti(L, t, freelist) == LUA_TNIL) {  /* first access? */
    ref = 0;  /* list is empty */
    lua_pushinteger(L, 0);  /* initialize as an empty list */
    lua_rawseti(L, t, freelist);  /* ref = t[freelist] = 0 */
  }
  else {  /* already initialized */
    lua_assert(lua_isinteger(L, -1));
    ref = (int)lua_tointeger(L, -1);  /* ref = t[freelist] */
  }
  lua_pop(L, 1);  /* remove element from stack */
  if (ref != 0) {  /* any free element? */
    lua_rawgeti(L, t, ref);  /* remove it from list */
    lua_rawseti(L, t, freelist);  /* (t[freelist] = t[ref]) */
  }
  else  /* no free elements */
    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */
  lua_rawseti(L, t, ref);
  return ref;
}


LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
  if (ref >= 0) {
    t = lua_absindex(L, t);
    lua_rawgeti(L, t, freelist);
    lua_assert(lua_isinteger(L, -1));
    lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */
    lua_pushinteger(L, ref);
    lua_rawseti(L, t, freelist);  /* t[freelist] = ref */
  }
}

/* }====================================================== */


/*
** {======================================================
** Load functions
** =======================================================
*/

typedef struct LoadF {
  int n;  /* number of pre-read characters */
  FILE *f;  /* file being read */
  char buff[BUFSIZ];  /* area for reading file */
} LoadF;


static const char *getF (lua_State *L, void *ud, size_t *size) {
  LoadF *lf = (LoadF *)ud;
  (void)L;  /* not used */
  if (lf->n > 0) {  /* are there pre-read characters to be read? */
    *size = lf->n;  /* return them (chars already in buffer) */
    lf->n = 0;  /* no more pre-read characters */
  }
  else {  /* read a block from file */
    /* 'fread' can return > 0 *and* set the EOF flag. If next call to
       'getF' called 'fread', it might still wait for user input.
       The next check avoids this problem. */
    if (feof(lf->f)) return NULL;
    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
  }
  return lf->buff;
}


static int errfile (lua_State *L, const char *what, int fnameindex) {
  const char *serr = strerror(errno);
  const char *filename = lua_tostring(L, fnameindex) + 1;
  lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
  lua_remove(L, fnameindex);
  return LUA_ERRFILE;
}


static int skipBOM (LoadF *lf) {
  const char *p = "\xEF\xBB\xBF";  /* UTF-8 BOM mark */
  int c;
  lf->n = 0;
  do {
    c = getc(lf->f);
    if (c == EOF || c != *(const unsigned char *)p++) return c;
    lf->buff[lf->n++] = c;  /* to be read by the parser */
  } while (*p != '\0');
  lf->n = 0;  /* prefix matched; discard it */
  return getc(lf->f);  /* return next character */
}


/*
** reads the first character of file 'f' and skips an optional BOM mark
** in its beginning plus its first line if it starts with '#'. Returns
** true if it skipped the first line.  In any case, '*cp' has the
** first "valid" character of the file (after the optional BOM and
** a first-line comment).
*/
static int skipcomment (LoadF *lf, int *cp) {
  int c = *cp = skipBOM(lf);
  if (c == '#') {  /* first line is a comment (Unix exec. file)? */
    do {  /* skip first line */
      c = getc(lf->f);
    } while (c != EOF && c != '\n');
    *cp = getc(lf->f);  /* skip end-of-line, if present */
    return 1;  /* there was a comment */
  }
  else return 0;  /* no comment */
}


LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
                                             const char *mode) {
  LoadF lf;
  int status, readstatus;
  int c;
  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
  if (filename == NULL) {
    lua_pushliteral(L, "=stdin");
    lf.f = stdin;
  }
  else {
    lua_pushfstring(L, "@%s", filename);
    lf.f = fopen(filename, "r");
    if (lf.f == NULL) return errfile(L, "open", fnameindex);
  }
  if (skipcomment(&lf, &c))  /* read initial portion */
    lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
  if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
    lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
    if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
    skipcomment(&lf, &c);  /* re-read initial portion */
  }
  if (c != EOF)
    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
  readstatus = ferror(lf.f);
  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
  if (readstatus) {
    lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */
    return errfile(L, "read", fnameindex);
  }
  lua_remove(L, fnameindex);
  return status;
}


typedef struct LoadS {
  const char *s;
  size_t size;
} LoadS;


static const char *getS (lua_State *L, void *ud, size_t *size) {
  LoadS *ls = (LoadS *)ud;
  (void)L;  /* not used */
  if (ls->size == 0) return NULL;
  *size = ls->size;
  ls->size = 0;
  return ls->s;
}


LUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,
                                 const char *name, const char *mode) {
  LoadS ls;
  ls.s = buff;
  ls.size = size;
  return lua_load(L, getS, &ls, name, mode);
}


LUALIB_API int luaL_loadstring (lua_State *L, const char *s) {
  return luaL_loadbuffer(L, s, strlen(s), s);
}

/* }====================================================== */



LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
  if (!lua_getmetatable(L, obj))  /* no metatable? */
    return LUA_TNIL;
  else {
    int tt;
    lua_pushstring(L, event);
    tt = lua_rawget(L, -2);
    if (tt == LUA_TNIL)  /* is metafield nil? */
      lua_pop(L, 2);  /* remove metatable and metafield */
    else
      lua_remove(L, -2);  /* remove only metatable */
    return tt;  /* return metafield type */
  }
}


LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
  obj = lua_absindex(L, obj);
  if (luaL_getmetafield(L, obj, event) == LUA_TNIL)  /* no metafield? */
    return 0;
  lua_pushvalue(L, obj);
  lua_call(L, 1, 1);
  return 1;
}


LUALIB_API lua_Integer luaL_len (lua_State *L, int idx) {
  lua_Integer l;
  int isnum;
  lua_len(L, idx);
  l = lua_tointegerx(L, -1, &isnum);
  if (l_unlikely(!isnum))
    luaL_error(L, "object length is not an integer");
  lua_pop(L, 1);  /* remove object */
  return l;
}


LUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {
  if (luaL_callmeta(L, idx, "__tostring")) {  /* metafield? */
    if (!lua_isstring(L, -1))
      luaL_error(L, "'__tostring' must return a string");
  }
  else {
    switch (lua_type(L, idx)) {
      case LUA_TNUMBER: {
        if (lua_isinteger(L, idx))
          lua_pushfstring(L, "%I", (LUAI_UACINT)lua_tointeger(L, idx));
        else
          lua_pushfstring(L, "%f", (LUAI_UACNUMBER)lua_tonumber(L, idx));
        break;
      }
      case LUA_TSTRING:
        lua_pushvalue(L, idx);
        break;
      case LUA_TBOOLEAN:
        lua_pushstring(L, (lua_toboolean(L, idx) ? "true" : "false"));
        break;
      case LUA_TNIL:
        lua_pushliteral(L, "nil");
        break;
      default: {
        int tt = luaL_getmetafield(L, idx, "__name");  /* try name */
        const char *kind = (tt == LUA_TSTRING) ? lua_tostring(L, -1) :
                                                 luaL_typename(L, idx);
        lua_pushfstring(L, "%s: %p", kind, lua_topointer(L, idx));
        if (tt != LUA_TNIL)
          lua_remove(L, -2);  /* remove '__name' */
        break;
      }
    }
  }
  return lua_tolstring(L, -1, len);
}


/*
** set functions from list 'l' into table at top - 'nup'; each
** function gets the 'nup' elements at the top as upvalues.
** Returns with only the table at the stack.
*/
LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
  luaL_checkstack(L, nup, "too many upvalues");
  for (; l->name != NULL; l++) {  /* fill the table with given functions */
    if (l->func == NULL)  /* place holder? */
      lua_pushboolean(L, 0);
    else {
      int i;
      for (i = 0; i < nup; i++)  /* copy upvalues to the top */
        lua_pushvalue(L, -nup);
      lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */
    }
    lua_setfield(L, -(nup + 2), l->name);
  }
  lua_pop(L, nup);  /* remove upvalues */
}


/*
** ensure that stack[idx][fname] has a table and push that table
** into the stack
*/
LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {
  if (lua_getfield(L, idx, fname) == LUA_TTABLE)
    return 1;  /* table already there */
  else {
    lua_pop(L, 1);  /* remove previous result */
    idx = lua_absindex(L, idx);
    lua_newtable(L);
    lua_pushvalue(L, -1);  /* copy to be left at top */
    lua_setfield(L, idx, fname);  /* assign new table to field */
    return 0;  /* false, because did not find table there */
  }
}


/*
** Stripped-down 'require': After checking "loaded" table, calls 'openf'
** to open a module, registers the result in 'package.loaded' table and,
** if 'glb' is true, also registers the result in the global table.
** Leaves resulting module on the top.
*/
LUALIB_API void luaL_requiref (lua_State *L, const char *modname,
                               lua_CFunction openf, int glb) {
  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  lua_getfield(L, -1, modname);  /* LOADED[modname] */
  if (!lua_toboolean(L, -1)) {  /* package not already loaded? */
    lua_pop(L, 1);  /* remove field */
    lua_pushcfunction(L, openf);
    lua_pushstring(L, modname);  /* argument to open function */
    lua_call(L, 1, 1);  /* call 'openf' to open module */
    lua_pushvalue(L, -1);  /* make copy of module (call result) */
    lua_setfield(L, -3, modname);  /* LOADED[modname] = module */
  }
  lua_remove(L, -2);  /* remove LOADED table */
  if (glb) {
    lua_pushvalue(L, -1);  /* copy of module */
    lua_setglobal(L, modname);  /* _G[modname] = module */
  }
}


LUALIB_API void luaL_addgsub (luaL_Buffer *b, const char *s,
                                     const char *p, const char *r) {
  const char *wild;
  size_t l = strlen(p);
  while ((wild = strstr(s, p)) != NULL) {
    luaL_addlstring(b, s, wild - s);  /* push prefix */
    luaL_addstring(b, r);  /* push replacement in place of pattern */
    s = wild + l;  /* continue after 'p' */
  }
  luaL_addstring(b, s);  /* push last suffix */
}


LUALIB_API const char *luaL_gsub (lua_State *L, const char *s,
                                  const char *p, const char *r) {
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  luaL_addgsub(&b, s, p, r);
  luaL_pushresult(&b);
  return lua_tostring(L, -1);
}


static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
  (void)ud; (void)osize;  /* not used */
  if (nsize == 0) {
    free(ptr);
    return NULL;
  }
  else
    return realloc(ptr, nsize);
}


static int panic (lua_State *L) {
  const char *msg = lua_tostring(L, -1);
  if (msg == NULL) msg = "error object is not a string";
  lua_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
                        msg);
  return 0;  /* return to Lua to abort */
}


/*
** Warning functions:
** warnfoff: warning system is off
** warnfon: ready to start a new message
** warnfcont: previous message is to be continued
*/
static void warnfoff (void *ud, const char *message, int tocont);
static void warnfon (void *ud, const char *message, int tocont);
static void warnfcont (void *ud, const char *message, int tocont);


/*
** Check whether message is a control message. If so, execute the
** control or ignore it if unknown.
*/
static int checkcontrol (lua_State *L, const char *message, int tocont) {
  if (tocont || *(message++) != '@')  /* not a control message? */
    return 0;
  else {
    if (strcmp(message, "off") == 0)
      lua_setwarnf(L, warnfoff, L);  /* turn warnings off */
    else if (strcmp(message, "on") == 0)
      lua_setwarnf(L, warnfon, L);   /* turn warnings on */
    return 1;  /* it was a control message */
  }
}


static void warnfoff (void *ud, const char *message, int tocont) {
  checkcontrol((lua_State *)ud, message, tocont);
}


/*
** Writes the message and handle 'tocont', finishing the message
** if needed and setting the next warn function.
*/
static void warnfcont (void *ud, const char *message, int tocont) {
  lua_State *L = (lua_State *)ud;
  lua_writestringerror("%s", message);  /* write message */
  if (tocont)  /* not the last part? */
    lua_setwarnf(L, warnfcont, L);  /* to be continued */
  else {  /* last part */
    lua_writestringerror("%s", "\n");  /* finish message with end-of-line */
    lua_setwarnf(L, warnfon, L);  /* next call is a new message */
  }
}


static void warnfon (void *ud, const char *message, int tocont) {
  if (checkcontrol((lua_State *)ud, message, tocont))  /* control message? */
    return;  /* nothing else to be done */
  lua_writestringerror("%s", "Lua warning: ");  /* start a new warning */
  warnfcont(ud, message, tocont);  /* finish processing */
}


LUALIB_API lua_State *luaL_newstate (void) {
  lua_State *L = lua_newstate(l_alloc, NULL);
  if (l_likely(L)) {
    lua_atpanic(L, &panic);
    lua_setwarnf(L, warnfoff, L);  /* default is warnings off */
  }
  return L;
}


LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver, size_t sz) {
  lua_Number v = lua_version(L);
  if (sz != LUAL_NUMSIZES)  /* check numeric types */
    luaL_error(L, "core and library have incompatible numeric types");
  else if (v != ver)
    luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
                  (LUAI_UACNUMBER)ver, (LUAI_UACNUMBER)v);
}

#include <stdio.h>
/*
** $Id: lbaselib.c $
** Basic library
** See Copyright Notice in lua.h
*/

#define lbaselib_c
#define LUA_LIB

#include "lprefix.h"


#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


static int luaB_print (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  int i;
  for (i = 1; i <= n; i++) {  /* for each argument */
    size_t l;
    const char *s = luaL_tolstring(L, i, &l);  /* convert it to string */
    if (i > 1)  /* not the first element? */
      lua_writestring("\t", 1);  /* add a tab before it */
    lua_writestring(s, l);  /* print it */
    lua_pop(L, 1);  /* pop result */
  }
  lua_writeline();
  return 0;
}


/*
** Creates a warning with all given arguments.
** Check first for errors; otherwise an error may interrupt
** the composition of a warning, leaving it unfinished.
*/
static int luaB_warn (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  int i;
  luaL_checkstring(L, 1);  /* at least one argument */
  for (i = 2; i <= n; i++)
    luaL_checkstring(L, i);  /* make sure all arguments are strings */
  for (i = 1; i < n; i++)  /* compose warning */
    lua_warning(L, lua_tostring(L, i), 1);
  lua_warning(L, lua_tostring(L, n), 0);  /* close warning */
  return 0;
}


#define SPACECHARS	" \f\n\r\t\v"

static const char *b_str2int (const char *s, int base, lua_Integer *pn) {
  lua_Unsigned n = 0;
  int neg = 0;
  s += strspn(s, SPACECHARS);  /* skip initial spaces */
  if (*s == '-') { s++; neg = 1; }  /* handle sign */
  else if (*s == '+') s++;
  if (!isalnum((unsigned char)*s))  /* no digit? */
    return NULL;
  do {
    int digit = (isdigit((unsigned char)*s)) ? *s - '0'
                   : (toupper((unsigned char)*s) - 'A') + 10;
    if (digit >= base) return NULL;  /* invalid numeral */
    n = n * base + digit;
    s++;
  } while (isalnum((unsigned char)*s));
  s += strspn(s, SPACECHARS);  /* skip trailing spaces */
  *pn = (lua_Integer)((neg) ? (0u - n) : n);
  return s;
}


static int luaB_tonumber (lua_State *L) {
  if (lua_isnoneornil(L, 2)) {  /* standard conversion? */
    if (lua_type(L, 1) == LUA_TNUMBER) {  /* already a number? */
      lua_settop(L, 1);  /* yes; return it */
      return 1;
    }
    else {
      size_t l;
      const char *s = lua_tolstring(L, 1, &l);
      if (s != NULL && lua_stringtonumber(L, s) == l + 1)
        return 1;  /* successful conversion to number */
      /* else not a number */
      luaL_checkany(L, 1);  /* (but there must be some parameter) */
    }
  }
  else {
    size_t l;
    const char *s;
    lua_Integer n = 0;  /* to avoid warnings */
    lua_Integer base = luaL_checkinteger(L, 2);
    luaL_checktype(L, 1, LUA_TSTRING);  /* no numbers as strings */
    s = lua_tolstring(L, 1, &l);
    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
    if (b_str2int(s, (int)base, &n) == s + l) {
      lua_pushinteger(L, n);
      return 1;
    }  /* else not a number */
  }  /* else not a number */
  luaL_pushfail(L);  /* not a number */
  return 1;
}


static int luaB_error (lua_State *L) {
  int level = (int)luaL_optinteger(L, 2, 1);
  lua_settop(L, 1);
  if (lua_type(L, 1) == LUA_TSTRING && level > 0) {
    luaL_where(L, level);   /* add extra information */
    lua_pushvalue(L, 1);
    lua_concat(L, 2);
  }
  return lua_error(L);
}


static int luaB_getmetatable (lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);
    return 1;  /* no metatable */
  }
  luaL_getmetafield(L, 1, "__metatable");
  return 1;  /* returns either __metatable field (if present) or metatable */
}


static int luaB_setmetatable (lua_State *L) {
  int t = lua_type(L, 2);
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_argexpected(L, t == LUA_TNIL || t == LUA_TTABLE, 2, "nil or table");
  if (l_unlikely(luaL_getmetafield(L, 1, "__metatable") != LUA_TNIL))
    return luaL_error(L, "cannot change a protected metatable");
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;
}


static int luaB_rawequal (lua_State *L) {
  luaL_checkany(L, 1);
  luaL_checkany(L, 2);
  lua_pushboolean(L, lua_rawequal(L, 1, 2));
  return 1;
}


static int luaB_rawlen (lua_State *L) {
  int t = lua_type(L, 1);
  luaL_argexpected(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,
                      "table or string");
  lua_pushinteger(L, lua_rawlen(L, 1));
  return 1;
}


static int luaB_rawget (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_rawget(L, 1);
  return 1;
}

static int luaB_rawset (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  luaL_checkany(L, 3);
  lua_settop(L, 3);
  lua_rawset(L, 1);
  return 1;
}


static int pushmode (lua_State *L, int oldmode) {
  lua_pushstring(L, (oldmode == LUA_GCINC) ? "incremental"
                                           : "generational");
  return 1;
}


static int luaB_collectgarbage (lua_State *L) {
  static const char *const opts[] = {"stop", "restart", "collect",
    "count", "step", "setpause", "setstepmul",
    "isrunning", "generational", "incremental", NULL};
  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
    LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};
  int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
  switch (o) {
    case LUA_GCCOUNT: {
      int k = lua_gc(L, o);
      int b = lua_gc(L, LUA_GCCOUNTB);
      lua_pushnumber(L, (lua_Number)k + ((lua_Number)b/1024));
      return 1;
    }
    case LUA_GCSTEP: {
      int step = (int)luaL_optinteger(L, 2, 0);
      int res = lua_gc(L, o, step);
      lua_pushboolean(L, res);
      return 1;
    }
    case LUA_GCSETPAUSE:
    case LUA_GCSETSTEPMUL: {
      int p = (int)luaL_optinteger(L, 2, 0);
      int previous = lua_gc(L, o, p);
      lua_pushinteger(L, previous);
      return 1;
    }
    case LUA_GCISRUNNING: {
      int res = lua_gc(L, o);
      lua_pushboolean(L, res);
      return 1;
    }
    case LUA_GCGEN: {
      int minormul = (int)luaL_optinteger(L, 2, 0);
      int majormul = (int)luaL_optinteger(L, 3, 0);
      return pushmode(L, lua_gc(L, o, minormul, majormul));
    }
    case LUA_GCINC: {
      int pause = (int)luaL_optinteger(L, 2, 0);
      int stepmul = (int)luaL_optinteger(L, 3, 0);
      int stepsize = (int)luaL_optinteger(L, 4, 0);
      return pushmode(L, lua_gc(L, o, pause, stepmul, stepsize));
    }
    default: {
      int res = lua_gc(L, o);
      lua_pushinteger(L, res);
      return 1;
    }
  }
}


static int luaB_type (lua_State *L) {
  int t = lua_type(L, 1);
  luaL_argcheck(L, t != LUA_TNONE, 1, "value expected");
  lua_pushstring(L, lua_typename(L, t));
  return 1;
}


static int luaB_next (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
  if (lua_next(L, 1))
    return 2;
  else {
    lua_pushnil(L);
    return 1;
  }
}


static int luaB_pairs (lua_State *L) {
  luaL_checkany(L, 1);
  if (luaL_getmetafield(L, 1, "__pairs") == LUA_TNIL) {  /* no metamethod? */
    lua_pushcfunction(L, luaB_next);  /* will return generator, */
    lua_pushvalue(L, 1);  /* state, */
    lua_pushnil(L);  /* and initial value */
  }
  else {
    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */
    lua_call(L, 1, 3);  /* get 3 values from metamethod */
  }
  return 3;
}


/*
** Traversal function for 'ipairs'
*/
static int ipairsaux (lua_State *L) {
  lua_Integer i = luaL_checkinteger(L, 2) + 1;
  lua_pushinteger(L, i);
  return (lua_geti(L, 1, i) == LUA_TNIL) ? 1 : 2;
}


/*
** 'ipairs' function. Returns 'ipairsaux', given "table", 0.
** (The given "table" may not be a table.)
*/
static int luaB_ipairs (lua_State *L) {
  luaL_checkany(L, 1);
  lua_pushcfunction(L, ipairsaux);  /* iteration function */
  lua_pushvalue(L, 1);  /* state */
  lua_pushinteger(L, 0);  /* initial value */
  return 3;
}


static int load_aux (lua_State *L, int status, int envidx) {
  if (l_likely(status == LUA_OK)) {
    if (envidx != 0) {  /* 'env' parameter? */
      lua_pushvalue(L, envidx);  /* environment for loaded function */
      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */
        lua_pop(L, 1);  /* remove 'env' if not used by previous call */
    }
    return 1;
  }
  else {  /* error (message is on top of the stack) */
    luaL_pushfail(L);
    lua_insert(L, -2);  /* put before error message */
    return 2;  /* return fail plus error message */
  }
}


static int luaB_loadfile (lua_State *L) {
  const char *fname = luaL_optstring(L, 1, NULL);
  const char *mode = luaL_optstring(L, 2, NULL);
  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */
  int status = luaL_loadfilex(L, fname, mode);
  return load_aux(L, status, env);
}


/*
** {======================================================
** Generic Read function
** =======================================================
*/


/*
** reserved slot, above all arguments, to hold a copy of the returned
** string to avoid it being collected while parsed. 'load' has four
** optional arguments (chunk, source name, mode, and environment).
*/
#define RESERVEDSLOT	5


/*
** Reader for generic 'load' function: 'lua_load' uses the
** stack for internal stuff, so the reader cannot change the
** stack top. Instead, it keeps its resulting string in a
** reserved slot inside the stack.
*/
static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
  (void)(ud);  /* not used */
  luaL_checkstack(L, 2, "too many nested functions");
  lua_pushvalue(L, 1);  /* get function */
  lua_call(L, 0, 1);  /* call it */
  if (lua_isnil(L, -1)) {
    lua_pop(L, 1);  /* pop result */
    *size = 0;
    return NULL;
  }
  else if (l_unlikely(!lua_isstring(L, -1)))
    luaL_error(L, "reader function must return a string");
  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */
  return lua_tolstring(L, RESERVEDSLOT, size);
}


static int luaB_load (lua_State *L) {
  int status;
  size_t l;
  const char *s = lua_tolstring(L, 1, &l);
  const char *mode = luaL_optstring(L, 3, "bt");
  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */
  if (s != NULL) {  /* loading a string? */
    const char *chunkname = luaL_optstring(L, 2, s);
    status = luaL_loadbufferx(L, s, l, chunkname, mode);
  }
  else {  /* loading from a reader function */
    const char *chunkname = luaL_optstring(L, 2, "=(load)");
    luaL_checktype(L, 1, LUA_TFUNCTION);
    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */
    status = lua_load(L, generic_reader, NULL, chunkname, mode);
  }
  return load_aux(L, status, env);
}

/* }====================================================== */


static int dofilecont (lua_State *L, int d1, lua_KContext d2) {
  (void)d1;  (void)d2;  /* only to match 'lua_Kfunction' prototype */
  return lua_gettop(L) - 1;
}


static int luaB_dofile (lua_State *L) {
  const char *fname = luaL_optstring(L, 1, NULL);
  lua_settop(L, 1);
  if (l_unlikely(luaL_loadfile(L, fname) != LUA_OK))
    return lua_error(L);
  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
  return dofilecont(L, 0, 0);
}


static int luaB_assert (lua_State *L) {
  if (l_likely(lua_toboolean(L, 1)))  /* condition is true? */
    return lua_gettop(L);  /* return all arguments */
  else {  /* error */
    luaL_checkany(L, 1);  /* there must be a condition */
    lua_remove(L, 1);  /* remove it */
    lua_pushliteral(L, "assertion failed!");  /* default message */
    lua_settop(L, 1);  /* leave only message (default if no other one) */
    return luaB_error(L);  /* call 'error' */
  }
}


static int luaB_select (lua_State *L) {
  int n = lua_gettop(L);
  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
    lua_pushinteger(L, n-1);
    return 1;
  }
  else {
    lua_Integer i = luaL_checkinteger(L, 1);
    if (i < 0) i = n + i;
    else if (i > n) i = n;
    luaL_argcheck(L, 1 <= i, 1, "index out of range");
    return n - (int)i;
  }
}


/*
** Continuation function for 'pcall' and 'xpcall'. Both functions
** already pushed a 'true' before doing the call, so in case of success
** 'finishpcall' only has to return everything in the stack minus
** 'extra' values (where 'extra' is exactly the number of items to be
** ignored).
*/
static int finishpcall (lua_State *L, int status, lua_KContext extra) {
  if (l_unlikely(status != LUA_OK && status != LUA_YIELD)) {  /* error? */
    lua_pushboolean(L, 0);  /* first result (false) */
    lua_pushvalue(L, -2);  /* error message */
    return 2;  /* return false, msg */
  }
  else
    return lua_gettop(L) - (int)extra;  /* return all results */
}


static int luaB_pcall (lua_State *L) {
  int status;
  luaL_checkany(L, 1);
  lua_pushboolean(L, 1);  /* first result if no errors */
  lua_insert(L, 1);  /* put it in place */
  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);
  return finishpcall(L, status, 0);
}


/*
** Do a protected call with error handling. After 'lua_rotate', the
** stack will have <f, err, true, f, [args...]>; so, the function passes
** 2 to 'finishpcall' to skip the 2 first values when returning results.
*/
static int luaB_xpcall (lua_State *L) {
  int status;
  int n = lua_gettop(L);
  luaL_checktype(L, 2, LUA_TFUNCTION);  /* check error function */
  lua_pushboolean(L, 1);  /* first result */
  lua_pushvalue(L, 1);  /* function */
  lua_rotate(L, 3, 2);  /* move them below function's arguments */
  status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);
  return finishpcall(L, status, 2);
}


static int luaB_tostring (lua_State *L) {
  luaL_checkany(L, 1);
  luaL_tolstring(L, 1, NULL);
  return 1;
}


static const luaL_Reg base_funcs[] = {
  {"assert", luaB_assert},
  {"collectgarbage", luaB_collectgarbage},
  {"dofile", luaB_dofile},
  {"error", luaB_error},
  {"getmetatable", luaB_getmetatable},
  {"ipairs", luaB_ipairs},
  {"loadfile", luaB_loadfile},
  {"load", luaB_load},
  {"next", luaB_next},
  {"pairs", luaB_pairs},
  {"pcall", luaB_pcall},
  {"print", luaB_print},
  {"warn", luaB_warn},
  {"rawequal", luaB_rawequal},
  {"rawlen", luaB_rawlen},
  {"rawget", luaB_rawget},
  {"rawset", luaB_rawset},
  {"select", luaB_select},
  {"setmetatable", luaB_setmetatable},
  {"tonumber", luaB_tonumber},
  {"tostring", luaB_tostring},
  {"type", luaB_type},
  {"xpcall", luaB_xpcall},
  /* placeholders */
  {LUA_GNAME, NULL},
  {"_VERSION", NULL},
  {NULL, NULL}
};


LUAMOD_API int luaopen_base (lua_State *L) {
  /* open lib into global table */
  lua_pushglobaltable(L);
  luaL_setfuncs(L, base_funcs, 0);
  /* set global _G */
  lua_pushvalue(L, -1);
  lua_setfield(L, -2, LUA_GNAME);
  /* set global _VERSION */
  lua_pushliteral(L, LUA_VERSION);
  lua_setfield(L, -2, "_VERSION");
  return 1;
}

#include <stdio.h>
/*
** $Id: lcode.c $
** Code generator for Lua
** See Copyright Notice in lua.h
*/

#define lcode_c
#define LUA_CORE

#include "lprefix.h"


#include <limits.h>
#include <math.h>
#include <stdlib.h>

#include "lua.h"

#include "lcode.h"
#include "ldebug.h"
#include "ldo.h"
#include "lgc.h"
#include "llex.h"
#include "lmem.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lparser.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"


/* Maximum number of registers in a Lua function (must fit in 8 bits) */
#define MAXREGS		255


#define hasjumps(e)	((e)->t != (e)->f)


static int codesJ (FuncState *fs, OpCode o, int sj, int k);



/* semantic error */
l_noret luaK_semerror (LexState *ls, const char *msg) {
  ls->t.token = 0;  /* remove "near <token>" from final message */
  luaX_syntaxerror(ls, msg);
}


/*
** If expression is a numeric constant, fills 'v' with its value
** and returns 1. Otherwise, returns 0.
*/
static int tonumeral (const expdesc *e, TValue *v) {
  if (hasjumps(e))
    return 0;  /* not a numeral */
  switch (e->k) {
    case VKINT:
      if (v) setivalue(v, e->u.ival);
      return 1;
    case VKFLT:
      if (v) setfltvalue(v, e->u.nval);
      return 1;
    default: return 0;
  }
}


/*
** Get the constant value from a constant expression
*/
static TValue *const2val (FuncState *fs, const expdesc *e) {
  lua_assert(e->k == VCONST);
  return &fs->ls->dyd->actvar.arr[e->u.info].k;
}


/*
** If expression is a constant, fills 'v' with its value
** and returns 1. Otherwise, returns 0.
*/
int luaK_exp2const (FuncState *fs, const expdesc *e, TValue *v) {
  if (hasjumps(e))
    return 0;  /* not a constant */
  switch (e->k) {
    case VFALSE:
      setbfvalue(v);
      return 1;
    case VTRUE:
      setbtvalue(v);
      return 1;
    case VNIL:
      setnilvalue(v);
      return 1;
    case VKSTR: {
      setsvalue(fs->ls->L, v, e->u.strval);
      return 1;
    }
    case VCONST: {
      setobj(fs->ls->L, v, const2val(fs, e));
      return 1;
    }
    default: return tonumeral(e, v);
  }
}


/*
** Return the previous instruction of the current code. If there
** may be a jump target between the current instruction and the
** previous one, return an invalid instruction (to avoid wrong
** optimizations).
*/
static Instruction *previousinstruction (FuncState *fs) {
  static const Instruction invalidinstruction = ~(Instruction)0;
  if (fs->pc > fs->lasttarget)
    return &fs->f->code[fs->pc - 1];  /* previous instruction */
  else
    return cast(Instruction*, &invalidinstruction);
}


/*
** Create a OP_LOADNIL instruction, but try to optimize: if the previous
** instruction is also OP_LOADNIL and ranges are compatible, adjust
** range of previous instruction instead of emitting a new one. (For
** instance, 'local a; local b' will generate a single opcode.)
*/
void luaK_nil (FuncState *fs, int from, int n) {
  int l = from + n - 1;  /* last register to set nil */
  Instruction *previous = previousinstruction(fs);
  if (GET_OPCODE(*previous) == OP_LOADNIL) {  /* previous is LOADNIL? */
    int pfrom = GETARG_A(*previous);  /* get previous range */
    int pl = pfrom + GETARG_B(*previous);
    if ((pfrom <= from && from <= pl + 1) ||
        (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */
      if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */
      if (pl > l) l = pl;  /* l = max(l, pl) */
      SETARG_A(*previous, from);
      SETARG_B(*previous, l - from);
      return;
    }  /* else go through */
  }
  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */
}


/*
** Gets the destination address of a jump instruction. Used to traverse
** a list of jumps.
*/
static int getjump (FuncState *fs, int pc) {
  int offset = GETARG_sJ(fs->f->code[pc]);
  if (offset == NO_JUMP)  /* point to itself represents end of list */
    return NO_JUMP;  /* end of list */
  else
    return (pc+1)+offset;  /* turn offset into absolute position */
}


/*
** Fix jump instruction at position 'pc' to jump to 'dest'.
** (Jump addresses are relative in Lua)
*/
static void fixjump (FuncState *fs, int pc, int dest) {
  Instruction *jmp = &fs->f->code[pc];
  int offset = dest - (pc + 1);
  lua_assert(dest != NO_JUMP);
  if (!(-OFFSET_sJ <= offset && offset <= MAXARG_sJ - OFFSET_sJ))
    luaX_syntaxerror(fs->ls, "control structure too long");
  lua_assert(GET_OPCODE(*jmp) == OP_JMP);
  SETARG_sJ(*jmp, offset);
}


/*
** Concatenate jump-list 'l2' into jump-list 'l1'
*/
void luaK_concat (FuncState *fs, int *l1, int l2) {
  if (l2 == NO_JUMP) return;  /* nothing to concatenate? */
  else if (*l1 == NO_JUMP)  /* no original list? */
    *l1 = l2;  /* 'l1' points to 'l2' */
  else {
    int list = *l1;
    int next;
    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
      list = next;
    fixjump(fs, list, l2);  /* last element links to 'l2' */
  }
}


/*
** Create a jump instruction and return its position, so its destination
** can be fixed later (with 'fixjump').
*/
int luaK_jump (FuncState *fs) {
  return codesJ(fs, OP_JMP, NO_JUMP, 0);
}


/*
** Code a 'return' instruction
*/
void luaK_ret (FuncState *fs, int first, int nret) {
  OpCode op;
  switch (nret) {
    case 0: op = OP_RETURN0; break;
    case 1: op = OP_RETURN1; break;
    default: op = OP_RETURN; break;
  }
  luaK_codeABC(fs, op, first, nret + 1, 0);
}


/*
** Code a "conditional jump", that is, a test or comparison opcode
** followed by a jump. Return jump position.
*/
static int condjump (FuncState *fs, OpCode op, int A, int B, int C, int k) {
  luaK_codeABCk(fs, op, A, B, C, k);
  return luaK_jump(fs);
}


/*
** returns current 'pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/
int luaK_getlabel (FuncState *fs) {
  fs->lasttarget = fs->pc;
  return fs->pc;
}


/*
** Returns the position of the instruction "controlling" a given
** jump (that is, its condition), or the jump itself if it is
** unconditional.
*/
static Instruction *getjumpcontrol (FuncState *fs, int pc) {
  Instruction *pi = &fs->f->code[pc];
  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
    return pi-1;
  else
    return pi;
}


/*
** Patch destination register for a TESTSET instruction.
** If instruction in position 'node' is not a TESTSET, return 0 ("fails").
** Otherwise, if 'reg' is not 'NO_REG', set it as the destination
** register. Otherwise, change instruction to a simple 'TEST' (produces
** no register value)
*/
static int patchtestreg (FuncState *fs, int node, int reg) {
  Instruction *i = getjumpcontrol(fs, node);
  if (GET_OPCODE(*i) != OP_TESTSET)
    return 0;  /* cannot patch other instructions */
  if (reg != NO_REG && reg != GETARG_B(*i))
    SETARG_A(*i, reg);
  else {
     /* no register to put value or register already has the value;
        change instruction to simple test */
    *i = CREATE_ABCk(OP_TEST, GETARG_B(*i), 0, 0, GETARG_k(*i));
  }
  return 1;
}


/*
** Traverse a list of tests ensuring no one produces a value
*/
static void removevalues (FuncState *fs, int list) {
  for (; list != NO_JUMP; list = getjump(fs, list))
      patchtestreg(fs, list, NO_REG);
}


/*
** Traverse a list of tests, patching their destination address and
** registers: tests producing values jump to 'vtarget' (and put their
** values in 'reg'), other tests jump to 'dtarget'.
*/
static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
                          int dtarget) {
  while (list != NO_JUMP) {
    int next = getjump(fs, list);
    if (patchtestreg(fs, list, reg))
      fixjump(fs, list, vtarget);
    else
      fixjump(fs, list, dtarget);  /* jump to default target */
    list = next;
  }
}


/*
** Path all jumps in 'list' to jump to 'target'.
** (The assert means that we cannot fix a jump to a forward address
** because we only know addresses once code is generated.)
*/
void luaK_patchlist (FuncState *fs, int list, int target) {
  lua_assert(target <= fs->pc);
  patchlistaux(fs, list, target, NO_REG, target);
}


void luaK_patchtohere (FuncState *fs, int list) {
  int hr = luaK_getlabel(fs);  /* mark "here" as a jump target */
  luaK_patchlist(fs, list, hr);
}


/* limit for difference between lines in relative line info. */
#define LIMLINEDIFF	0x80


/*
** Save line info for a new instruction. If difference from last line
** does not fit in a byte, of after that many instructions, save a new
** absolute line info; (in that case, the special value 'ABSLINEINFO'
** in 'lineinfo' signals the existence of this absolute information.)
** Otherwise, store the difference from last line in 'lineinfo'.
*/
static void savelineinfo (FuncState *fs, Proto *f, int line) {
  int linedif = line - fs->previousline;
  int pc = fs->pc - 1;  /* last instruction coded */
  if (abs(linedif) >= LIMLINEDIFF || fs->iwthabs++ >= MAXIWTHABS) {
    luaM_growvector(fs->ls->L, f->abslineinfo, fs->nabslineinfo,
                    f->sizeabslineinfo, AbsLineInfo, MAX_INT, "lines");
    f->abslineinfo[fs->nabslineinfo].pc = pc;
    f->abslineinfo[fs->nabslineinfo++].line = line;
    linedif = ABSLINEINFO;  /* signal that there is absolute information */
    fs->iwthabs = 1;  /* restart counter */
  }
  luaM_growvector(fs->ls->L, f->lineinfo, pc, f->sizelineinfo, ls_byte,
                  MAX_INT, "opcodes");
  f->lineinfo[pc] = linedif;
  fs->previousline = line;  /* last line saved */
}


/*
** Remove line information from the last instruction.
** If line information for that instruction is absolute, set 'iwthabs'
** above its max to force the new (replacing) instruction to have
** absolute line info, too.
*/
static void removelastlineinfo (FuncState *fs) {
  Proto *f = fs->f;
  int pc = fs->pc - 1;  /* last instruction coded */
  if (f->lineinfo[pc] != ABSLINEINFO) {  /* relative line info? */
    fs->previousline -= f->lineinfo[pc];  /* correct last line saved */
    fs->iwthabs--;  /* undo previous increment */
  }
  else {  /* absolute line information */
    lua_assert(f->abslineinfo[fs->nabslineinfo - 1].pc == pc);
    fs->nabslineinfo--;  /* remove it */
    fs->iwthabs = MAXIWTHABS + 1;  /* force next line info to be absolute */
  }
}


/*
** Remove the last instruction created, correcting line information
** accordingly.
*/
static void removelastinstruction (FuncState *fs) {
  removelastlineinfo(fs);
  fs->pc--;
}


/*
** Emit instruction 'i', checking for array sizes and saving also its
** line information. Return 'i' position.
*/
int luaK_code (FuncState *fs, Instruction i) {
  Proto *f = fs->f;
  /* put new instruction in code array */
  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
                  MAX_INT, "opcodes");
  f->code[fs->pc++] = i;
  savelineinfo(fs, f, fs->ls->lastline);
  return fs->pc - 1;  /* index of new instruction */
}


/*
** Format and emit an 'iABC' instruction. (Assertions check consistency
** of parameters versus opcode.)
*/
int luaK_codeABCk (FuncState *fs, OpCode o, int a, int b, int c, int k) {
  lua_assert(getOpMode(o) == iABC);
  lua_assert(a <= MAXARG_A && b <= MAXARG_B &&
             c <= MAXARG_C && (k & ~1) == 0);
  return luaK_code(fs, CREATE_ABCk(o, a, b, c, k));
}


/*
** Format and emit an 'iABx' instruction.
*/
int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
  lua_assert(getOpMode(o) == iABx);
  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);
  return luaK_code(fs, CREATE_ABx(o, a, bc));
}


/*
** Format and emit an 'iAsBx' instruction.
*/
int luaK_codeAsBx (FuncState *fs, OpCode o, int a, int bc) {
  unsigned int b = bc + OFFSET_sBx;
  lua_assert(getOpMode(o) == iAsBx);
  lua_assert(a <= MAXARG_A && b <= MAXARG_Bx);
  return luaK_code(fs, CREATE_ABx(o, a, b));
}


/*
** Format and emit an 'isJ' instruction.
*/
static int codesJ (FuncState *fs, OpCode o, int sj, int k) {
  unsigned int j = sj + OFFSET_sJ;
  lua_assert(getOpMode(o) == isJ);
  lua_assert(j <= MAXARG_sJ && (k & ~1) == 0);
  return luaK_code(fs, CREATE_sJ(o, j, k));
}


/*
** Emit an "extra argument" instruction (format 'iAx')
*/
static int codeextraarg (FuncState *fs, int a) {
  lua_assert(a <= MAXARG_Ax);
  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
}


/*
** Emit a "load constant" instruction, using either 'OP_LOADK'
** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'
** instruction with "extra argument".
*/
static int luaK_codek (FuncState *fs, int reg, int k) {
  if (k <= MAXARG_Bx)
    return luaK_codeABx(fs, OP_LOADK, reg, k);
  else {
    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
    codeextraarg(fs, k);
    return p;
  }
}


/*
** Check register-stack level, keeping track of its maximum size
** in field 'maxstacksize'
*/
void luaK_checkstack (FuncState *fs, int n) {
  int newstack = fs->freereg + n;
  if (newstack > fs->f->maxstacksize) {
    if (newstack >= MAXREGS)
      luaX_syntaxerror(fs->ls,
        "function or expression needs too many registers");
    fs->f->maxstacksize = cast_byte(newstack);
  }
}


/*
** Reserve 'n' registers in register stack
*/
void luaK_reserveregs (FuncState *fs, int n) {
  luaK_checkstack(fs, n);
  fs->freereg += n;
}


/*
** Free register 'reg', if it is neither a constant index nor
** a local variable.
)
*/
static void freereg (FuncState *fs, int reg) {
  if (reg >= luaY_nvarstack(fs)) {
    fs->freereg--;
    lua_assert(reg == fs->freereg);
  }
}


/*
** Free two registers in proper order
*/
static void freeregs (FuncState *fs, int r1, int r2) {
  if (r1 > r2) {
    freereg(fs, r1);
    freereg(fs, r2);
  }
  else {
    freereg(fs, r2);
    freereg(fs, r1);
  }
}


/*
** Free register used by expression 'e' (if any)
*/
static void freeexp (FuncState *fs, expdesc *e) {
  if (e->k == VNONRELOC)
    freereg(fs, e->u.info);
}


/*
** Free registers used by expressions 'e1' and 'e2' (if any) in proper
** order.
*/
static void freeexps (FuncState *fs, expdesc *e1, expdesc *e2) {
  int r1 = (e1->k == VNONRELOC) ? e1->u.info : -1;
  int r2 = (e2->k == VNONRELOC) ? e2->u.info : -1;
  freeregs(fs, r1, r2);
}


/*
** Add constant 'v' to prototype's list of constants (field 'k').
** Use scanner's table to cache position of constants in constant list
** and try to reuse constants. Because some values should not be used
** as keys (nil cannot be a key, integer keys can collapse with float
** keys), the caller must provide a useful 'key' for indexing the cache.
** Note that all functions share the same table, so entering or exiting
** a function can make some indices wrong.
*/
static int addk (FuncState *fs, TValue *key, TValue *v) {
  TValue val;
  lua_State *L = fs->ls->L;
  Proto *f = fs->f;
  const TValue *idx = luaH_get(fs->ls->h, key);  /* query scanner table */
  int k, oldsize;
  if (ttisinteger(idx)) {  /* is there an index there? */
    k = cast_int(ivalue(idx));
    /* correct value? (warning: must distinguish floats from integers!) */
    if (k < fs->nk && ttypetag(&f->k[k]) == ttypetag(v) &&
                      luaV_rawequalobj(&f->k[k], v))
      return k;  /* reuse index */
  }
  /* constant not found; create a new entry */
  oldsize = f->sizek;
  k = fs->nk;
  /* numerical value does not need GC barrier;
     table has no metatable, so it does not need to invalidate cache */
  setivalue(&val, k);
  luaH_finishset(L, fs->ls->h, key, idx, &val);
  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
  setobj(L, &f->k[k], v);
  fs->nk++;
  luaC_barrier(L, f, v);
  return k;
}


/*
** Add a string to list of constants and return its index.
*/
static int stringK (FuncState *fs, TString *s) {
  TValue o;
  setsvalue(fs->ls->L, &o, s);
  return addk(fs, &o, &o);  /* use string itself as key */
}


/*
** Add an integer to list of constants and return its index.
** Integers use userdata as keys to avoid collision with floats with
** same value; conversion to 'void*' is used only for hashing, so there
** are no "precision" problems.
*/
static int luaK_intK (FuncState *fs, lua_Integer n) {
  TValue k, o;
  setpvalue(&k, cast_voidp(cast_sizet(n)));
  setivalue(&o, n);
  return addk(fs, &k, &o);
}

/*
** Add a float to list of constants and return its index.
*/
static int luaK_numberK (FuncState *fs, lua_Number r) {
  TValue o;
  setfltvalue(&o, r);
  return addk(fs, &o, &o);  /* use number itself as key */
}


/*
** Add a false to list of constants and return its index.
*/
static int boolF (FuncState *fs) {
  TValue o;
  setbfvalue(&o);
  return addk(fs, &o, &o);  /* use boolean itself as key */
}


/*
** Add a true to list of constants and return its index.
*/
static int boolT (FuncState *fs) {
  TValue o;
  setbtvalue(&o);
  return addk(fs, &o, &o);  /* use boolean itself as key */
}


/*
** Add nil to list of constants and return its index.
*/
static int nilK (FuncState *fs) {
  TValue k, v;
  setnilvalue(&v);
  /* cannot use nil as key; instead use table itself to represent nil */
  sethvalue(fs->ls->L, &k, fs->ls->h);
  return addk(fs, &k, &v);
}


/*
** Check whether 'i' can be stored in an 'sC' operand. Equivalent to
** (0 <= int2sC(i) && int2sC(i) <= MAXARG_C) but without risk of
** overflows in the hidden addition inside 'int2sC'.
*/
static int fitsC (lua_Integer i) {
  return (l_castS2U(i) + OFFSET_sC <= cast_uint(MAXARG_C));
}


/*
** Check whether 'i' can be stored in an 'sBx' operand.
*/
static int fitsBx (lua_Integer i) {
  return (-OFFSET_sBx <= i && i <= MAXARG_Bx - OFFSET_sBx);
}


void luaK_int (FuncState *fs, int reg, lua_Integer i) {
  if (fitsBx(i))
    luaK_codeAsBx(fs, OP_LOADI, reg, cast_int(i));
  else
    luaK_codek(fs, reg, luaK_intK(fs, i));
}


static void luaK_float (FuncState *fs, int reg, lua_Number f) {
  lua_Integer fi;
  if (luaV_flttointeger(f, &fi, F2Ieq) && fitsBx(fi))
    luaK_codeAsBx(fs, OP_LOADF, reg, cast_int(fi));
  else
    luaK_codek(fs, reg, luaK_numberK(fs, f));
}


/*
** Convert a constant in 'v' into an expression description 'e'
*/
static void const2exp (TValue *v, expdesc *e) {
  switch (ttypetag(v)) {
    case LUA_VNUMINT:
      e->k = VKINT; e->u.ival = ivalue(v);
      break;
    case LUA_VNUMFLT:
      e->k = VKFLT; e->u.nval = fltvalue(v);
      break;
    case LUA_VFALSE:
      e->k = VFALSE;
      break;
    case LUA_VTRUE:
      e->k = VTRUE;
      break;
    case LUA_VNIL:
      e->k = VNIL;
      break;
    case LUA_VSHRSTR:  case LUA_VLNGSTR:
      e->k = VKSTR; e->u.strval = tsvalue(v);
      break;
    default: lua_assert(0);
  }
}


/*
** Fix an expression to return the number of results 'nresults'.
** 'e' must be a multi-ret expression (function call or vararg).
*/
void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
  Instruction *pc = &getinstruction(fs, e);
  if (e->k == VCALL)  /* expression is an open function call? */
    SETARG_C(*pc, nresults + 1);
  else {
    lua_assert(e->k == VVARARG);
    SETARG_C(*pc, nresults + 1);
    SETARG_A(*pc, fs->freereg);
    luaK_reserveregs(fs, 1);
  }
}


/*
** Convert a VKSTR to a VK
*/
static void str2K (FuncState *fs, expdesc *e) {
  lua_assert(e->k == VKSTR);
  e->u.info = stringK(fs, e->u.strval);
  e->k = VK;
}


/*
** Fix an expression to return one result.
** If expression is not a multi-ret expression (function call or
** vararg), it already returns one result, so nothing needs to be done.
** Function calls become VNONRELOC expressions (as its result comes
** fixed in the base register of the call), while vararg expressions
** become VRELOC (as OP_VARARG puts its results where it wants).
** (Calls are created returning one result, so that does not need
** to be fixed.)
*/
void luaK_setoneret (FuncState *fs, expdesc *e) {
  if (e->k == VCALL) {  /* expression is an open function call? */
    /* already returns 1 value */
    lua_assert(GETARG_C(getinstruction(fs, e)) == 2);
    e->k = VNONRELOC;  /* result has fixed position */
    e->u.info = GETARG_A(getinstruction(fs, e));
  }
  else if (e->k == VVARARG) {
    SETARG_C(getinstruction(fs, e), 2);
    e->k = VRELOC;  /* can relocate its simple result */
  }
}


/*
** Ensure that expression 'e' is not a variable (nor a <const>).
** (Expression still may have jump lists.)
*/
void luaK_dischargevars (FuncState *fs, expdesc *e) {
  switch (e->k) {
    case VCONST: {
      const2exp(const2val(fs, e), e);
      break;
    }
    case VLOCAL: {  /* already in a register */
      e->u.info = e->u.var.ridx;
      e->k = VNONRELOC;  /* becomes a non-relocatable value */
      break;
    }
    case VUPVAL: {  /* move value to some (pending) register */
      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
      e->k = VRELOC;
      break;
    }
    case VINDEXUP: {
      e->u.info = luaK_codeABC(fs, OP_GETTABUP, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOC;
      break;
    }
    case VINDEXI: {
      freereg(fs, e->u.ind.t);
      e->u.info = luaK_codeABC(fs, OP_GETI, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOC;
      break;
    }
    case VINDEXSTR: {
      freereg(fs, e->u.ind.t);
      e->u.info = luaK_codeABC(fs, OP_GETFIELD, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOC;
      break;
    }
    case VINDEXED: {
      freeregs(fs, e->u.ind.t, e->u.ind.idx);
      e->u.info = luaK_codeABC(fs, OP_GETTABLE, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOC;
      break;
    }
    case VVARARG: case VCALL: {
      luaK_setoneret(fs, e);
      break;
    }
    default: break;  /* there is one value available (somewhere) */
  }
}


/*
** Ensure expression value is in register 'reg', making 'e' a
** non-relocatable expression.
** (Expression still may have jump lists.)
*/
static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VNIL: {
      luaK_nil(fs, reg, 1);
      break;
    }
    case VFALSE: {
      luaK_codeABC(fs, OP_LOADFALSE, reg, 0, 0);
      break;
    }
    case VTRUE: {
      luaK_codeABC(fs, OP_LOADTRUE, reg, 0, 0);
      break;
    }
    case VKSTR: {
      str2K(fs, e);
    }  /* FALLTHROUGH */
    case VK: {
      luaK_codek(fs, reg, e->u.info);
      break;
    }
    case VKFLT: {
      luaK_float(fs, reg, e->u.nval);
      break;
    }
    case VKINT: {
      luaK_int(fs, reg, e->u.ival);
      break;
    }
    case VRELOC: {
      Instruction *pc = &getinstruction(fs, e);
      SETARG_A(*pc, reg);  /* instruction will put result in 'reg' */
      break;
    }
    case VNONRELOC: {
      if (reg != e->u.info)
        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
      break;
    }
    default: {
      lua_assert(e->k == VJMP);
      return;  /* nothing to do... */
    }
  }
  e->u.info = reg;
  e->k = VNONRELOC;
}


/*
** Ensure expression value is in a register, making 'e' a
** non-relocatable expression.
** (Expression still may have jump lists.)
*/
static void discharge2anyreg (FuncState *fs, expdesc *e) {
  if (e->k != VNONRELOC) {  /* no fixed register yet? */
    luaK_reserveregs(fs, 1);  /* get a register */
    discharge2reg(fs, e, fs->freereg-1);  /* put value there */
  }
}


static int code_loadbool (FuncState *fs, int A, OpCode op) {
  luaK_getlabel(fs);  /* those instructions may be jump targets */
  return luaK_codeABC(fs, op, A, 0, 0);
}


/*
** check whether list has any jump that do not produce a value
** or produce an inverted value
*/
static int need_value (FuncState *fs, int list) {
  for (; list != NO_JUMP; list = getjump(fs, list)) {
    Instruction i = *getjumpcontrol(fs, list);
    if (GET_OPCODE(i) != OP_TESTSET) return 1;
  }
  return 0;  /* not found */
}


/*
** Ensures final expression result (which includes results from its
** jump lists) is in register 'reg'.
** If expression has jumps, need to patch these jumps either to
** its final position or to "load" instructions (for those tests
** that do not produce values).
*/
static void exp2reg (FuncState *fs, expdesc *e, int reg) {
  discharge2reg(fs, e, reg);
  if (e->k == VJMP)  /* expression itself is a test? */
    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in 't' list */
  if (hasjumps(e)) {
    int final;  /* position after whole expression */
    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
    if (need_value(fs, e->t) || need_value(fs, e->f)) {
      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);
      p_f = code_loadbool(fs, reg, OP_LFALSESKIP);  /* skip next inst. */
      p_t = code_loadbool(fs, reg, OP_LOADTRUE);
      /* jump around these booleans if 'e' is not a test */
      luaK_patchtohere(fs, fj);
    }
    final = luaK_getlabel(fs);
    patchlistaux(fs, e->f, final, reg, p_f);
    patchlistaux(fs, e->t, final, reg, p_t);
  }
  e->f = e->t = NO_JUMP;
  e->u.info = reg;
  e->k = VNONRELOC;
}


/*
** Ensures final expression result is in next available register.
*/
void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  freeexp(fs, e);
  luaK_reserveregs(fs, 1);
  exp2reg(fs, e, fs->freereg - 1);
}


/*
** Ensures final expression result is in some (any) register
** and return that register.
*/
int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  if (e->k == VNONRELOC) {  /* expression already has a register? */
    if (!hasjumps(e))  /* no jumps? */
      return e->u.info;  /* result is already in a register */
    if (e->u.info >= luaY_nvarstack(fs)) {  /* reg. is not a local? */
      exp2reg(fs, e, e->u.info);  /* put final result in it */
      return e->u.info;
    }
    /* else expression has jumps and cannot change its register
       to hold the jump values, because it is a local variable.
       Go through to the default case. */
  }
  luaK_exp2nextreg(fs, e);  /* default: use next available register */
  return e->u.info;
}


/*
** Ensures final expression result is either in a register
** or in an upvalue.
*/
void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
  if (e->k != VUPVAL || hasjumps(e))
    luaK_exp2anyreg(fs, e);
}


/*
** Ensures final expression result is either in a register
** or it is a constant.
*/
void luaK_exp2val (FuncState *fs, expdesc *e) {
  if (hasjumps(e))
    luaK_exp2anyreg(fs, e);
  else
    luaK_dischargevars(fs, e);
}


/*
** Try to make 'e' a K expression with an index in the range of R/K
** indices. Return true iff succeeded.
*/
static int luaK_exp2K (FuncState *fs, expdesc *e) {
  if (!hasjumps(e)) {
    int info;
    switch (e->k) {  /* move constants to 'k' */
      case VTRUE: info = boolT(fs); break;
      case VFALSE: info = boolF(fs); break;
      case VNIL: info = nilK(fs); break;
      case VKINT: info = luaK_intK(fs, e->u.ival); break;
      case VKFLT: info = luaK_numberK(fs, e->u.nval); break;
      case VKSTR: info = stringK(fs, e->u.strval); break;
      case VK: info = e->u.info; break;
      default: return 0;  /* not a constant */
    }
    if (info <= MAXINDEXRK) {  /* does constant fit in 'argC'? */
      e->k = VK;  /* make expression a 'K' expression */
      e->u.info = info;
      return 1;
    }
  }
  /* else, expression doesn't fit; leave it unchanged */
  return 0;
}


/*
** Ensures final expression result is in a valid R/K index
** (that is, it is either in a register or in 'k' with an index
** in the range of R/K indices).
** Returns 1 iff expression is K.
*/
int luaK_exp2RK (FuncState *fs, expdesc *e) {
  if (luaK_exp2K(fs, e))
    return 1;
  else {  /* not a constant in the right range: put it in a register */
    luaK_exp2anyreg(fs, e);
    return 0;
  }
}


static void codeABRK (FuncState *fs, OpCode o, int a, int b,
                      expdesc *ec) {
  int k = luaK_exp2RK(fs, ec);
  luaK_codeABCk(fs, o, a, b, ec->u.info, k);
}


/*
** Generate code to store result of expression 'ex' into variable 'var'.
*/
void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
  switch (var->k) {
    case VLOCAL: {
      freeexp(fs, ex);
      exp2reg(fs, ex, var->u.var.ridx);  /* compute 'ex' into proper place */
      return;
    }
    case VUPVAL: {
      int e = luaK_exp2anyreg(fs, ex);
      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
      break;
    }
    case VINDEXUP: {
      codeABRK(fs, OP_SETTABUP, var->u.ind.t, var->u.ind.idx, ex);
      break;
    }
    case VINDEXI: {
      codeABRK(fs, OP_SETI, var->u.ind.t, var->u.ind.idx, ex);
      break;
    }
    case VINDEXSTR: {
      codeABRK(fs, OP_SETFIELD, var->u.ind.t, var->u.ind.idx, ex);
      break;
    }
    case VINDEXED: {
      codeABRK(fs, OP_SETTABLE, var->u.ind.t, var->u.ind.idx, ex);
      break;
    }
    default: lua_assert(0);  /* invalid var kind to store */
  }
  freeexp(fs, ex);
}


/*
** Emit SELF instruction (convert expression 'e' into 'e:key(e,').
*/
void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
  int ereg;
  luaK_exp2anyreg(fs, e);
  ereg = e->u.info;  /* register where 'e' was placed */
  freeexp(fs, e);
  e->u.info = fs->freereg;  /* base register for op_self */
  e->k = VNONRELOC;  /* self expression has a fixed register */
  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */
  codeABRK(fs, OP_SELF, e->u.info, ereg, key);
  freeexp(fs, key);
}


/*
** Negate condition 'e' (where 'e' is a comparison).
*/
static void negatecondition (FuncState *fs, expdesc *e) {
  Instruction *pc = getjumpcontrol(fs, e->u.info);
  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
                                           GET_OPCODE(*pc) != OP_TEST);
  SETARG_k(*pc, (GETARG_k(*pc) ^ 1));
}


/*
** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'
** is true, code will jump if 'e' is true.) Return jump position.
** Optimize when 'e' is 'not' something, inverting the condition
** and removing the 'not'.
*/
static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e->k == VRELOC) {
    Instruction ie = getinstruction(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      removelastinstruction(fs);  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, 0, cond);
}


/*
** Emit code to go through if 'e' is true, jump otherwise.
*/
void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of new jump */
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VJMP: {  /* condition? */
      negatecondition(fs, e);  /* jump when it is false */
      pc = e->u.info;  /* save jump position */
      break;
    }
    case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);  /* jump when false */
      break;
    }
  }
  luaK_concat(fs, &e->f, pc);  /* insert new jump in false list */
  luaK_patchtohere(fs, e->t);  /* true list jumps to here (to go through) */
  e->t = NO_JUMP;
}


/*
** Emit code to go through if 'e' is false, jump otherwise.
*/
void luaK_goiffalse (FuncState *fs, expdesc *e) {
  int pc;  /* pc of new jump */
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VJMP: {
      pc = e->u.info;  /* already jump if true */
      break;
    }
    case VNIL: case VFALSE: {
      pc = NO_JUMP;  /* always false; do nothing */
      break;
    }
    default: {
      pc = jumponcond(fs, e, 1);  /* jump if true */
      break;
    }
  }
  luaK_concat(fs, &e->t, pc);  /* insert new jump in 't' list */
  luaK_patchtohere(fs, e->f);  /* false list jumps to here (to go through) */
  e->f = NO_JUMP;
}


/*
** Code 'not e', doing constant folding.
*/
static void codenot (FuncState *fs, expdesc *e) {
  switch (e->k) {
    case VNIL: case VFALSE: {
      e->k = VTRUE;  /* true == not nil == not false */
      break;
    }
    case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {
      e->k = VFALSE;  /* false == not "x" == not 0.5 == not 1 == not true */
      break;
    }
    case VJMP: {
      negatecondition(fs, e);
      break;
    }
    case VRELOC:
    case VNONRELOC: {
      discharge2anyreg(fs, e);
      freeexp(fs, e);
      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);
      e->k = VRELOC;
      break;
    }
    default: lua_assert(0);  /* cannot happen */
  }
  /* interchange true and false lists */
  { int temp = e->f; e->f = e->t; e->t = temp; }
  removevalues(fs, e->f);  /* values are useless when negated */
  removevalues(fs, e->t);
}


/*
** Check whether expression 'e' is a small literal string
*/
static int isKstr (FuncState *fs, expdesc *e) {
  return (e->k == VK && !hasjumps(e) && e->u.info <= MAXARG_B &&
          ttisshrstring(&fs->f->k[e->u.info]));
}

/*
** Check whether expression 'e' is a literal integer.
*/
int luaK_isKint (expdesc *e) {
  return (e->k == VKINT && !hasjumps(e));
}


/*
** Check whether expression 'e' is a literal integer in
** proper range to fit in register C
*/
static int isCint (expdesc *e) {
  return luaK_isKint(e) && (l_castS2U(e->u.ival) <= l_castS2U(MAXARG_C));
}


/*
** Check whether expression 'e' is a literal integer in
** proper range to fit in register sC
*/
static int isSCint (expdesc *e) {
  return luaK_isKint(e) && fitsC(e->u.ival);
}


/*
** Check whether expression 'e' is a literal integer or float in
** proper range to fit in a register (sB or sC).
*/
static int isSCnumber (expdesc *e, int *pi, int *isfloat) {
  lua_Integer i;
  if (e->k == VKINT)
    i = e->u.ival;
  else if (e->k == VKFLT && luaV_flttointeger(e->u.nval, &i, F2Ieq))
    *isfloat = 1;
  else
    return 0;  /* not a number */
  if (!hasjumps(e) && fitsC(i)) {
    *pi = int2sC(cast_int(i));
    return 1;
  }
  else
    return 0;
}


/*
** Create expression 't[k]'. 't' must have its final result already in a
** register or upvalue. Upvalues can only be indexed by literal strings.
** Keys can be literal strings in the constant table or arbitrary
** values in registers.
*/
void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
  if (k->k == VKSTR)
    str2K(fs, k);
  lua_assert(!hasjumps(t) &&
             (t->k == VLOCAL || t->k == VNONRELOC || t->k == VUPVAL));
  if (t->k == VUPVAL && !isKstr(fs, k))  /* upvalue indexed by non 'Kstr'? */
    luaK_exp2anyreg(fs, t);  /* put it in a register */
  if (t->k == VUPVAL) {
    t->u.ind.t = t->u.info;  /* upvalue index */
    t->u.ind.idx = k->u.info;  /* literal string */
    t->k = VINDEXUP;
  }
  else {
    /* register index of the table */
    t->u.ind.t = (t->k == VLOCAL) ? t->u.var.ridx: t->u.info;
    if (isKstr(fs, k)) {
      t->u.ind.idx = k->u.info;  /* literal string */
      t->k = VINDEXSTR;
    }
    else if (isCint(k)) {
      t->u.ind.idx = cast_int(k->u.ival);  /* int. constant in proper range */
      t->k = VINDEXI;
    }
    else {
      t->u.ind.idx = luaK_exp2anyreg(fs, k);  /* register */
      t->k = VINDEXED;
    }
  }
}


/*
** Return false if folding can raise an error.
** Bitwise operations need operands convertible to integers; division
** operations cannot have 0 as divisor.
*/
static int validop (int op, TValue *v1, TValue *v2) {
  switch (op) {
    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:
    case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  /* conversion errors */
      lua_Integer i;
      return (luaV_tointegerns(v1, &i, LUA_FLOORN2I) &&
              luaV_tointegerns(v2, &i, LUA_FLOORN2I));
    }
    case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  /* division by 0 */
      return (nvalue(v2) != 0);
    default: return 1;  /* everything else is valid */
  }
}


/*
** Try to "constant-fold" an operation; return 1 iff successful.
** (In this case, 'e1' has the final result.)
*/
static int constfolding (FuncState *fs, int op, expdesc *e1,
                                        const expdesc *e2) {
  TValue v1, v2, res;
  if (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))
    return 0;  /* non-numeric operands or not safe to fold */
  luaO_rawarith(fs->ls->L, op, &v1, &v2, &res);  /* does operation */
  if (ttisinteger(&res)) {
    e1->k = VKINT;
    e1->u.ival = ivalue(&res);
  }
  else {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */
    lua_Number n = fltvalue(&res);
    if (luai_numisnan(n) || n == 0)
      return 0;
    e1->k = VKFLT;
    e1->u.nval = n;
  }
  return 1;
}


/*
** Emit code for unary expressions that "produce values"
** (everything but 'not').
** Expression to produce final result will be encoded in 'e'.
*/
static void codeunexpval (FuncState *fs, OpCode op, expdesc *e, int line) {
  int r = luaK_exp2anyreg(fs, e);  /* opcodes operate only on registers */
  freeexp(fs, e);
  e->u.info = luaK_codeABC(fs, op, 0, r, 0);  /* generate opcode */
  e->k = VRELOC;  /* all those operations are relocatable */
  luaK_fixline(fs, line);
}


/*
** Emit code for binary expressions that "produce values"
** (everything but logical operators 'and'/'or' and comparison
** operators).
** Expression to produce final result will be encoded in 'e1'.
*/
static void finishbinexpval (FuncState *fs, expdesc *e1, expdesc *e2,
                             OpCode op, int v2, int flip, int line,
                             OpCode mmop, TMS event) {
  int v1 = luaK_exp2anyreg(fs, e1);
  int pc = luaK_codeABCk(fs, op, 0, v1, v2, 0);
  freeexps(fs, e1, e2);
  e1->u.info = pc;
  e1->k = VRELOC;  /* all those operations are relocatable */
  luaK_fixline(fs, line);
  luaK_codeABCk(fs, mmop, v1, v2, event, flip);  /* to call metamethod */
  luaK_fixline(fs, line);
}


/*
** Emit code for binary expressions that "produce values" over
** two registers.
*/
static void codebinexpval (FuncState *fs, OpCode op,
                           expdesc *e1, expdesc *e2, int line) {
  int v2 = luaK_exp2anyreg(fs, e2);  /* both operands are in registers */
  lua_assert(OP_ADD <= op && op <= OP_SHR);
  finishbinexpval(fs, e1, e2, op, v2, 0, line, OP_MMBIN,
                  cast(TMS, (op - OP_ADD) + TM_ADD));
}


/*
** Code binary operators with immediate operands.
*/
static void codebini (FuncState *fs, OpCode op,
                       expdesc *e1, expdesc *e2, int flip, int line,
                       TMS event) {
  int v2 = int2sC(cast_int(e2->u.ival));  /* immediate operand */
  lua_assert(e2->k == VKINT);
  finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINI, event);
}


/* Try to code a binary operator negating its second operand.
** For the metamethod, 2nd operand must keep its original value.
*/
static int finishbinexpneg (FuncState *fs, expdesc *e1, expdesc *e2,
                             OpCode op, int line, TMS event) {
  if (!luaK_isKint(e2))
    return 0;  /* not an integer constant */
  else {
    lua_Integer i2 = e2->u.ival;
    if (!(fitsC(i2) && fitsC(-i2)))
      return 0;  /* not in the proper range */
    else {  /* operating a small integer constant */
      int v2 = cast_int(i2);
      finishbinexpval(fs, e1, e2, op, int2sC(-v2), 0, line, OP_MMBINI, event);
      /* correct metamethod argument */
      SETARG_B(fs->f->code[fs->pc - 1], int2sC(v2));
      return 1;  /* successfully coded */
    }
  }
}


static void swapexps (expdesc *e1, expdesc *e2) {
  expdesc temp = *e1; *e1 = *e2; *e2 = temp;  /* swap 'e1' and 'e2' */
}


/*
** Code arithmetic operators ('+', '-', ...). If second operand is a
** constant in the proper range, use variant opcodes with K operands.
*/
static void codearith (FuncState *fs, BinOpr opr,
                       expdesc *e1, expdesc *e2, int flip, int line) {
  TMS event = cast(TMS, opr + TM_ADD);
  if (tonumeral(e2, NULL) && luaK_exp2K(fs, e2)) {  /* K operand? */
    int v2 = e2->u.info;  /* K index */
    OpCode op = cast(OpCode, opr + OP_ADDK);
    finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINK, event);
  }
  else {  /* 'e2' is neither an immediate nor a K operand */
    OpCode op = cast(OpCode, opr + OP_ADD);
    if (flip)
      swapexps(e1, e2);  /* back to original order */
    codebinexpval(fs, op, e1, e2, line);  /* use standard operators */
  }
}


/*
** Code commutative operators ('+', '*'). If first operand is a
** numeric constant, change order of operands to try to use an
** immediate or K operator.
*/
static void codecommutative (FuncState *fs, BinOpr op,
                             expdesc *e1, expdesc *e2, int line) {
  int flip = 0;
  if (tonumeral(e1, NULL)) {  /* is first operand a numeric constant? */
    swapexps(e1, e2);  /* change order */
    flip = 1;
  }
  if (op == OPR_ADD && isSCint(e2))  /* immediate operand? */
    codebini(fs, cast(OpCode, OP_ADDI), e1, e2, flip, line, TM_ADD);
  else
    codearith(fs, op, e1, e2, flip, line);
}


/*
** Code bitwise operations; they are all associative, so the function
** tries to put an integer constant as the 2nd operand (a K operand).
*/
static void codebitwise (FuncState *fs, BinOpr opr,
                         expdesc *e1, expdesc *e2, int line) {
  int flip = 0;
  int v2;
  OpCode op;
  if (e1->k == VKINT && luaK_exp2RK(fs, e1)) {
    swapexps(e1, e2);  /* 'e2' will be the constant operand */
    flip = 1;
  }
  else if (!(e2->k == VKINT && luaK_exp2RK(fs, e2))) {  /* no constants? */
    op = cast(OpCode, opr + OP_ADD);
    codebinexpval(fs, op, e1, e2, line);  /* all-register opcodes */
    return;
  }
  v2 = e2->u.info;  /* index in K array */
  op = cast(OpCode, opr + OP_ADDK);
  lua_assert(ttisinteger(&fs->f->k[v2]));
  finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINK,
                  cast(TMS, opr + TM_ADD));
}


/*
** Emit code for order comparisons. When using an immediate operand,
** 'isfloat' tells whether the original value was a float.
*/
static void codeorder (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
  int r1, r2;
  int im;
  int isfloat = 0;
  if (isSCnumber(e2, &im, &isfloat)) {
    /* use immediate operand */
    r1 = luaK_exp2anyreg(fs, e1);
    r2 = im;
    op = cast(OpCode, (op - OP_LT) + OP_LTI);
  }
  else if (isSCnumber(e1, &im, &isfloat)) {
    /* transform (A < B) to (B > A) and (A <= B) to (B >= A) */
    r1 = luaK_exp2anyreg(fs, e2);
    r2 = im;
    op = (op == OP_LT) ? OP_GTI : OP_GEI;
  }
  else {  /* regular case, compare two registers */
    r1 = luaK_exp2anyreg(fs, e1);
    r2 = luaK_exp2anyreg(fs, e2);
  }
  freeexps(fs, e1, e2);
  e1->u.info = condjump(fs, op, r1, r2, isfloat, 1);
  e1->k = VJMP;
}


/*
** Emit code for equality comparisons ('==', '~=').
** 'e1' was already put as RK by 'luaK_infix'.
*/
static void codeeq (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {
  int r1, r2;
  int im;
  int isfloat = 0;  /* not needed here, but kept for symmetry */
  OpCode op;
  if (e1->k != VNONRELOC) {
    lua_assert(e1->k == VK || e1->k == VKINT || e1->k == VKFLT);
    swapexps(e1, e2);
  }
  r1 = luaK_exp2anyreg(fs, e1);  /* 1st expression must be in register */
  if (isSCnumber(e2, &im, &isfloat)) {
    op = OP_EQI;
    r2 = im;  /* immediate operand */
  }
  else if (luaK_exp2RK(fs, e2)) {  /* 1st expression is constant? */
    op = OP_EQK;
    r2 = e2->u.info;  /* constant index */
  }
  else {
    op = OP_EQ;  /* will compare two registers */
    r2 = luaK_exp2anyreg(fs, e2);
  }
  freeexps(fs, e1, e2);
  e1->u.info = condjump(fs, op, r1, r2, isfloat, (opr == OPR_EQ));
  e1->k = VJMP;
}


/*
** Apply prefix operation 'op' to expression 'e'.
*/
void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
  static const expdesc ef = {VKINT, {0}, NO_JUMP, NO_JUMP};
  luaK_dischargevars(fs, e);
  switch (op) {
    case OPR_MINUS: case OPR_BNOT:  /* use 'ef' as fake 2nd operand */
      if (constfolding(fs, op + LUA_OPUNM, e, &ef))
        break;
      /* else */ /* FALLTHROUGH */
    case OPR_LEN:
      codeunexpval(fs, cast(OpCode, op + OP_UNM), e, line);
      break;
    case OPR_NOT: codenot(fs, e); break;
    default: lua_assert(0);
  }
}


/*
** Process 1st operand 'v' of binary operation 'op' before reading
** 2nd operand.
*/
void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
  luaK_dischargevars(fs, v);
  switch (op) {
    case OPR_AND: {
      luaK_goiftrue(fs, v);  /* go ahead only if 'v' is true */
      break;
    }
    case OPR_OR: {
      luaK_goiffalse(fs, v);  /* go ahead only if 'v' is false */
      break;
    }
    case OPR_CONCAT: {
      luaK_exp2nextreg(fs, v);  /* operand must be on the stack */
      break;
    }
    case OPR_ADD: case OPR_SUB:
    case OPR_MUL: case OPR_DIV: case OPR_IDIV:
    case OPR_MOD: case OPR_POW:
    case OPR_BAND: case OPR_BOR: case OPR_BXOR:
    case OPR_SHL: case OPR_SHR: {
      if (!tonumeral(v, NULL))
        luaK_exp2anyreg(fs, v);
      /* else keep numeral, which may be folded with 2nd operand */
      break;
    }
    case OPR_EQ: case OPR_NE: {
      if (!tonumeral(v, NULL))
        luaK_exp2RK(fs, v);
      /* else keep numeral, which may be an immediate operand */
      break;
    }
    case OPR_LT: case OPR_LE:
    case OPR_GT: case OPR_GE: {
      int dummy, dummy2;
      if (!isSCnumber(v, &dummy, &dummy2))
        luaK_exp2anyreg(fs, v);
      /* else keep numeral, which may be an immediate operand */
      break;
    }
    default: lua_assert(0);
  }
}

/*
** Create code for '(e1 .. e2)'.
** For '(e1 .. e2.1 .. e2.2)' (which is '(e1 .. (e2.1 .. e2.2))',
** because concatenation is right associative), merge both CONCATs.
*/
static void codeconcat (FuncState *fs, expdesc *e1, expdesc *e2, int line) {
  Instruction *ie2 = previousinstruction(fs);
  if (GET_OPCODE(*ie2) == OP_CONCAT) {  /* is 'e2' a concatenation? */
    int n = GETARG_B(*ie2);  /* # of elements concatenated in 'e2' */
    lua_assert(e1->u.info + 1 == GETARG_A(*ie2));
    freeexp(fs, e2);
    SETARG_A(*ie2, e1->u.info);  /* correct first element ('e1') */
    SETARG_B(*ie2, n + 1);  /* will concatenate one more element */
  }
  else {  /* 'e2' is not a concatenation */
    luaK_codeABC(fs, OP_CONCAT, e1->u.info, 2, 0);  /* new concat opcode */
    freeexp(fs, e2);
    luaK_fixline(fs, line);
  }
}


/*
** Finalize code for binary operation, after reading 2nd operand.
*/
void luaK_posfix (FuncState *fs, BinOpr opr,
                  expdesc *e1, expdesc *e2, int line) {
  luaK_dischargevars(fs, e2);
  if (foldbinop(opr) && constfolding(fs, opr + LUA_OPADD, e1, e2))
    return;  /* done by folding */
  switch (opr) {
    case OPR_AND: {
      lua_assert(e1->t == NO_JUMP);  /* list closed by 'luaK_infix' */
      luaK_concat(fs, &e2->f, e1->f);
      *e1 = *e2;
      break;
    }
    case OPR_OR: {
      lua_assert(e1->f == NO_JUMP);  /* list closed by 'luaK_infix' */
      luaK_concat(fs, &e2->t, e1->t);
      *e1 = *e2;
      break;
    }
    case OPR_CONCAT: {  /* e1 .. e2 */
      luaK_exp2nextreg(fs, e2);
      codeconcat(fs, e1, e2, line);
      break;
    }
    case OPR_ADD: case OPR_MUL: {
      codecommutative(fs, opr, e1, e2, line);
      break;
    }
    case OPR_SUB: {
      if (finishbinexpneg(fs, e1, e2, OP_ADDI, line, TM_SUB))
        break; /* coded as (r1 + -I) */
      /* ELSE */
    }  /* FALLTHROUGH */
    case OPR_DIV: case OPR_IDIV: case OPR_MOD: case OPR_POW: {
      codearith(fs, opr, e1, e2, 0, line);
      break;
    }
    case OPR_BAND: case OPR_BOR: case OPR_BXOR: {
      codebitwise(fs, opr, e1, e2, line);
      break;
    }
    case OPR_SHL: {
      if (isSCint(e1)) {
        swapexps(e1, e2);
        codebini(fs, OP_SHLI, e1, e2, 1, line, TM_SHL);  /* I << r2 */
      }
      else if (finishbinexpneg(fs, e1, e2, OP_SHRI, line, TM_SHL)) {
        /* coded as (r1 >> -I) */;
      }
      else  /* regular case (two registers) */
       codebinexpval(fs, OP_SHL, e1, e2, line);
      break;
    }
    case OPR_SHR: {
      if (isSCint(e2))
        codebini(fs, OP_SHRI, e1, e2, 0, line, TM_SHR);  /* r1 >> I */
      else  /* regular case (two registers) */
        codebinexpval(fs, OP_SHR, e1, e2, line);
      break;
    }
    case OPR_EQ: case OPR_NE: {
      codeeq(fs, opr, e1, e2);
      break;
    }
    case OPR_LT: case OPR_LE: {
      OpCode op = cast(OpCode, (opr - OPR_EQ) + OP_EQ);
      codeorder(fs, op, e1, e2);
      break;
    }
    case OPR_GT: case OPR_GE: {
      /* '(a > b)' <=> '(b < a)';  '(a >= b)' <=> '(b <= a)' */
      OpCode op = cast(OpCode, (opr - OPR_NE) + OP_EQ);
      swapexps(e1, e2);
      codeorder(fs, op, e1, e2);
      break;
    }
    default: lua_assert(0);
  }
}


/*
** Change line information associated with current position, by removing
** previous info and adding it again with new line.
*/
void luaK_fixline (FuncState *fs, int line) {
  removelastlineinfo(fs);
  savelineinfo(fs, fs->f, line);
}


void luaK_settablesize (FuncState *fs, int pc, int ra, int asize, int hsize) {
  Instruction *inst = &fs->f->code[pc];
  int rb = (hsize != 0) ? luaO_ceillog2(hsize) + 1 : 0;  /* hash size */
  int extra = asize / (MAXARG_C + 1);  /* higher bits of array size */
  int rc = asize % (MAXARG_C + 1);  /* lower bits of array size */
  int k = (extra > 0);  /* true iff needs extra argument */
  *inst = CREATE_ABCk(OP_NEWTABLE, ra, rb, rc, k);
  *(inst + 1) = CREATE_Ax(OP_EXTRAARG, extra);
}


/*
** Emit a SETLIST instruction.
** 'base' is register that keeps table;
** 'nelems' is #table plus those to be stored now;
** 'tostore' is number of values (in registers 'base + 1',...) to add to
** table (or LUA_MULTRET to add up to stack top).
*/
void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
  lua_assert(tostore != 0 && tostore <= LFIELDS_PER_FLUSH);
  if (tostore == LUA_MULTRET)
    tostore = 0;
  if (nelems <= MAXARG_C)
    luaK_codeABC(fs, OP_SETLIST, base, tostore, nelems);
  else {
    int extra = nelems / (MAXARG_C + 1);
    nelems %= (MAXARG_C + 1);
    luaK_codeABCk(fs, OP_SETLIST, base, tostore, nelems, 1);
    codeextraarg(fs, extra);
  }
  fs->freereg = base + 1;  /* free registers with list values */
}


/*
** return the final target of a jump (skipping jumps to jumps)
*/
static int finaltarget (Instruction *code, int i) {
  int count;
  for (count = 0; count < 100; count++) {  /* avoid infinite loops */
    Instruction pc = code[i];
    if (GET_OPCODE(pc) != OP_JMP)
      break;
     else
       i += GETARG_sJ(pc) + 1;
  }
  return i;
}


/*
** Do a final pass over the code of a function, doing small peephole
** optimizations and adjustments.
*/
void luaK_finish (FuncState *fs) {
  int i;
  Proto *p = fs->f;
  for (i = 0; i < fs->pc; i++) {
    Instruction *pc = &p->code[i];
    lua_assert(i == 0 || isOT(*(pc - 1)) == isIT(*pc));
    switch (GET_OPCODE(*pc)) {
      case OP_RETURN0: case OP_RETURN1: {
        if (!(fs->needclose || p->is_vararg))
          break;  /* no extra work */
        /* else use OP_RETURN to do the extra work */
        SET_OPCODE(*pc, OP_RETURN);
      }  /* FALLTHROUGH */
      case OP_RETURN: case OP_TAILCALL: {
        if (fs->needclose)
          SETARG_k(*pc, 1);  /* signal that it needs to close */
        if (p->is_vararg)
          SETARG_C(*pc, p->numparams + 1);  /* signal that it is vararg */
        break;
      }
      case OP_JMP: {
        int target = finaltarget(p->code, i);
        fixjump(fs, i, target);
        break;
      }
      default: break;
    }
  }
}
#include <stdio.h>
/*
** $Id: ldebug.c $
** Debug Interface
** See Copyright Notice in lua.h
*/

#define ldebug_c
#define LUA_CORE

#include "lprefix.h"


#include <stdarg.h>
#include <stddef.h>
#include <string.h>

#include "lua.h"

#include "lapi.h"
#include "lcode.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"
#include "lvm.h"



#define noLuaClosure(f)		((f) == NULL || (f)->c.tt == LUA_VCCL)


static const char *funcnamefromcode (lua_State *L, CallInfo *ci,
                                    const char **name);


static int currentpc (CallInfo *ci) {
  lua_assert(isLua(ci));
  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);
}


/*
** Get a "base line" to find the line corresponding to an instruction.
** Base lines are regularly placed at MAXIWTHABS intervals, so usually
** an integer division gets the right place. When the source file has
** large sequences of empty/comment lines, it may need extra entries,
** so the original estimate needs a correction.
** If the original estimate is -1, the initial 'if' ensures that the
** 'while' will run at least once.
** The assertion that the estimate is a lower bound for the correct base
** is valid as long as the debug info has been generated with the same
** value for MAXIWTHABS or smaller. (Previous releases use a little
** smaller value.)
*/
static int getbaseline (const Proto *f, int pc, int *basepc) {
  if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {
    *basepc = -1;  /* start from the beginning */
    return f->linedefined;
  }
  else {
    int i = cast_uint(pc) / MAXIWTHABS - 1;  /* get an estimate */
    /* estimate must be a lower bond of the correct base */
    lua_assert(i < 0 ||
              (i < f->sizeabslineinfo && f->abslineinfo[i].pc <= pc));
    while (i + 1 < f->sizeabslineinfo && pc >= f->abslineinfo[i + 1].pc)
      i++;  /* low estimate; adjust it */
    *basepc = f->abslineinfo[i].pc;
    return f->abslineinfo[i].line;
  }
}


/*
** Get the line corresponding to instruction 'pc' in function 'f';
** first gets a base line and from there does the increments until
** the desired instruction.
*/
int luaG_getfuncline (const Proto *f, int pc) {
  if (f->lineinfo == NULL)  /* no debug information? */
    return -1;
  else {
    int basepc;
    int baseline = getbaseline(f, pc, &basepc);
    while (basepc++ < pc) {  /* walk until given instruction */
      lua_assert(f->lineinfo[basepc] != ABSLINEINFO);
      baseline += f->lineinfo[basepc];  /* correct line */
    }
    return baseline;
  }
}


static int getcurrentline (CallInfo *ci) {
  return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));
}


/*
** Set 'trap' for all active Lua frames.
** This function can be called during a signal, under "reasonable"
** assumptions. A new 'ci' is completely linked in the list before it
** becomes part of the "active" list, and we assume that pointers are
** atomic; see comment in next function.
** (A compiler doing interprocedural optimizations could, theoretically,
** reorder memory writes in such a way that the list could be
** temporarily broken while inserting a new element. We simply assume it
** has no good reasons to do that.)
*/
static void settraps (CallInfo *ci) {
  for (; ci != NULL; ci = ci->previous)
    if (isLua(ci))
      ci->u.l.trap = 1;
}


/*
** This function can be called during a signal, under "reasonable"
** assumptions.
** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')
** are for debug only, and it is no problem if they get arbitrary
** values (causes at most one wrong hook call). 'hookmask' is an atomic
** value. We assume that pointers are atomic too (e.g., gcc ensures that
** for all platforms where it runs). Moreover, 'hook' is always checked
** before being called (see 'luaD_hook').
*/
LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
  if (func == NULL || mask == 0) {  /* turn off hooks? */
    mask = 0;
    func = NULL;
  }
  L->hook = func;
  L->basehookcount = count;
  resethookcount(L);
  L->hookmask = cast_byte(mask);
  if (mask)
    settraps(L->ci);  /* to trace inside 'luaV_execute' */
}


LUA_API lua_Hook lua_gethook (lua_State *L) {
  return L->hook;
}


LUA_API int lua_gethookmask (lua_State *L) {
  return L->hookmask;
}


LUA_API int lua_gethookcount (lua_State *L) {
  return L->basehookcount;
}


LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
  int status;
  CallInfo *ci;
  if (level < 0) return 0;  /* invalid (negative) level */
  lua_lock(L);
  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
    level--;
  if (level == 0 && ci != &L->base_ci) {  /* level found? */
    status = 1;
    ar->i_ci = ci;
  }
  else status = 0;  /* no such level */
  lua_unlock(L);
  return status;
}


static const char *upvalname (const Proto *p, int uv) {
  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);
  if (s == NULL) return "?";
  else return getstr(s);
}


static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
  if (clLvalue(s2v(ci->func))->p->is_vararg) {
    int nextra = ci->u.l.nextraargs;
    if (n >= -nextra) {  /* 'n' is negative */
      *pos = ci->func - nextra - (n + 1);
      return "(vararg)";  /* generic name for any vararg */
    }
  }
  return NULL;  /* no such vararg */
}


const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {
  StkId base = ci->func + 1;
  const char *name = NULL;
  if (isLua(ci)) {
    if (n < 0)  /* access to vararg values? */
      return findvararg(ci, n, pos);
    else
      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
  }
  if (name == NULL) {  /* no 'standard' name? */
    StkId limit = (ci == L->ci) ? L->top : ci->next->func;
    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */
      /* generic name for any valid slot */
      name = isLua(ci) ? "(temporary)" : "(C temporary)";
    }
    else
      return NULL;  /* no name */
  }
  if (pos)
    *pos = base + (n - 1);
  return name;
}


LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
  const char *name;
  lua_lock(L);
  if (ar == NULL) {  /* information about non-active function? */
    if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */
      name = NULL;
    else  /* consider live variables at function start (parameters) */
      name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);
  }
  else {  /* active function; get information through 'ar' */
    StkId pos = NULL;  /* to avoid warnings */
    name = luaG_findlocal(L, ar->i_ci, n, &pos);
    if (name) {
      setobjs2s(L, L->top, pos);
      api_incr_top(L);
    }
  }
  lua_unlock(L);
  return name;
}


LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
  StkId pos = NULL;  /* to avoid warnings */
  const char *name;
  lua_lock(L);
  name = luaG_findlocal(L, ar->i_ci, n, &pos);
  if (name) {
    setobjs2s(L, pos, L->top - 1);
    L->top--;  /* pop value */
  }
  lua_unlock(L);
  return name;
}


static void funcinfo (lua_Debug *ar, Closure *cl) {
  if (noLuaClosure(cl)) {
    ar->source = "=[C]";
    ar->srclen = LL("=[C]");
    ar->linedefined = -1;
    ar->lastlinedefined = -1;
    ar->what = "C";
  }
  else {
    const Proto *p = cl->l.p;
    if (p->source) {
      ar->source = getstr(p->source);
      ar->srclen = tsslen(p->source);
    }
    else {
      ar->source = "=?";
      ar->srclen = LL("=?");
    }
    ar->linedefined = p->linedefined;
    ar->lastlinedefined = p->lastlinedefined;
    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
  }
  luaO_chunkid(ar->short_src, ar->source, ar->srclen);
}


static int nextline (const Proto *p, int currentline, int pc) {
  if (p->lineinfo[pc] != ABSLINEINFO)
    return currentline + p->lineinfo[pc];
  else
    return luaG_getfuncline(p, pc);
}


static void collectvalidlines (lua_State *L, Closure *f) {
  if (noLuaClosure(f)) {
    setnilvalue(s2v(L->top));
    api_incr_top(L);
  }
  else {
    int i;
    TValue v;
    const Proto *p = f->l.p;
    int currentline = p->linedefined;
    Table *t = luaH_new(L);  /* new table to store active lines */
    sethvalue2s(L, L->top, t);  /* push it on stack */
    api_incr_top(L);
    setbtvalue(&v);  /* boolean 'true' to be the value of all indices */
    for (i = 0; i < p->sizelineinfo; i++) {  /* for all instructions */
      currentline = nextline(p, currentline, i);  /* get its line */
      luaH_setint(L, t, currentline, &v);  /* table[line] = true */
    }
  }
}


static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
  if (ci == NULL)  /* no 'ci'? */
    return NULL;  /* no info */
  else if (ci->callstatus & CIST_FIN) {  /* is this a finalizer? */
    *name = "__gc";
    return "metamethod";  /* report it as such */
  }
  /* calling function is a known Lua function? */
  else if (!(ci->callstatus & CIST_TAIL) && isLua(ci->previous))
    return funcnamefromcode(L, ci->previous, name);
  else return NULL;  /* no way to find a name */
}


static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
                       Closure *f, CallInfo *ci) {
  int status = 1;
  for (; *what; what++) {
    switch (*what) {
      case 'S': {
        funcinfo(ar, f);
        break;
      }
      case 'l': {
        ar->currentline = (ci && isLua(ci)) ? getcurrentline(ci) : -1;
        break;
      }
      case 'u': {
        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;
        if (noLuaClosure(f)) {
          ar->isvararg = 1;
          ar->nparams = 0;
        }
        else {
          ar->isvararg = f->l.p->is_vararg;
          ar->nparams = f->l.p->numparams;
        }
        break;
      }
      case 't': {
        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;
        break;
      }
      case 'n': {
        ar->namewhat = getfuncname(L, ci, &ar->name);
        if (ar->namewhat == NULL) {
          ar->namewhat = "";  /* not found */
          ar->name = NULL;
        }
        break;
      }
      case 'r': {
        if (ci == NULL || !(ci->callstatus & CIST_TRAN))
          ar->ftransfer = ar->ntransfer = 0;
        else {
          ar->ftransfer = ci->u2.transferinfo.ftransfer;
          ar->ntransfer = ci->u2.transferinfo.ntransfer;
        }
        break;
      }
      case 'L':
      case 'f':  /* handled by lua_getinfo */
        break;
      default: status = 0;  /* invalid option */
    }
  }
  return status;
}


LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
  int status;
  Closure *cl;
  CallInfo *ci;
  TValue *func;
  lua_lock(L);
  if (*what == '>') {
    ci = NULL;
    func = s2v(L->top - 1);
    api_check(L, ttisfunction(func), "function expected");
    what++;  /* skip the '>' */
    L->top--;  /* pop function */
  }
  else {
    ci = ar->i_ci;
    func = s2v(ci->func);
    lua_assert(ttisfunction(func));
  }
  cl = ttisclosure(func) ? clvalue(func) : NULL;
  status = auxgetinfo(L, what, ar, cl, ci);
  if (strchr(what, 'f')) {
    setobj2s(L, L->top, func);
    api_incr_top(L);
  }
  if (strchr(what, 'L'))
    collectvalidlines(L, cl);
  lua_unlock(L);
  return status;
}


/*
** {======================================================
** Symbolic Execution
** =======================================================
*/

static const char *getobjname (const Proto *p, int lastpc, int reg,
                               const char **name);


/*
** Find a "name" for the constant 'c'.
*/
static void kname (const Proto *p, int c, const char **name) {
  TValue *kvalue = &p->k[c];
  *name = (ttisstring(kvalue)) ? svalue(kvalue) : "?";
}


/*
** Find a "name" for the register 'c'.
*/
static void rname (const Proto *p, int pc, int c, const char **name) {
  const char *what = getobjname(p, pc, c, name); /* search for 'c' */
  if (!(what && *what == 'c'))  /* did not find a constant name? */
    *name = "?";
}


/*
** Find a "name" for a 'C' value in an RK instruction.
*/
static void rkname (const Proto *p, int pc, Instruction i, const char **name) {
  int c = GETARG_C(i);  /* key index */
  if (GETARG_k(i))  /* is 'c' a constant? */
    kname(p, c, name);
  else  /* 'c' is a register */
    rname(p, pc, c, name);
}


static int filterpc (int pc, int jmptarget) {
  if (pc < jmptarget)  /* is code conditional (inside a jump)? */
    return -1;  /* cannot know who sets that register */
  else return pc;  /* current position sets that register */
}


/*
** Try to find last instruction before 'lastpc' that modified register 'reg'.
*/
static int findsetreg (const Proto *p, int lastpc, int reg) {
  int pc;
  int setreg = -1;  /* keep last instruction that changed 'reg' */
  int jmptarget = 0;  /* any code before this address is conditional */
  if (testMMMode(GET_OPCODE(p->code[lastpc])))
    lastpc--;  /* previous instruction was not actually executed */
  for (pc = 0; pc < lastpc; pc++) {
    Instruction i = p->code[pc];
    OpCode op = GET_OPCODE(i);
    int a = GETARG_A(i);
    int change;  /* true if current instruction changed 'reg' */
    switch (op) {
      case OP_LOADNIL: {  /* set registers from 'a' to 'a+b' */
        int b = GETARG_B(i);
        change = (a <= reg && reg <= a + b);
        break;
      }
      case OP_TFORCALL: {  /* affect all regs above its base */
        change = (reg >= a + 2);
        break;
      }
      case OP_CALL:
      case OP_TAILCALL: {  /* affect all registers above base */
        change = (reg >= a);
        break;
      }
      case OP_JMP: {  /* doesn't change registers, but changes 'jmptarget' */
        int b = GETARG_sJ(i);
        int dest = pc + 1 + b;
        /* jump does not skip 'lastpc' and is larger than current one? */
        if (dest <= lastpc && dest > jmptarget)
          jmptarget = dest;  /* update 'jmptarget' */
        change = 0;
        break;
      }
      default:  /* any instruction that sets A */
        change = (testAMode(op) && reg == a);
        break;
    }
    if (change)
      setreg = filterpc(pc, jmptarget);
  }
  return setreg;
}


/*
** Check whether table being indexed by instruction 'i' is the
** environment '_ENV'
*/
static const char *gxf (const Proto *p, int pc, Instruction i, int isup) {
  int t = GETARG_B(i);  /* table index */
  const char *name;  /* name of indexed variable */
  if (isup)  /* is an upvalue? */
    name = upvalname(p, t);
  else
    getobjname(p, pc, t, &name);
  return (name && strcmp(name, LUA_ENV) == 0) ? "global" : "field";
}


static const char *getobjname (const Proto *p, int lastpc, int reg,
                               const char **name) {
  int pc;
  *name = luaF_getlocalname(p, reg + 1, lastpc);
  if (*name)  /* is a local? */
    return "local";
  /* else try symbolic execution */
  pc = findsetreg(p, lastpc, reg);
  if (pc != -1) {  /* could find instruction? */
    Instruction i = p->code[pc];
    OpCode op = GET_OPCODE(i);
    switch (op) {
      case OP_MOVE: {
        int b = GETARG_B(i);  /* move from 'b' to 'a' */
        if (b < GETARG_A(i))
          return getobjname(p, pc, b, name);  /* get name for 'b' */
        break;
      }
      case OP_GETTABUP: {
        int k = GETARG_C(i);  /* key index */
        kname(p, k, name);
        return gxf(p, pc, i, 1);
      }
      case OP_GETTABLE: {
        int k = GETARG_C(i);  /* key index */
        rname(p, pc, k, name);
        return gxf(p, pc, i, 0);
      }
      case OP_GETI: {
        *name = "integer index";
        return "field";
      }
      case OP_GETFIELD: {
        int k = GETARG_C(i);  /* key index */
        kname(p, k, name);
        return gxf(p, pc, i, 0);
      }
      case OP_GETUPVAL: {
        *name = upvalname(p, GETARG_B(i));
        return "upvalue";
      }
      case OP_LOADK:
      case OP_LOADKX: {
        int b = (op == OP_LOADK) ? GETARG_Bx(i)
                                 : GETARG_Ax(p->code[pc + 1]);
        if (ttisstring(&p->k[b])) {
          *name = svalue(&p->k[b]);
          return "constant";
        }
        break;
      }
      case OP_SELF: {
        rkname(p, pc, i, name);
        return "method";
      }
      default: break;  /* go through to return NULL */
    }
  }
  return NULL;  /* could not find reasonable name */
}


/*
** Try to find a name for a function based on the code that called it.
** (Only works when function was called by a Lua function.)
** Returns what the name is (e.g., "for iterator", "method",
** "metamethod") and sets '*name' to point to the name.
*/
static const char *funcnamefromcode (lua_State *L, CallInfo *ci,
                                     const char **name) {
  TMS tm = (TMS)0;  /* (initial value avoids warnings) */
  const Proto *p = ci_func(ci)->p;  /* calling function */
  int pc = currentpc(ci);  /* calling instruction index */
  Instruction i = p->code[pc];  /* calling instruction */
  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */
    *name = "?";
    return "hook";
  }
  switch (GET_OPCODE(i)) {
    case OP_CALL:
    case OP_TAILCALL:
      return getobjname(p, pc, GETARG_A(i), name);  /* get function name */
    case OP_TFORCALL: {  /* for iterator */
      *name = "for iterator";
       return "for iterator";
    }
    /* other instructions can do calls through metamethods */
    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:
    case OP_GETI: case OP_GETFIELD:
      tm = TM_INDEX;
      break;
    case OP_SETTABUP: case OP_SETTABLE: case OP_SETI: case OP_SETFIELD:
      tm = TM_NEWINDEX;
      break;
    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {
      tm = cast(TMS, GETARG_C(i));
      break;
    }
    case OP_UNM: tm = TM_UNM; break;
    case OP_BNOT: tm = TM_BNOT; break;
    case OP_LEN: tm = TM_LEN; break;
    case OP_CONCAT: tm = TM_CONCAT; break;
    case OP_EQ: tm = TM_EQ; break;
    /* no cases for OP_EQI and OP_EQK, as they don't call metamethods */
    case OP_LT: case OP_LTI: case OP_GTI: tm = TM_LT; break;
    case OP_LE: case OP_LEI: case OP_GEI: tm = TM_LE; break;
    case OP_CLOSE: case OP_RETURN: tm = TM_CLOSE; break;
    default:
      return NULL;  /* cannot find a reasonable name */
  }
  *name = getstr(G(L)->tmname[tm]) + 2;
  return "metamethod";
}

/* }====================================================== */



/*
** Check whether pointer 'o' points to some value in the stack
** frame of the current function. Because 'o' may not point to a
** value in this stack, we cannot compare it with the region
** boundaries (undefined behaviour in ISO C).
*/
static int isinstack (CallInfo *ci, const TValue *o) {
  StkId pos;
  for (pos = ci->func + 1; pos < ci->top; pos++) {
    if (o == s2v(pos))
      return 1;
  }
  return 0;  /* not found */
}


/*
** Checks whether value 'o' came from an upvalue. (That can only happen
** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on
** upvalues.)
*/
static const char *getupvalname (CallInfo *ci, const TValue *o,
                                 const char **name) {
  LClosure *c = ci_func(ci);
  int i;
  for (i = 0; i < c->nupvalues; i++) {
    if (c->upvals[i]->v == o) {
      *name = upvalname(c->p, i);
      return "upvalue";
    }
  }
  return NULL;
}


static const char *varinfo (lua_State *L, const TValue *o) {
  const char *name = NULL;  /* to avoid warnings */
  CallInfo *ci = L->ci;
  const char *kind = NULL;
  if (isLua(ci)) {
    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */
    if (!kind && isinstack(ci, o))  /* no? try a register */
      kind = getobjname(ci_func(ci)->p, currentpc(ci),
                        cast_int(cast(StkId, o) - (ci->func + 1)), &name);
  }
  return (kind) ? luaO_pushfstring(L, " (%s '%s')", kind, name) : "";
}


l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
  const char *t = luaT_objtypename(L, o);
  luaG_runerror(L, "attempt to %s a %s value%s", op, t, varinfo(L, o));
}


l_noret luaG_callerror (lua_State *L, const TValue *o) {
  CallInfo *ci = L->ci;
  const char *name = NULL;  /* to avoid warnings */
  const char *what = (isLua(ci)) ? funcnamefromcode(L, ci, &name) : NULL;
  if (what != NULL) {
    const char *t = luaT_objtypename(L, o);
    luaG_runerror(L, "%s '%s' is not callable (a %s value)", what, name, t);
  }
  else
    luaG_typeerror(L, o, "call");
}


l_noret luaG_forerror (lua_State *L, const TValue *o, const char *what) {
  luaG_runerror(L, "bad 'for' %s (number expected, got %s)",
                   what, luaT_objtypename(L, o));
}


l_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {
  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;
  luaG_typeerror(L, p1, "concatenate");
}


l_noret luaG_opinterror (lua_State *L, const TValue *p1,
                         const TValue *p2, const char *msg) {
  if (!ttisnumber(p1))  /* first operand is wrong? */
    p2 = p1;  /* now second is wrong */
  luaG_typeerror(L, p2, msg);
}


/*
** Error when both values are convertible to numbers, but not to integers
*/
l_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {
  lua_Integer temp;
  if (!luaV_tointegerns(p1, &temp, LUA_FLOORN2I))
    p2 = p1;
  luaG_runerror(L, "number%s has no integer representation", varinfo(L, p2));
}


l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
  const char *t1 = luaT_objtypename(L, p1);
  const char *t2 = luaT_objtypename(L, p2);
  if (strcmp(t1, t2) == 0)
    luaG_runerror(L, "attempt to compare two %s values", t1);
  else
    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
}


/* add src:line information to 'msg' */
const char *luaG_addinfo (lua_State *L, const char *msg, TString *src,
                                        int line) {
  char buff[LUA_IDSIZE];
  if (src)
    luaO_chunkid(buff, getstr(src), tsslen(src));
  else {  /* no source available; use "?" instead */
    buff[0] = '?'; buff[1] = '\0';
  }
  return luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
}


l_noret luaG_errormsg (lua_State *L) {
  if (L->errfunc != 0) {  /* is there an error handling function? */
    StkId errfunc = restorestack(L, L->errfunc);
    lua_assert(ttisfunction(s2v(errfunc)));
    setobjs2s(L, L->top, L->top - 1);  /* move argument */
    setobjs2s(L, L->top - 1, errfunc);  /* push function */
    L->top++;  /* assume EXTRA_STACK */
    luaD_callnoyield(L, L->top - 2, 1);  /* call it */
  }
  luaD_throw(L, LUA_ERRRUN);
}


l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
  CallInfo *ci = L->ci;
  const char *msg;
  va_list argp;
  luaC_checkGC(L);  /* error message uses memory */
  va_start(argp, fmt);
  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */
  va_end(argp);
  if (isLua(ci))  /* if Lua function, add source:line information */
    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));
  luaG_errormsg(L);
}


/*
** Check whether new instruction 'newpc' is in a different line from
** previous instruction 'oldpc'. More often than not, 'newpc' is only
** one or a few instructions after 'oldpc' (it must be after, see
** caller), so try to avoid calling 'luaG_getfuncline'. If they are
** too far apart, there is a good chance of a ABSLINEINFO in the way,
** so it goes directly to 'luaG_getfuncline'.
*/
static int changedline (const Proto *p, int oldpc, int newpc) {
  if (p->lineinfo == NULL)  /* no debug information? */
    return 0;
  if (newpc - oldpc < MAXIWTHABS / 2) {  /* not too far apart? */
    int delta = 0;  /* line diference */
    int pc = oldpc;
    for (;;) {
      int lineinfo = p->lineinfo[++pc];
      if (lineinfo == ABSLINEINFO)
        break;  /* cannot compute delta; fall through */
      delta += lineinfo;
      if (pc == newpc)
        return (delta != 0);  /* delta computed successfully */
    }
  }
  /* either instructions are too far apart or there is an absolute line
     info in the way; compute line difference explicitly */
  return (luaG_getfuncline(p, oldpc) != luaG_getfuncline(p, newpc));
}


int luaG_traceexec (lua_State *L, const Instruction *pc) {
  CallInfo *ci = L->ci;
  lu_byte mask = L->hookmask;
  const Proto *p = ci_func(ci)->p;
  int counthook;
  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */
    ci->u.l.trap = 0;  /* don't need to stop again */
    return 0;  /* turn off 'trap' */
  }
  pc++;  /* reference is always next instruction */
  ci->u.l.savedpc = pc;  /* save 'pc' */
  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));
  if (counthook)
    resethookcount(L);  /* reset count */
  else if (!(mask & LUA_MASKLINE))
    return 1;  /* no line hook and count != 0; nothing to be done now */
  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
    return 1;  /* do not call hook again (VM yielded, so it did not move) */
  }
  if (!isIT(*(ci->u.l.savedpc - 1)))  /* top not being used? */
    L->top = ci->top;  /* correct top */
  if (counthook)
    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */
  if (mask & LUA_MASKLINE) {
    /* 'L->oldpc' may be invalid; use zero in this case */
    int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;
    int npci = pcRel(pc, p);
    if (npci <= oldpc ||  /* call hook when jump back (loop), */
        changedline(p, oldpc, npci)) {  /* or when enter new line */
      int newline = luaG_getfuncline(p, npci);
      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */
    }
    L->oldpc = npci;  /* 'pc' of last call to line hook */
  }
  if (L->status == LUA_YIELD) {  /* did hook yield? */
    if (counthook)
      L->hookcount = 1;  /* undo decrement to zero */
    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */
    luaD_throw(L, LUA_YIELD);
  }
  return 1;  /* keep 'trap' on */
}

#include "include/prototypes_LJC2.h"

/*Reserves memory for active list with size [CAListSize] With the typedef of ActiveList. */
ActiveList *ACTIVELIST_INIT(
unsigned int CAListSize)
{
	ActiveList *m = NULL;
	
	/*Allocate active list*/
	m = (ActiveList*) GC_MALLOC( (size_t)(CAListSize) * sizeof(ActiveList) );
	if (m == NULL) 
	{
		fprintf(stderr, "[ACTIVELIST_INIT]\n");
		fprintf(stderr, "   NO MORE MEMORY: Tried to allocate memory Active Lists!! Program stopped!\n");
		return NULL;
	}
	return (m);
}

/*Reserves memory for matrix of size [rows]x[cols] With the typedef of DataCell.*/
DataCell **GLOBALDATA_INIT(
int rows, 
int cols)
{
	int i;
	DataCell **m = NULL;
	
	/*Allocate row pointers*/
	if((m = (DataCell**) GC_MALLOC((size_t)(rows) * sizeof(DataCell*) )) == NULL)
	{
		fprintf(stderr, "[GLOBALDATA_INIT]\n");
		fprintf(stderr, "   NO MORE MEMORY: Tried to allocate memory for %d Rows!! Program stopped!\n", rows);
		return NULL;
	}
	/*allocate cols & set previously allocated row pointers to point to these*/
	for (i = 0; i < rows; i++) 
	{
		if((m[i] = (DataCell*) GC_MALLOC((size_t)(cols) * sizeof(DataCell) )) == NULL)
		{
			fprintf(stderr, "[GLOBALDATA_INIT]\n");
			fprintf(stderr, "   NO MORE MEMORY: Tried to allocate memory for %d cols in %d rows!! Program stopped!", cols,rows);
			return NULL;
		}
	}
	return m; /*return array */
}

#include "include/prototypes_LJC2.h"

int CHECK_VENT_LOCATION(
Vent *vent, 
double *gridInfo,
DataCell **grid)
{
	int i=1, ventRow, ventCol;
	
  
	if((ventRow = (int) ( ( vent->northing - gridInfo[3]) / gridInfo[5]) ) <= 0) 
	{
		fprintf(stderr, "[CHECK_VENT]: Vent not within region covered by DEM! (SOUTH of region)\n");
		fprintf(stderr, " Vent #%d at cell: [%d][%d].\n",
							(i), ventRow, (int) (( vent->easting - gridInfo[0]) / gridInfo[1]) );
		return 1;
	}
	else if (ventRow >= gridInfo[4]) 
	{
		fprintf(stderr, "[CHECK_VENT]: Vent not within region covered by DEM! (NORTH of region)\n");
		fprintf(stderr, " Vent #%d at cell: [%d][%d].\n",
							(i), ventRow, (int) (( vent->easting - gridInfo[0]) / gridInfo[1]) );
		return 1;
	}
	else if((ventCol = (int) ((vent->easting - gridInfo[0]) / gridInfo[1]) ) <= 0) 
	{
		fprintf(stderr, "[CHECK_VENT]: Vent not within region covered by DEM! (WEST of region)\n");
		fprintf(stderr, " Vent #%d at cell: [%d][%d].\n",
							(i), ventRow, ventCol);
		return 1;
	}
	else if(ventCol >= gridInfo[2]) 
	{
		fprintf(stderr, "[CHECK_VENT]: Vent not within region covered by DEM! (EAST of region)\n");
		fprintf(stderr, " Vent #%d at cell: [%d][%d].\n",
							(i), ventRow, ventCol);
		return 1;
	}
	else if ( grid[ventRow][ventCol].dem_elev < 0)
	{
		fprintf(stderr, "[CHECK_VENT]: Vent below sea-level, but continuing.\n");
		fprintf(stderr, " Vent #%d at cell: [%d][%d].\n",
							(i), ventRow, ventCol);
}
	
	return 0;
}
/*############################################################################
# MOLASSES (MOdular LAva Simulation Software for the Earth Sciences) 
# The MOLASSES model relies on a cellular automata algorithm to 
# estimate the area inundated by lava flows.
#
#    Copyright (C) 2015-2021  
#    Laura Connor (lconnor@usf.edu)
#    Jacob Richardson 
#    Charles Connor
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
###########################################################################*/ 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include "include/prototypes_LJC2.h"

#define CR 13            /* Decimal code of Carriage Return char */
#define LF 10            /* Decimal code of Line Feed char */

/* PERL version: 
sub choose_new_vent {
    
  my $spatial_density = $_[0];
  my $num_vents = $_[1];
  my $sd_spacing = $_[2];
  my @lambda;
  my $sum;
  my $random;
  my $sum_lambda = 0;
  
  open(SP_DENSITY, "+<$spatial_density") or die ("cannot open $spatial_density: $!");
	my  @lines = <SP_DENSITY>;
  close SP_DENSITY;
  
  # Sum data values over area of interest
  for my $i (0..$#lines) {
    (my $east, my $north, my $data) = split(" ", $lines[$i]);
    $sum_lambda += $data;
    $lambda[$i]{east} = $east;
    $lambda[$i]{north} = $north;
    $lambda[$i]{data} = $data;
  }
  
  printf STDERR "spatial density sums to: %g\n", $sum_lambda;
  my $half = $sd_spacing/2;
  my $new_east; my $new_north;
  for (my $vent = 0; $vent < $num_vents; $vent++) {
    # Choose a random number between 0 and calculated sum of data values
    $random = random_uniform(1,0,$sum_lambda);
  
    $sum = 0;
    my $i = 0;
    #printf "Random Value chosen: %g\n",$random;
    # Select grid for new vent based on the random value
    while ($sum < $random) {
      $sum += $lambda[$i]{data};
      $i++;
    }
    # Choose random and northing and easting for new vent within chosen grid cell
    my $left = $lambda[$i]{east} - $half;
    my $right = $lambda[$i]{east} + $half;
    $new_east = random_uniform_integer(1,$left,$right);
    
    my $top = $lambda[$i]{north} + $half;
    my $bot = $lambda[$i]{north} - $half;
    $new_north = random_uniform_integer(1,$bot,$top);
    #printf STDERR "%.1f  %.1f\n",  $new_east, $new_north;
  }
  return $new_east, $new_north;
}

*/

int CHOOSE_NEW_VENT(
Inputs *In, 
Vent *vent,
SpatialDensity *grid) 
{
	double sum_lambda = 0, sum = 0, half, random, left, right, top, bot, new_east, new_north;
	int ct, i, num_grids, grid_spacing;
	/* SpatialDensity *grid = vent->spd_grd; */
	
	num_grids = In->num_grids;
	grid_spacing = In->spd_grid_spacing;
	
	/*Sum data values over area of interest*/
	for (ct = 0; ct < num_grids; ct++) 
	{
		sum_lambda += (grid+ct)->prob;
	}
#ifdef PRINT 
	fprintf (stderr, "spatial density sums to: %0.2g\n", sum_lambda);
#endif
	half = (double)grid_spacing/2.0;
	/* Choose a random number between 0 and calculated sum of data values */
	random = (double) genunf ( (float) 0, (float) sum_lambda ); /*random_uniform(1,0,$sum_lambda); */
	sum = 0;
	i = 0;
#ifdef PRINT 
	fprintf (stderr, "Random Value chosen: %g\n",random); */
#endif
	/* Select grid value for new vent based on the random value */
	while (sum < random) 
	{
		sum += (grid + i++)->prob;
	}
	 /* Choose random and northing and easting for new vent within chosen grid cell */
	left = (double)(grid + i)->easting - half;
	right = (double)(grid + i)->easting + half;
	new_east = (double) ignuin ( (int) left, (int) right ); /*random_uniform_integer(1,$left,$right); */
	top = (grid + i)->northing + half;
	bot = (grid + i)->northing - half;
	new_north = (double) ignuin ( (int) bot, (int) top); /* random_uniform_integer(1,$bot,$top) */
#ifdef PRINT 
	fprintf (stderr, "%f  %f ",  new_east, new_north);
#endif
	vent->easting = new_east;
	vent->northing = new_north;
#ifdef PRINT 
	fprintf (stderr, " New Vent [%0.0f  %0.0f]\n",  vent->easting, vent->northing);
#endif
	return 0;
}

/************************************
returns number of rows in file
************************************/
int count_rows(
char file[], 
long len) 
{
	int NumRows = 0;
	long totc = 0L;
	char * fp;

	fp = file;
	while (totc < len) 
	{ 
		while (*fp != LF && *fp != CR) 
		{   
			fp++;
			totc++;
		}    
		while (*fp == CR || *fp == LF) 
		{  
			totc++; 
			fp++;
		}
		NumRows++; 
	}
	return NumRows;    
}

/**************************************
reads spatial density values from file
and loads array structure (grid)
**************************************/
int load_spd_data(
FILE *Opener, 
Lava_flow *active_flow, 
int *ct) 
{
	long len, __attribute__((__unused__)) num;
	char *lines, *fp;
	int Nrows;
	long totc = 0L;
	long ind = 0L;
	char *here, *one_line;
	
	fseek(Opener, 0L, SEEK_END);  /* Position to end of file */
	len = ftell(Opener);          /* Get file length */
	rewind(Opener);               /* Back to start of file */
	lines = (char *)GC_MALLOC((size_t)((len + 1) * sizeof(char)));
	if (lines == NULL ) 
	{
		fprintf(stderr, 
					"\n[load_spd_data]: Insufficient memory to read spatial density filefile: %s (%u)\n", 
					strerror(errno), errno);
		return 1;
	}
	num = fread(lines, len, 1, Opener); /* Read the entire file into array */
	lines[len] = '\0';
	Nrows = count_rows(lines, len);
#ifdef PRINT 
	fprintf(stderr, "\nReading %ld file with %ld bytes and %d rows ", num, len, Nrows);
#endif
	active_flow->spd_grd = (SpatialDensity *)GC_MALLOC(( (size_t)Nrows * sizeof(SpatialDensity)));
	if (active_flow->spd_grd == NULL) 
	{
		fprintf(stderr, 
					"\n[load_spd_data]: Cannot malloc memory for spatial densty grid:[%s] (%u)\n", 
					strerror(errno), errno);
	return 1;
	}
	fp = lines;
	*ct = 0;
	while (totc < len) 
	{
		ind = 0L;          
		here = fp; 
		while (*fp != LF && *fp != CR) 
		{   
			fp++;
			totc++;
			ind++;
		}
		while (*fp == CR || *fp == LF) 
		{
			totc++; 
			fp++;
		}
		one_line = (char *)GC_MALLOC((ind+1) * sizeof(char));
		if (one_line == NULL) 
		{
			fprintf(stderr, 
						"\n[load_spd_data]: Cannot malloc memory for line:%s (%u)\n", 
						strerror(errno), errno);
			return 1;
		}
		strncpy(one_line, here, ind);
		one_line[ind] = '\0';
		if (one_line[0] == '#' || one_line[0] == LF || one_line[0] == ' '|| one_line[0] == CR) continue;
		/*print incoming parameter*/
		/*split line into 3 number separated by space*/
		sscanf (one_line,
					"%lf %lf %Lf\n", 
					&(active_flow->spd_grd + *ct)->easting, 
					&(active_flow->spd_grd + *ct)->northing, 
					&(active_flow->spd_grd + *ct)->prob); 
		(*ct)++;
	}
	return 0;
}
/*############################################################################
# MOLASSES (MOdular LAva Simulation Software for the Earth Sciences) 
# The MOLASSES model relies on a cellular automata algorithm to 
# estimate the area inundated by lava flows.MOLASSES 
#
#    Copyright (C) 2015-2021  
#    Laura Connor (lconnor@usf.edu)
#    Jacob Richardson 
#    Charles Connor
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
###########################################################################*/ 
#include "include/prototypes_LJC2.h"

DataCell **DEM_LOADER(
char *DEMfilename,
double *DEMGeoTransform,
DataCell **grid, 
char *modeltype) {
/*
MODULE: DEM_LOADER_GDAL
Accepts a file name and a null data grid
Checks for validity of raster file
Load raster file metadata into array (DEMGeoTransform)
Load Raster Data into DataCell grid array depending on Raster Type:
TOPOG: DEMgrid.dem_elev (elevation)
T_UNC: DEMgrid.elev_uncert (grid cell uncertainty)
RESID: DEMgrid.residual (modal flow residual)
	
RETURN:
DataCell **grid, or NULL on error
	

DEMGeoTransform[0] lower left x
DEMGeoTransform[1] w-e pixel resolution (positive value)
DEMGeoTransform[2] number of cols, assigned manually in this module 
DEMGeoTransform[3] lower left y
DEMGeoTransform[4] number of rows, assigned manually in this module
DEMGeoTransform[5] n-s pixel resolution (negative value) 
	
*/
	
	GDALDatasetH    DEMDataset;/*The raster file*/
	GDALDriverH     DEMDriver; /*essentially the raster File Type*/
	GDALRasterBandH DEMBand;
    
	float *pafScanline;
	int type = -1;
	int YOff;
	int i,j;
	float k;
	DataCell **local_grid;	

	GDALAllRegister();
	DEMDataset = GDALOpen( DEMfilename, GA_ReadOnly ); /* Open file */
	if(DEMDataset == NULL){
		fprintf(stderr, "ERROR [DEM_LOADER]: File=[%s] could not be opened!\n", DEMfilename);
		return NULL;
	}
	
	/*Make sure Projection metadata is valid (that the raster is a valid raster)*/
	if( GDALGetProjectionRef( DEMDataset ) == NULL ){
		fprintf(stderr, "ERROR [DEM_LOADER]: File=[%s] could not be read!\n", DEMfilename);
		return NULL;
	}
	
	/*Read DEM raster metadata into DEMGeoTransform*/
	if( GDALGetGeoTransform( DEMDataset, DEMGeoTransform ) != CE_None )
	{
		fprintf(stderr, "ERROR [DEM_LOADER]: Data from [%s]could not be loaded!\n",DEMfilename);
		return NULL;
	}
	
	DEMDriver = GDALGetDatasetDriver( DEMDataset ); 	/* Find out raster type (e.g. tiff, netcdf)*/
	DEMGeoTransform[5] = -1 * DEMGeoTransform[5]; /*row height*/
	DEMGeoTransform[4] = GDALGetRasterYSize( DEMDataset );
	DEMGeoTransform[2] = GDALGetRasterXSize( DEMDataset );
	DEMGeoTransform[3] -= (DEMGeoTransform[5] * DEMGeoTransform[4]);
	
	fprintf(stdout, "\nDEM Information [%s]:\n", GDALGetDriverLongName(DEMDriver)); 
	fprintf(stdout, "  File:              %s\n", DEMfilename);
	fprintf(stdout, "  Lower Left Origin: (%.6f,%.6f)\n", DEMGeoTransform[0], DEMGeoTransform[3]);
	fprintf(stdout, "  GMT Range Code:    -R%.3f/%.3f/%.3f/%.3f\n",
	        DEMGeoTransform[0],
	       (DEMGeoTransform[0]+((DEMGeoTransform[2]-1)*DEMGeoTransform[1])),
	        DEMGeoTransform[3],
	       (DEMGeoTransform[3]+((DEMGeoTransform[4]-1)*DEMGeoTransform[5])));
	fprintf(stdout, "  Pixel Size:        (%.6f,%.6f)\n",
	       DEMGeoTransform[5], DEMGeoTransform[1]);
	fprintf(stdout, "  Grid Size:         (%d,%d)\n",
	       (int)DEMGeoTransform[4], (int)DEMGeoTransform[2]);
	
	if(!strcmp(modeltype,"TOPOG")) {
		type = Topog;
		fprintf(stdout, "              Creating ELEVATION Grid...\n");
		local_grid = GLOBALDATA_INIT(DEMGeoTransform[4], DEMGeoTransform[2]);
        if (local_grid == NULL) return NULL;
        else grid = local_grid;
	} 
	else if(!strcmp(modeltype,"RESID")) {
		fprintf(stdout, "              Creating RESIDUAL Grid...\n");
		type = Resid;
	}
	else if(!strcmp(modeltype, "T_UNC")) {
		fprintf(stdout, "              Creating ELEVATION UNCERTAINTY Grid...\n");
		type = T_unc;
	}
		
	DEMBand = GDALGetRasterBand(DEMDataset, 1); /* 1 band in raster */
	pafScanline = (float *) CPLMalloc(sizeof(float) * DEMGeoTransform[2]); /* Allocate for 1 row of data */
	 	
	for(i=0; i < DEMGeoTransform[4]; i++) { /*For each row*/
        YOff = (DEMGeoTransform[4]-1) - i; /* bottom row is read in first*/
		if((GDALRasterIO(DEMBand, /*Read elevation data from row in input raster*/
            GF_Read, 0, YOff, DEMGeoTransform[2], 1, pafScanline, DEMGeoTransform[2], 1, GDT_Float32, 0, 0)) != CE_None) {
            fprintf(stderr, 
                "\nERROR [DEM_LOADER]: DEM file [%s] could not be read!\n", DEMfilename);
            return NULL;
		}
	
		if((i % 50) == 0) { /*Command line Status Bar*/
			k = 0;
			fprintf(stdout, "\r");
			while(k < (DEMGeoTransform[4] - 1)){		
				if (k < i) fprintf(stdout, "=");
				else if((k - ((DEMGeoTransform[4] - 1) / 60)) < i) fprintf(stdout, ">");
				else fprintf(stdout, " ");
				k += DEMGeoTransform[4] / 60;
			} fprintf(stdout, "| %3d%%",(int) (100 * i / (DEMGeoTransform[4] -1)));
		}
	
		for (j = 0; j < DEMGeoTransform[2]; j++) { /*Write elevation column by column into 2D array*/
			if (type == Topog) {
				(grid)[i][j].dem_elev = pafScanline[j];
				(grid)[i][j].eff_elev = (grid)[i][j].dem_elev;
				(grid)[i][j].parentcode = 0;
				(grid)[i][j].active = -1;
				(grid)[i][j].hit_count = 0; /* Initialize hit count */
			} 
			else if (type == Resid) 
				(grid)[i][j].residual = pafScanline[j];
			else if (type == T_unc) 
				(grid)[i][j].elev_uncert = pafScanline[j];
		}
	}
	fprintf(stdout, "\n DEM Loaded.\n\n");
	CPLFree(pafScanline);
	fflush(stdout);
	return(grid);
}
#include <stdio.h>


#include "include/prototypes_LJC2.h"
int DISTRIBUTE( 
DataCell **grid,
ActiveList *activeList,
unsigned int *CAListSize,
unsigned int *activeCount,
Neighbor *activeNeighbor,
double *gridinfo,
Inputs *in
/*Vent *vent*/)
{

	int ct = 0;
	int neighborCount = 0;              /* Number of lava-accepting cells in neighborhood */
	double myResidual, thickness;
	int n = 0;  					/* neighbor counter*/
	double lavaOut, lavaIn;      /* lava volume to advect away from center cell    */
	unsigned char parentCode = 0;            /* bitwise parent-child relationship code         */
	ActiveList *more = NULL;
	int active_neighbor;
	double total_wt, my_wt;
	int i, j, max, temp, r, nc;   
  int shuffle[8];
  int excess = 0;
 
	*activeCount = 1;
	do { /* for all active cells */
	  
		myResidual = grid[(activeList+ct)->row][(activeList+ct)->col].residual;
		thickness = grid[(activeList+ct)->row][(activeList+ct)->col].eff_elev 
		          - grid[(activeList+ct)->row][(activeList+ct)->col].dem_elev;
		lavaOut = thickness - myResidual;	
    /* if (lavaOut <=0) return 0; */
		
		/* Find neighbor cells which are not parents and have lower elevation than active cell */
				
		neighborCount = NEIGHBOR_ID(
									(activeList+ct),		/*Automata Center Cell (parent))*/
									grid,							/*DataCell Global Data Grid */
									gridinfo,					/*double   grid data */
									activeNeighbor		/* list for active neighbors */
									/* vent					   Vent* Pointer to the vent data structure */	);
		
    
	
		/* If neighbors are found */
		if (neighborCount > 0) {
      max = neighborCount - 1;
      total_wt = 0.0;
      lavaIn = 0.0;
      for (i = 0; i < neighborCount; i++) {
        total_wt += (activeNeighbor+i)->elev_diff;
        shuffle[i] = i;
      }  
		
      if (neighborCount > 1) { /* then shuffle list */
        for (i = 0; i < neighborCount-1; i++) {
         r = (rand() % max);
  	     temp = shuffle[r];
         shuffle[r] = shuffle[max];
  	     shuffle[max] = temp;
  	     max--;
       }
      } 

			/* For each neighbor */				
			for (nc = 0; nc < neighborCount; nc++) {
        n = shuffle[nc]; 
			
				/* Find parent of each neighbor cell */ 
				
				
				if ( (activeNeighbor+n)->row > (activeList+ct)->row  && (activeNeighbor+n)->col < (activeList+ct)->col ) parentCode = 3; /* (0011) this neighbor's parent is SE */
				
				else if ( (activeNeighbor+n)->row > (activeList+ct)->row && (activeNeighbor+n)->col > (activeList+ct)->col ) parentCode = 9; /* (1001) this neighbor's parent is SW */
				
				else if ( (activeNeighbor+n)->row < (activeList+ct)->row && (activeNeighbor+n)->col < (activeList+ct)->col ) parentCode = 6; /* (0110) this neighbor's parent is NE */
				
				else if ( (activeNeighbor+n)->row < (activeList+ct)->row && (activeNeighbor+n)->col > (activeList+ct)->col ) parentCode = 12; /* (1100) this neighbor's parent is NW */
				
				else if ((activeNeighbor+n)->row > (activeList+ct)->row) parentCode = 1; /* (0001) this neighbor's parent is SOUTH */
					
				else if ((activeNeighbor+n)->col < (activeList+ct)->col) parentCode = 2; /*  (0010) this neighbor's parent is EAST */
						
				else if ((activeNeighbor+n)->row < (activeList+ct)->row) parentCode = 4; /* (0100) this neighbor's parent is NORTH */
						
				else if ((activeNeighbor+n)->col > (activeList+ct)->col) parentCode = 8; /* (1000) this neighbor's parent is WEST */
					
				/* Assign parentCode to neighbor grid cell */
				grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].parentcode = parentCode; 
		/*		if (grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].active >= *activeCount)
          grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].active = -1;*/
				/* Now Calculate the amount of lava this neighbor gets		
					This neighbor gets lava proportional to the elevation difference with its parent;
					lower neighbors get more lava, higher neighbors get less lava.
				*/	
			
        if (total_wt > 0.0) {	
            my_wt = 	(activeNeighbor+n)->elev_diff;
						lavaIn = lavaOut * ( my_wt / total_wt);
				}
				else { 
					fprintf (stderr,  
						"PROBLEM: Cannot divide by zero or difference is less than 0: total_wt = %f\n", 
						total_wt);
						fflush(stderr);
						exit(1);
				}
					
				/* Distribute lava to neighbor */			
				grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].eff_elev += lavaIn;
				
				myResidual = grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].residual;
				
				thickness = grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].eff_elev
					          - grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].dem_elev;
					          
				/* NOW, IF neighbor has excess lava */ 
				if (thickness > myResidual){ 
            				  
				  /* check if this neighbor is active */
				  active_neighbor = grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].active;		
				  	
				  if (active_neighbor < 0) { 
          /* If neighbor cell is not on active list (first time with excess lava) or 
             neighbor was on active list of previous pulse */
					
					 /* Add neighbor to end of current active list */
					 (activeList + *activeCount)->row = (activeNeighbor+n)->row;
					 (activeList + *activeCount)->col = (activeNeighbor+n)->col;
           /*(activeList + *activeCount)->excess = 1;*/
					 grid[(activeNeighbor+n)->row][(activeNeighbor+n)->col].active = *activeCount;
					 *activeCount += 1;				
						
						if (*activeCount == *CAListSize) { /* resize active list if more space is needed */
							fprintf (stderr, 
							"Number of cells = %u; active list out of memory (%u) reallocation happening .....\n", 
							*activeCount, *CAListSize);
							*CAListSize *= 2;
							more = (ActiveList *) GC_REALLOC( activeList, (size_t)(*CAListSize) * sizeof(ActiveList) );
							if (more != NULL) activeList = more;
							else {
								fprintf(stderr, "[DISTRIBUTE]\n");
								fprintf(stderr, 
								"   NO MORE MEMORY: Tried to re-allocate memory for activelist (%u)\n", *CAListSize);
								fflush(stderr);
								return 1;
							}
					 } 
					 
				}  /* END if (active_neighbor < 0) Neighbor not on active list */

        /*else if (active_neighbor < ct)
          (activeList + active_neighbor)->excess = 1; * Active cell receives more lava */

		  } /* END thickness > residual */
     
		} /* END for each neighbor */
				
		/*REMOVE LAVA FROM Parent CELL**************************/
		/* Subtract lavaOut  from activeCell's  effective elevation*/
		grid[(activeList+ct)->row][(activeList+ct)->col].eff_elev -= lavaOut;
    (activeList + ct)->excess = 0;
	}
	 else if (neighborCount < 0) { /* might be off the grid */
				fprintf(stdout, 
				"ERROR [DISTRIBUTE]:  neighbor count=%d\n", 
				neighborCount);
				return neighborCount;
	  }
	  ct++;
	  if (ct == *activeCount && excess < 3) {
	    ct = 0;
	    excess += 1;
	  }
	} while (ct < *activeCount); /*Keep looping until all active cells have been tested*/
	
	/* All active cells have given away their access lava 
	for(i = 0; i < gridinfo[4]; i++) {
		for(j = 0; j < gridinfo[2]; j++) {
		    grid[i][j].active = -1;
		}
	}*/
  for (j = 1; j < *activeCount; j++) 
    grid[(activeList+j)->row][(activeList+j)->col].active = -1;
	/*return 0 for a successful round of distribution.*/
/*	fflush(stderr);*/
	return 0;
}


#include <stdio.h>

int main(int argc, char *argv[]) {

	DataCell **Grid = NULL;			/* data Grid */
	ActiveList *CAList = NULL;		/* Active Cell list */
	Neighbor NeighborList[8];		/* Each cell can have at most 4 or 8 neighbors. */
	Lava_flow ActiveFlow;						/* Lava_flow structure */
	unsigned int ActiveCounter = 0;		/* current # of Active Cells */
	
	Inputs In;				/* Structure to hold model inputs named in Config file */
	Outputs Out;			/* Structure to hold model outputs named in config file */
	int size = 25;					/* variable used for creating seed phrase */
	char *phrase;			/* seed phrase for random number generator */
	int seed1;				/* random seed number */
	int seed2;				/* random seed number */
	int i,j, ret;  
	unsigned int CAListSize  = 0;				/* Current size of active list, see INIT_FLOW */
	unsigned int pulseCount  = 0;				/* Current number of Main PULSE loops */
	double thickness;						/* thickness of lava in cell */
	double areaInundated = 0;
	double DEMmetadata[6];				/* Geographic Metadata from GDAL */
	double volumeErupted = 0;		/* Total Lava Volume in All Active Cells */
	double volumeRemaining = 0;	/* Volume Remaining to be Erupted */
	double total = 0;						/* Difference between volumeErupted-Flow.volumeToErupt */

	int run = 0;			/* Current lava flow run */ 
	int start = 0;		/* Starting run number, from command line or 0 */
	int endrun = 0;   /* Last lava flow run */
	int current_vent = 0; /* Keep track of which vent is currently erupting */
  
	GC_INIT();
	startTime = time(NULL); 
	srand(time(NULL));
	
	phrase = (char *)GC_MALLOC_ATOMIC(((size_t)size * sizeof(char)));	
  if (phrase == NULL) {
    fprintf(stderr, "Cannot malloc memory for seed phrase:[%s]\n", strerror(errno));
    return 1;
  }
  snprintf(phrase, size, "%d", (int)startTime);
  fprintf(stdout, "Seeding random number generator: %s\n", phrase);
  initialize ( );  /* Initialize the rng's */
  phrtsd ( phrase, &seed1, &seed2 ); /* Initialize all generators. */
  set_initial_seed ( seed1, seed2 );  /* Set seeds based on phrase. */
    
	fprintf(stdout, "\n\n               MOLASSES is a lava flow simulator.\n\n");
	
	if(argc < 2) {
		fprintf(stderr, "Usage: %s config-filename\n",argv[0]);
		return 1;
	}
	if (argc > 2) {
		start = atoi(argv[2]);
		fprintf(stderr, "Starting with run #%d\n", start);
		if (start < 0) start = 0;
	}
	fprintf(stdout, "Starting with run #%d\n", start);
	
	fprintf(stdout, "Beginning flow simulation...\n");	    
	In.config_file = argv[1]; 
	fprintf(stdout, "Config file: %s\n", In.config_file);
	
    /* Initialize variables with values from the config file */
	ret = INITIALIZE(
	&In,        /* (type=Inputs*) 1D Input parameters structure  */
	&Out,       /* (type=Outputs*) 1D Output parameters structure */
	&ActiveFlow);     /* (Lava_flow*) Lava_flow Structure */

	if(ret){
		fprintf(stderr, "\n[MAIN]: Error flag returned from [INITIALIZE].\n");
		fprintf(stderr, "Exiting.\n");
		return 1;
	}

	/* Read in the DEM using the gdal library */
	Grid = DEM_LOADER(
	In.dem_file,	/* (type=char*)  DEM file name */
	DEMmetadata,	/* (type=double*) 1D Metadata array */
	Grid,			/* (type=DataCell**)  pointer ->2D Data Grid */
	"TOPOG");		/* (type=string) Code for topography grid */
	                        
	if(Grid == NULL){
		fprintf(stderr, "[MAIN]: Error returned from [DEM_LOADER]. Exiting.\n");
		return 1;
	}
	
	/* This is the pixel resolution. Assumes both dimensions are the same. */
	/* In.cell_size = DEMmetadata[5]; */
	
	if(In.elev_uncert == -1) { /* user input an elevation uncertainty map*/
		Grid = DEM_LOADER(		/* see file demloader.c) */
		In.uncert_map,		/* (type=char*) uncertainty-grid filename*/
		DEMmetadata, 		/* (type=double*) Metadata array */
		Grid,    			/* (type=DataCell**)  pointer ->2D Data Grid */
		"T_UNC");			/* (type=string) Code for elevation uncertainty */
    
		if(Grid == NULL){
      	fprintf(stderr, "[MAIN]: Error returned from [DEM_LOADER]. Exiting.\n");
      	return 1;
    	}
	}
	else {		/* Select uncertainty value from config file */
		for(i=0;i<DEMmetadata[4];i++) {
			for(j=0;j<DEMmetadata[2];j++) {
				Grid[i][j].elev_uncert = In.elev_uncert;
			}
		}
	}
	
	endrun = In.runs + start;
	for (run = start; run < endrun; run++) {
		pulseCount = 0; /* Keeps tract of number of lava pulses per run. */
		ActiveCounter = 0; /* Keeps track of the current number of active cells. */
		fprintf (stderr, "RUN #%d\n\n", run);
		fprintf (stdout, "\nRUN #%d\n", run);
		
		ret = SET_FLOW_PARAMS(	/* see file set_flow_params.c  */
				&In,				/* (type=Inputs*) 1D Input parameters structure  */
				&ActiveFlow,			/* (Lava_flow*) Flow Structure */
				DEMmetadata,	/* (type=double*) Metadata array */
				Grid);			/* (type=DataCell**)  2D Data Grid */
		
		/* Select new vent from spatial density grid 
		   OR
		   If a vent coordinate is given, then use this coordinate. 
		*/
		if (In.spd_file != NULL) {
			do { 
				ret = CHOOSE_NEW_VENT(&In, ActiveFlow.source, ActiveFlow.spd_grd );
				if (ret) {
					fprintf (stderr, "\n[MAIN] Error returned from [CHOOSE_NEW_VENT].\nExiting!\n");
					return 1;
				}
				ret = CHECK_VENT_LOCATION(ActiveFlow.source, DEMmetadata, Grid); /*Check for Vent outside of map region*/
				if (ret) {
					ActiveFlow.source->easting = 0;
					ActiveFlow.source->northing = 0;
					continue; /* select another vent location */
				}
			} while (!ActiveFlow.source->easting || !ActiveFlow.source->northing);
		}
		for (i = 0; i < ActiveFlow.num_vents; i++) {
		  ret = CHECK_VENT_LOCATION(ActiveFlow.source+i, DEMmetadata, Grid); /*Check for Vent outside of map region*/
		  if (ret) {
			  fprintf (stderr, "[MAIN]Vent location outside of the grid area. Exiting\n");
		    return 1;
		  }
      fprintf (stderr, "[Run: %d] Vent: EASTING: %f\tNorthing: %f\n", run, (ActiveFlow.source+i)->easting, (ActiveFlow.source+i)->northing);
      fprintf (stdout, "[Run: %d] Vent: EASTING: %f\tNorthing: %f\n", run, (ActiveFlow.source+i)->easting, (ActiveFlow.source+i)->northing);
      /*row = (int) ( ( Vent.northing - DEMmetadata[3]) / DEMmetadata[5]); / Row (Y) of vent cell */
      /*col = (int) ((Vent.easting - DEMmetadata[0]) / DEMmetadata[1]); /Col (X) of vent cell */
     /* Grid[row][col].active = 0; / vent cell */
    }
		/* Initialize the lava flow data structures and initialize vent cell. 
		   TODO: try to figure out the maximum size possible for the active list */
		CAList = INIT_FLOW(
		Grid,					/* (type=DataCell**)  2D Data Grid */
		/* CAList,				type=ActiveList*) 1D Active Cells List */
		ActiveFlow.source,				/* (type=Lava_flow*) Lava_flow Data structure */
		ActiveFlow.num_vents, /* Number of erupting vents */
		&CAListSize,		/* (type= unsigned int*)  Max size of active List */
		/* &ActiveCounter, 	 (type= unsigned int*) Active list current cell count */
		DEMmetadata);		 /* (type=double*) Metadata array */

		if (CAList == NULL) { 
			fprintf (stderr, "[MAIN] Error returned from [INIT_FLOW]. Exiting\n");
			return 1;
		}

		/* fprintf(stdout, "\nRunning Flow #%d from (%d, %d)\n", run, CAList->row, CAList->col); */
		/* Initialize the remaining volume to be the volume of lava to erupt. */
		volumeRemaining = ActiveFlow.volumeToErupt; 
		//current_vent = (current_vent + 1) % (ActiveFlow.num_vents);
    current_vent = 0;
		/* Run the flow until the volume to erupt is exhausted. */
		while(volumeRemaining > (double) 0.0) {
      
			/* vent cell gets a new pulse of lava to distribute 
			   see file: pulse.c 
			*/
			current_vent = (current_vent + 1) % (ActiveFlow.num_vents);
			
			CAList->row = (ActiveFlow.source+current_vent)->row;
			CAList->col = (ActiveFlow.source+current_vent)->col;
			
			if (!(pulseCount % 100))
				fprintf(stdout, "[R%d]Vent: %6.0f %6.0f; Active Cells: %-3u; Volume Remaining: %10.3f Pulse count: %3u \n",
				run,	
				(ActiveFlow.source+current_vent)->easting,
				(ActiveFlow.source+current_vent)->northing,		
				ActiveCounter,
				volumeRemaining,
				pulseCount);
			
			
			PULSE(
			/* &ActiveCounter, 	 (type= unsigned int*) Active list current cell count */
			CAList,				/* (type=ActiveList*) 1D Active Cells List */
			&ActiveFlow,				/* (type=Lava_flow*) Lava_flow Data structure */
			Grid,					/* (type=DataCell**)  2D Data Grid */
			&volumeRemaining,	/* (type=double) Lava volume not yet erupted */
			DEMmetadata);		/* (type=double*) Metadata array */
		
			pulseCount++;

			/* Distribute lava to active cells and their 8 neighbors. */
			ret = DISTRIBUTE(
			Grid,					/* (type=DataCell**)  2D Data Grid */
			CAList,				/* (type=ActiveList*) 1D Active Cells List */
			&CAListSize,	/* (type=unsigned int) Max size of Active list */
			&ActiveCounter,	/* (type=unsigned int*) Active list current cell count */
			NeighborList,  	/* (type=Neighbor*) 8 element list of cell-neighbors info */
			DEMmetadata,		/* (type=double*) Metadata array */
			&In					/* (type=Inputs*) Inputs structure */
			/* &ActiveFlow.source				(type=Lava_flow*) Lava_flow Data structure */
			);

			if (ret) {
				fprintf (stderr, "[MAIN} Error returned from [DISTRIBUTE].ret=%d.. ", ret);
				if (ret < 0) { 
					if (run > 0) {
					 fprintf(stdout, "Starting a new run.\n");
					 run--;
					}
					volumeRemaining = 0.0;
				}
			}	
		} /* while(volumeRemaining > (double)0.0) */
			
		

		volumeErupted = 0.0;
		ActiveCounter = 0;
		/* Sum lava volume in each active flow cell */
		
		for(i = 0; i < DEMmetadata[4]; i++) {
			for(j = 0; j < DEMmetadata[2]; j++) {
				thickness = Grid[i][j].eff_elev - Grid[i][j].dem_elev;
					/*if (Grid[i][j].active > -1)*/
				if (thickness > 0) {  
				  Grid[i][j].hit_count++; /* Increment hit codouble areaInundated = 0;unt */
				  ActiveCounter++;
				}
				volumeErupted += (thickness * DEMmetadata[1] * DEMmetadata[5]);
			}
		} 
		areaInundated = ActiveCounter *  DEMmetadata[1] * DEMmetadata[5];
		areaInundated /= 1e6;
      fprintf(stdout, "Final Distribute: %d cells inundated.\n\n", ActiveCounter);
      fprintf(stdout, "Area inundated:    %12.3f square km\n\n", areaInundated);
		fprintf(stdout, "Conservation of mass check\n");
		fprintf(stdout, " Total (IN) volume pulsed from vents:   %12.3f\n", ActiveFlow.volumeToErupt);
		fprintf(stdout, " Total (OUT) volume found in cells:     %12.3f\n\n", volumeErupted);

		total = volumeErupted - ActiveFlow.volumeToErupt;
		if(abs(total) > 1e-8) fprintf(stderr, " ERROR: MASS NOT CONSERVED! Excess: %12.3f\n", total);
		fprintf(stderr, "----------------------------------------\n");
		
		/* Save the flow thickness for each run to a file */
		ret = OUTPUT(
		run,             /* run number */
		ascii_flow,      /* file output type */
		&Out,            /* (type=Outputs*) 1D Output parameters structure */
		&In,             /* (type=Inputs*) 1D Input parameters structure */
		Grid,            /* (type = DataCell *) Global Data Grid */ 
		&ActiveFlow,           /* (type=Lava_flow*) Lava_flow Data structure */
		DEMmetadata);    /* (type=double*) Metadata array */ 
		if (ret) fprintf(stderr, "OUTPUT ERROR!\n");
		fprintf(stdout, "OK\n");
		if (In.flow_field) { /* reinitialize the data grid using new dem*/
			for(i = 0; i < DEMmetadata[4]; i++) {
				for(j = 0; j < DEMmetadata[2]; j++) {
					Grid[i][j].dem_elev = Grid[i][j].eff_elev;
					Grid[i][j].active = -1;
					Grid[i][j].parentcode = 0;
				}
			}
		}
		else { /* just reinitialize the data grid for new flow */
			for(i = 0; i < DEMmetadata[4]; i++) {
				for(j = 0; j < DEMmetadata[2]; j++) {
					Grid[i][j].eff_elev = Grid[i][j].dem_elev;
					Grid[i][j].active = -1;
					Grid[i][j].parentcode = 0;
			 }
			}
		}
	} /* END:  for (run = start; run < (In.runs+start); run++) { */	
	fprintf(stdout, "OK\n");
	if (strlen(Out.ascii_hits_file) > 2) {
	ret = OUTPUT(
		run,             /* run number */
		ascii_hits,      /* file output type */
		&Out,            /* (type=Outputs*) 1D Output parameters structure */
		&In,             /* (type=Inputs*) 1D Input parameters structure */
		Grid,            /* (type = DataCell *) Global Data Grid */ 
		&ActiveFlow,           /* (type=Lava_flow*) Lava_flow Data structure */
		DEMmetadata);    /* (type=double*) Metadata array */ 
	if (ret) fprintf(stderr, "Ascii hits OUTPUT ERROR!\n");
	}
	fprintf(stdout, "OK\n");
	if (strlen(Out.raster_hits_file) > 2) {
	ret = OUTPUT(
		run,             /* run number */
		raster_hits,      /* file output type */
		&Out,            /* (type=Outputs*) 1D Output parameters structure */
		&In,             /* (type=Inputs*) 1D Input parameters structure */
		Grid,            /* (type = DataCell *) Global Data Grid */ 
		&ActiveFlow,           /* (type=Lava_flow*) Lava_flow Data structure */
		DEMmetadata);    /* (type=double*) Metadata array */ 
	if (ret) fprintf(stderr, "Raster hits OUTPUT ERROR!\n");
	}
	fprintf(stdout, "OK\n");
	if (In.flow_field > 0 && strlen(Out.raster_post_dem_file) > 2) {
		ret = OUTPUT(
		run,             /* run number */
		raster_post,      /* file output type */
		&Out,            /* (type=Outputs*) 1D Output parameters structure */
		&In,             /* (type=Inputs*) 1D Input parameters structure */
		Grid,            /* (type = DataCell *) Global Data Grid */ 
		&ActiveFlow,           /* (type=Lava_flow*) Lava_flow Data structure */
		DEMmetadata);    /* (type=double*) Metadata array */ 

		if (ret) fprintf(stderr, "Raster post dem OUTPUT ERROR!\n");
	}
	fprintf(stdout, "OK\n");
	endTime = time(NULL); /* Calculate simulation time elapsed */
	if ((endTime - startTime) > 60) {
		fprintf(stdout, "\n\nElapsed Time of simulation approximately %0.1f minutes.\n\n",
		(double)(endTime - startTime)/60.0);
	}	
	else {
		fprintf(stdout, "\n\nElapsed Time of simulation approximately %u seconds.\n\n",
		(unsigned)(endTime - startTime));
	}
	fflush(stdout);
	return 0;
}
#include <stdio.h>
#include <stdio.h>
#include "pico/stdlib.h"
#include "pico/binary_info.h"
#include "midi_uart_lib.h"
#include "bsp/board_api.h"
#include "tusb.h"
#include "usb_midi_host.h"

// UART selection Pin mapping. You can move these for your design if you want to
// Make sure all these values are consistent with your choice of midi_uart
// The default is to use UART 1, but you are free to use UART 0 if you make
// the changes in the CMakeLists.txt file or in your environment. Note
// that if you use UART0, then serial port debug will not be enabled
#ifndef MIDI_UART_NUM
#define MIDI_UART_NUM 1
#endif
#ifndef MIDI_UART_TX_GPIO
#define MIDI_UART_TX_GPIO 4
#endif
#ifndef MIDI_UART_RX_GPIO
#define MIDI_UART_RX_GPIO 5
#endif

static void *midi_uart_instance;
static uint8_t midi_dev_addr = 0;

static void blink_led(void)
{
    static absolute_time_t previous_timestamp = {0};

    static bool led_state = false;

    absolute_time_t now = get_absolute_time();
    
    int64_t diff = absolute_time_diff_us(previous_timestamp, now);
    if (diff > 1000000) {
        board_led_write(led_state);
        led_state = !led_state;
        previous_timestamp = now;
    }
}

static void poll_midi_uart_rx(bool connected)
{
    uint8_t rx[48];
    // Pull any bytes received on the MIDI UART out of the receive buffer and
    // send them out via USB MIDI on virtual cable 0
    uint8_t nread = midi_uart_poll_rx_buffer(midi_uart_instance, rx, sizeof(rx));
    if (nread > 0 && connected && tuh_midih_get_num_tx_cables(midi_dev_addr) >= 1)
    {
        uint32_t nwritten = tuh_midi_stream_write(midi_dev_addr, 0,rx, nread);
        if (nwritten != nread) {
            TU_LOG1("Warning: Dropped %lu bytes receiving from UART MIDI In\r\n", nread - nwritten);
        }
    }
}

int main() {

    bi_decl(bi_program_description("Provide a USB host interface for Serial Port MIDI."));
    bi_decl(bi_2pins_with_names(MIDI_UART_TX_GPIO, "MIDI UART TX", MIDI_UART_RX_GPIO, "MIDI UART RX"));

    board_init();
    printf("Pico MIDI Host to MIDI UART Adapter\r\n");
    tusb_init();

    // Map the pins to functions
    midi_uart_instance = midi_uart_configure(MIDI_UART_NUM, MIDI_UART_TX_GPIO, MIDI_UART_RX_GPIO);
    printf("Configured MIDI UART %u for 31250 baud\r\n", MIDI_UART_NUM);
    while (1) {
        tuh_task();

        blink_led();
        bool connected = midi_dev_addr != 0 && tuh_midi_configured(midi_dev_addr);

        poll_midi_uart_rx(connected);
        if (connected)
            tuh_midi_stream_flush(midi_dev_addr);
        midi_uart_drain_tx_buffer(midi_uart_instance);
    }
}

//--------------------------------------------------------------------+
// TinyUSB Callbacks
//--------------------------------------------------------------------+

// Invoked when device with hid interface is mounted
// Report descriptor is also available for use. tuh_hid_parse_report_descriptor()
// can be used to parse common/simple enough descriptor.
// Note: if report descriptor length > CFG_TUH_ENUMERATION_BUFSIZE, it will be skipped
// therefore report_desc = NULL, desc_len = 0
void tuh_midi_mount_cb(uint8_t dev_addr, uint8_t in_ep, uint8_t out_ep, uint8_t num_cables_rx, uint16_t num_cables_tx)
{
  printf("MIDI device address = %u, IN endpoint %u has %u cables, OUT endpoint %u has %u cables\r\n",
      dev_addr, in_ep & 0xf, num_cables_rx, out_ep & 0xf, num_cables_tx);

  if (midi_dev_addr == 0) {
    // then no MIDI device is currently connected
    midi_dev_addr = dev_addr;
  }
  else {
    printf("A different USB MIDI Device is already connected.\r\nOnly one device at a time is supported in this program\r\nDevice is disabled\r\n");
  }
}

// Invoked when device with hid interface is un-mounted
void tuh_midi_umount_cb(uint8_t dev_addr, uint8_t instance)
{
  if (dev_addr == midi_dev_addr) {
    midi_dev_addr = 0;
    printf("MIDI device address = %d, instance = %d is unmounted\r\n", dev_addr, instance);
  }
  else {
    printf("Unused MIDI device address = %d, instance = %d is unmounted\r\n", dev_addr, instance);
  }
}

void tuh_midi_rx_cb(uint8_t dev_addr, uint32_t num_packets)
{
    if (midi_dev_addr == dev_addr)
    {
        if (num_packets != 0)
        {
            uint8_t cable_num;
            uint8_t buffer[48];
            while (1) {
                uint32_t bytes_read = tuh_midi_stream_read(dev_addr, &cable_num, buffer, sizeof(buffer));
                if (bytes_read == 0)
                    return;
                if (cable_num == 0) {
                    uint8_t npushed = midi_uart_write_tx_buffer(midi_uart_instance,buffer,bytes_read);
                    if (npushed != bytes_read) {
                        TU_LOG1("Warning: Dropped %lu bytes sending to UART MIDI Out\r\n", bytes_read - npushed);
                    }
                }
            }
        }
    }
}

void tuh_midi_tx_cb(uint8_t dev_addr)
{
    (void)dev_addr;
}
#include <stdio.h>

/* esp32-cam camera application jpeg. sensor = ov2640

This file contains:
- main camera application
- esp32 wifi handler
- wifi ssid/password storage in NVS flash memory
- wifi credentials configuration via serial interface on startup.

This software is based on esp-idf version 4.3, 4.4
september 2021, Thomas Krueger, Hofgeismar Germany (all rights reserved)
*/

#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "lwip/err.h"
#include "lwip/sys.h"
#include "driver/gpio.h"
#include "esp_camera.h"

// the camera config structure to be used with the camera driver
static camera_config_t camera_config =
{
    .pin_pwdn  = 32,
    .pin_reset = -1,
    .pin_xclk = 0,
    .pin_sscb_sda = 26,
    .pin_sscb_scl = 27,

    .pin_d7 = 35,
    .pin_d6 = 34,
    .pin_d5 = 39,
    .pin_d4 = 36,
    .pin_d3 = 21,
    .pin_d2 = 19,
    .pin_d1 = 18,
    .pin_d0 = 5,
    .pin_vsync = 25,
    .pin_href = 23,
    .pin_pclk = 22,

    //XCLK 20MHz(or 10MHz for OV2640 double FPS by setting pll x 4)
    .xclk_freq_hz = 20000000,
//   .ledc_timer = LEDC_TIMER_0,  // not using LED dimming
//   .ledc_channel = LEDC_CHANNEL_0,

    .pixel_format = PIXFORMAT_JPEG,//YUV422,GRAYSCALE,RGB565,JPEG       this is the cams output format!!!!!!!!!!!!
    .frame_size = FRAMESIZE_UXGA,//first init with largest framesize to get biggest framebuffers in camera driver

    .jpeg_quality = 10, //0-63 lower number means higher quality
    .fb_count = 2 //number of framebuffers to use for capturing, if > 1, i2s runs in continuous mode.
};


static const char *TAG = "espcam";

/* wifi_status:
0=not initialized;
1= normal run, we are connected;
2=disconnected due to invalid ssid/pass;
3=disconnected due to connection loss
4=undefined, we issued a connect() and are waiting for an event to happen
*/
uint8_t wifi_status=0;

//protos:
void camserver(void);


void wifi_connect(char *ssid, char *passwd);
int wifi_try(char *ssid, char *passwd);
int wifi_startup(void);


void editlogintab(void);
void strcopy( char *s, char *d, int len);
//serial io
void putcc(char c);
char getcc(void);
void getss(char *buf);
void putss(const char *ps);



void app_main(void)
{
    esp_err_t ret;
// init:
    gpio_set_direction(33, GPIO_MODE_OUTPUT); // Debug Led
    gpio_set_level(33, 0); // turn debug led on during boot

    ret = nvs_flash_init(); //needed for wifi and PHY and stored AP logins
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    ESP_LOGI(TAG, "Hit SPACE to enter +++LoginEdit+++...2secs");
    vTaskDelay(2000/portTICK_PERIOD_MS);
    if (fgetc(stdin) == 0x20) editlogintab();

// get the camera going
    ESP_LOGI(TAG, "Init Camera.........");
    ret=esp_camera_init(&camera_config);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG,"Boot: camera init failed....Restarting System now...............>>>>>>\n");
        fflush(stdout);
        esp_restart(); // try to resolve by doing a reset
    }

// set framesize to standard VGA
    sensor_t * s = esp_camera_sensor_get();
    s->set_framesize(s, (framesize_t)FRAMESIZE_VGA);


    if (wifi_startup() == 0) //wifi takes a bit with its logging output...
    {
        ESP_LOGE(TAG, "Could not find a known Wifi Network!!!");
        vTaskDelay(10000/portTICK_PERIOD_MS);
        esp_restart(); // keep trying to find a known wifi router by reseting the system
    }

    gpio_set_level(33, 1); // turn debug led off, boot done, we are connected

    camserver(); //this task becomes the webserver for control

    // we shouldnt get here.
}



//event handler wifi new. this function executes in a different task!
void wifi_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
{
    wifi_event_sta_disconnected_t* disconnect = event_data;

    if (event_base == WIFI_EVENT)
    {
        switch(event_id)
        {
        case WIFI_EVENT_STA_START: // we entered STA wifi mode
            esp_wifi_connect(); // start scanning...and connect...or sta_disconnect
            break;
        case WIFI_EVENT_STA_DISCONNECTED:
            ESP_LOGI(TAG,"STA_DISCONNECTED,reason:%d\n",disconnect->reason);
            if (wifi_status != 3)
            {
                switch (disconnect->reason)
                {

                case WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT: // 15
                case WIFI_REASON_NO_AP_FOUND: //201
                //15=invalid password or not present; 201=ssid not found
				// if ssid is 0, we will not get here as wifi will just scan.

                    wifi_status=2; // we disconnected due to invalid ssid or passwd...try another ssid/passwd
                    break;
                default:
                    wifi_status=3; // we were connected but lost connection to AP, giving up reset
                    break;

                }
            }

            if (wifi_status == 3) // lost connection. just reset, any reconnect upsets the lwip stack
            {
            ESP_LOGI(TAG,"-- lost connection, restarting system ...");
                vTaskDelay(10000/portTICK_PERIOD_MS);
                esp_restart(); // we just reset the board as the TCPserver will likely hang. also we can connect to different AP then.

            }

            break;
        default:
            break;
        }
    }
    else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP)
    {
        // we got ip
        ESP_LOGI(TAG, "+++CONNECTED+++: got ip:" IPSTR , IP2STR(&((ip_event_got_ip_t*)(event_data))->ip_info.ip));
        wifi_status=1; //online
    }

}

// wifi connect to router with credentials supplied in nvs table
void wifi_connect(char *ssid, char *passwd)
{
    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    wifi_config_t wifi_config;
    int ret;

    // from here, we set the given APs credentials and start the connection process.
    memset(&wifi_config, 0, sizeof(wifi_config_t));
    snprintf((char*)wifi_config.sta.ssid, 32, "%s", ssid);
    snprintf((char*)wifi_config.sta.password, 64, "%s", passwd);
    ESP_LOGI(TAG, "...connecting to AP SSID:%s PASSWD:%s",ssid, passwd);

    if (wifi_status) // wifi task is already running, so here we just set the changed ssid/passwd parameters and (re)connect to that AP
    {
        // we assume we are disconnected at this stage!
        if (esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config)  != ESP_OK) // set ssid and passwd of wanted AccessPoint to connect to
        {
            ret=6;
            goto wifierr;
        }

        if (esp_wifi_connect() != ESP_OK) // connect with a new ssid/passwd
        {
            ret=7;
            goto wifierr;
        }
        wifi_status=4; //undefined

        return;
    }

// do first time wifi init stuff to start the wifi task:


// Setup the Wifi eventloop and define 2 events for "got_ip" and "other_stuff"
    if (esp_event_loop_create_default() != ESP_OK) // start the event loop task
    {
        ret=1;
        goto wifierr;
    }
    esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_handler, NULL, &instance_any_id);
    esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_handler, NULL, &instance_got_ip);

    esp_netif_init(); // init lwIP/TCPIP stack. from 4.1 its esp_netif_init().
    esp_netif_create_default_wifi_sta(); // create default station context

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    if (esp_wifi_init(&cfg) != ESP_OK) // WiFi control structure, RX/TX buffer, WiFi NVS structure etc, start WiFi task.
    {
        ret=2;
        goto wifierr;
    }
    if (esp_wifi_set_mode(WIFI_MODE_STA) != ESP_OK) // set Station mode(clientmode)
    {
        ret=3;
        goto wifierr;
    }

    if (esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config)  != ESP_OK) // set ssid and passwd of wanted AccessPoint to connect to
    {
        ret=4;
        goto wifierr;
    }
    if (esp_wifi_start() != ESP_OK) // startup the Wifi process..ie. it starts scanning and will connect
    {
        ret=5;
        goto wifierr;
    }
    esp_wifi_set_ps(WIFI_PS_NONE); // disable powersave. this will make ping go much faster: DEFAULT POWERMODE IS.WIFI_PS_MIN_MODEM
    wifi_status=4; //undefined. event_handler will set the correct status
    return;
wifierr:
    ESP_LOGE(TAG, "Wifi connect error : %d",ret);
}

/* try to connect to an AccessPoint with given credentials
exit:
0=fail;
1=OK, we are connected
*/
int wifi_try(char *ssid, char *passwd)
{
    int count;

    count=100; // 10 sec timeout

    wifi_connect(ssid,passwd);
    while (count--) //try for 10 secs
    {
        vTaskDelay(100/portTICK_PERIOD_MS);
        switch (wifi_status) // did event_handler set new status?
        {
        case 1:
            return 1; //online
        case 2:
        case 3:
            return 0; // disconnected
        default:
            break;
        }
    }
    return 0;
}

/* wifi_startup
This is the main function to connect to a wifi accesspoint.

uses WIFI login credentials saved in NVS:

The NVS-interface is similar to operating files on a computer:
open the file (nvs_open), write a file (nvs_set_xxx), save document(nvs_commit), close the file (nvs_close)
open the file (nvs_open), reading the file (nvs_get_xxx), close the file (nvs_close)

This function reads a table of ssid_name/password pairs from nvs.
"lastindex"  will supply lastused logindata tableindex, as its most likely to be used again.
else or on fail, it will interate through all stored name/passwd entrys until successfull wifi connect happens, and store its index in "lastindex".

if all fail,  it will remain in a loop, with onboard statusLED on (indicating NoWifiConnect).
The user must then update the logintable via serial interface.

exit: 0=fail,1=ok, wifi is up
*/
#define FILENAME "LoginData"
#define DATANAME "LoginTab"
#define nentrys 10
#define nlength 32
//tableformat: tab[number of strings][length of each string]
struct logintable
{
    int lastindex; // range: 0 to n-1
    // 10 entrys of name/passwd Login-pairs of max nlength each. (last char is 0-terminator)
    char name[nentrys][nlength]; //array of 10 names at nlength
    char pass[nentrys][nlength]; // array of 10 passwds at nlength
};

int wifi_startup(void)
{
    nvs_handle filehandle=0;
    size_t bytes = 0;
    esp_err_t ret;
    void *pmem=NULL;
    struct logintable *ptab;
    int i;

    // Open
    ret = nvs_open(FILENAME, NVS_READWRITE, &filehandle); // open a file in nvs, existing or not.
    if (ret != ESP_OK) 		goto reterror; // this should not happen as we allready inited nvs in main.

    pmem = malloc(sizeof(struct logintable));

    if (!pmem)
    {
        ret = -1;
        goto reterror; // malloc failed
    }

    ret = nvs_get_blob(filehandle, DATANAME, NULL, &bytes); // just get the size of the stored filedata. This fails if the record is not found

    if ((bytes != sizeof(struct logintable))||(ret !=ESP_OK)) // if DATANAME hasnt been stored before(0) or has different size
    {
        memset(pmem,0,sizeof(struct logintable)); // clear memory
        bytes = sizeof(struct logintable);
        ret = nvs_set_blob(filehandle, DATANAME, pmem, bytes); // save empty table
        if (ret != ESP_OK) goto reterror;
    }
    else // read in the table
    {
        ret = nvs_get_blob(filehandle, DATANAME, pmem, &bytes);
        if (ret != ESP_OK) goto reterror;
    }
    nvs_close(filehandle); // we need to close it, as wifi will also uses NVS
    filehandle = 0;

    // now the table is in memory (or empty), lets check if last used AP credentials work.
    ptab = pmem;
    if (ptab->lastindex < nentrys)
    {
        i = ptab->lastindex;
        if (ptab->name[i][0]) //...and name exists!
        {
            ret = wifi_try(&ptab->name[i][0], &ptab->pass[i][0]); // connect to last known AP
            if (ret) goto retok; // success
        }
    }

    // now walk through the table and test each entry for valid wifi connect
    for (i=0; i<nentrys; i++)
    {
        if (ptab->name[i][0]) // if first char is not zero, so there is a name in it
        {
            ret = wifi_try(&ptab->name[i][0], &ptab->pass[i][0]);
            if (ret) goto retok; // success
        }
    }

    ret = 0;// we could not connect the wifi from the table and give up here!

    // all entrys failed, now try the name/pass given by the configuration or sourcecode, if there

    goto doreturn;


retok:
//check, lastindex is different to i, ie. a different login was used as last time. update NVS then.
    if (ptab->lastindex != i)
    {
        ptab->lastindex = i;
        ret = nvs_open(FILENAME, NVS_READWRITE, &filehandle);
        if (ret != ESP_OK) 		goto reterror;
        bytes = sizeof(struct logintable);
        ret = nvs_set_blob(filehandle, DATANAME, pmem, bytes); // save empty table
        if (ret != ESP_OK) goto reterror;
        ESP_LOGI(TAG, "updated lastindex!!");
    }

    ret = 1; //OK
    goto doreturn;
reterror:
    if (ret != ESP_OK) ESP_LOGE(TAG, "Fatal error occurred in wifi_startup(): %d ; %s",ret, esp_err_to_name(ret));
    ret = 0; //error
doreturn:
    if (pmem) free(pmem);
    if (filehandle) nvs_close(filehandle);
    return ret;

}



void putcc(char c)
{
    fputc(c, stdout);
}

char getcc(void)
{
    char c;

    while (1)
    {
        vTaskDelay(10/portTICK_PERIOD_MS); //min 10 for watchdog not to trigger!
        c = fgetc(stdin);
        if (c!=0xFF) break;
    }
    putcc(c);
    return c;
}

void getss(char *buf)
{
    char *ps, c;
    ps=buf;
    while (1)
    {
        c=getcc();
        if (( c == 0x0d)||(c==0x0a)) // CR LF
            break;
        *ps++=c;
    }
    *ps=0;
    putcc(0x0d);
    putcc(0x0a);
}

void putss(const char *ps)
{
    while (*ps)
    {
        putcc(*ps++);
    }
}

// string copy where len is the total fieldlength including 0.
void strcopy( char *s, char *d, int len)
{
    len--;
    while (len--&&*s) *d++=*s++;
    *d=0;
}


const char *menue="***Menue***\n"
                  "l-list entrys\n"
                  "e<num>-edit entry\n"
                  "d<num>-delete entry\n"
                  "s-save changes\n"
                  "q-quit\n"
                  ;
const char *prompt="\nespcam>";


/* edit the NVS table for ssid/passwd's
This is called on startup if a SPACE kay was pressed after Reset.
*/
void editlogintab(void)
{
    char buf[100],c;

    nvs_handle filehandle=0;
    size_t bytes = 0;
    esp_err_t ret;
    void *pmem=NULL;
    struct logintable *ptab;
    int i,flag=0;

    // Open
    ret = nvs_open(FILENAME, NVS_READWRITE, &filehandle); // open a file in nvs, existing or not.
    if (ret != ESP_OK) 		ESP_LOGI(TAG, "nvs_open failed!!!");

    pmem = malloc(sizeof(struct logintable));

    if (!pmem)
    {
        ESP_LOGI(TAG, "malloc failed!!!");
    }

    ret = nvs_get_blob(filehandle, DATANAME, NULL, &bytes); // just get the size of the stored filedata. This fails if the record is not found

    if ((bytes != sizeof(struct logintable))||(ret !=ESP_OK)) // if DATANAME hasnt been stored before(0) or has different size
    {
        memset(pmem,0,sizeof(struct logintable)); // clear memory
        bytes = sizeof(struct logintable);
        ret = nvs_set_blob(filehandle, DATANAME, pmem, bytes); // save empty table
        if (ret != ESP_OK) ESP_LOGI(TAG, "nvs_set_blob failed!!!");
    }
    else // read in the table
    {
        ret = nvs_get_blob(filehandle, DATANAME, pmem, &bytes);
        if (ret != ESP_OK) 	ESP_LOGI(TAG, "nvs_get_blob failed!!!");
    }
    ptab = pmem;

    putss(menue);
    putss(prompt);

    while(1) // menue loop
    {
        c = getcc();
        switch(c)
        {
        case 'l': //list
            putss("\nList Logintable:\n");
            sprintf(buf,"LastUsed Entry: %d\n",ptab->lastindex);
            putss(buf);
            for (i=0; i<nentrys; i++)
            {
                sprintf(buf,"%d: %s   %s\n",i,&ptab->name[i][0], &ptab->pass[i][0]);
                putss(buf);
            }
            break;

        case 'e': //edit
            putss("\nEdit:Enter entry (0 to 9):");
            c = getcc();
            c -= 0x30;
            if (c>9) break;
            i=c;
            putss("\nEnter SSID:");
            getss(buf);
            strcopy(buf,&ptab->name[i][0],nlength);
            putss("Enter PASSWD:");
            getss(buf);
            strcopy(buf,&ptab->pass[i][0],nlength);
            ptab->lastindex = 0xff; // invalidate after edit
            break;

        case 'd': //delete
            putss("\nDelete:Enter entry (0 to 9):");
            c = getcc();
            c -= 0x30;
            if (c>9) break;
            i=c;
            ptab->name[i][0]=0;
            ptab->pass[i][0]=0;
            ptab->lastindex = 0xff; // invalidate after edit
            putss("Deleted");
            break;

        case 's': //save
            bytes = sizeof(struct logintable);
            ret = nvs_set_blob(filehandle, DATANAME, pmem, bytes); // save changed table
            if (ret != ESP_OK) ESP_LOGI(TAG, "nvs_set_blob failed!!!");
            putss("\nSaved!");
            break;

        case 'q': //quit
            flag=1;
            break;

        default:
            putss(menue);
        }
        putss(prompt);


        if (flag) break;
    }

    if (pmem) free(pmem);
    if (filehandle) nvs_close(filehandle);

}



#include <stdio.h>
/* tcp server for jpeg camera application

esp32-cam TCP server using lwip directly via BSD Socket API.

OV2640 using jpeg only!

This file contains:
- camcontrol webserver
  - the onboard LED to be used as flashlight (snapshots) or streaming light.
    This LED draws a higher current and gets quite hot.(no dimming is used)
  - nightmode
  - Status/Framerate display
  - Reset option processor

- camstreaming webserver
  - reduced framerate to balance network load on multible camera usage.(linux motion)

NOTES: esp32-cam 5V supply should be increased to min. 5.4V (upto 6V) for stable operation.

september 2020, Thomas Krueger, Hofgeismar Germany (all rights reserved)
*/

#include <string.h>
#include <sys/param.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/timers.h"

#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include "esp_wifi.h"
#include <lwip/netdb.h>
#include "driver/gpio.h"
#include "esp_camera.h"
#include "esp_log.h"


//protos:
void streamtask(void *param);
int tcpserver(int port);
int http_response(int port, char *req, int connection);
int http_stream(int connection);
int get_frame(uint8_t **buf, size_t *len);
static uint16_t set_register(char *uri);
static int set_control(char *uri);
static int get_camstatus(void);
static int get_status(char *uri);
void stream_speed(int full);
void night_mode(int on);

//globals:
camera_fb_t *fb=NULL;					 
char iobuf[1024]; // for control processing
int flashlight, streamlight, streamspeed, nightmode, IsStreaming;

//framerate stuff
TimerHandle_t tmr;
void timerCallBack( TimerHandle_t xTimer );

int NetFPS,HwFPS, I2sFPS, NetFrameCnt, resetflag=0;
int HwFrameCnt, I2sFrameCnt,DMAerrors,JPGerrors;

int uptime; // in seconds
int rssi;

static const char *TAG = "tcpserver";


/* server main function.
starts a task for the streamserver on port 81
then goes into control server on port 80 for camera control
*/
void camserver(void)
{
    TaskHandle_t servertask;

    //NOTE: the RTOS tick is configured to 10ms. so if you set timerperiod to 1, then its actually 10ms!!
    tmr = xTimerCreate("SecTimer", 100, pdTRUE, (void *)0, &timerCallBack); // create a 1Sec software timer
    xTimerStart(tmr,0);  // and start it

    flashlight=streamlight=IsStreaming=streamspeed=nightmode=0;

// init LED (only for AI-Thinker board!!)
    gpio_set_direction(4, GPIO_MODE_OUTPUT); // set portpin to output. HighPower LED

    // give visual indication that a successfull reset occured by turning LED briefly on
//    gpio_set_level(4, 1); // turn led on
//    vTaskDelay(400/portTICK_PERIOD_MS);  // wait a little to get camera exposure settle to new light conditions
    gpio_set_level(4, 0); // turn led off

// set starting streamspeed to slow=9fps(=1Mbit-stream at 640*480) for motion to not overload the wifi network	with 4 cameras
    stream_speed(0);

// start streaming task on port 81
    if (!xTaskCreatePinnedToCore(&streamtask, "streamserver", 8192, NULL, tskIDLE_PRIORITY+5, &servertask, 1))
    {
        ESP_LOGE(TAG, "***Failed to create stream servertask task");
    }

    tcpserver(80); // this task becomes the server on port 80 to serve camera controls and stills

// we should never get here!
    xTimerDelete( tmr,0 );

}

void streamtask(void *param)
{
    tcpserver(81);
}

//  tcp webserver. This may be a task!
int tcpserver(int port)
{
    char request[400];
    int serverSocket, clientConn, ret,cnt=0;
    //setup the socket address struct:
    struct sockaddr_in IpAddress;  // this is an overlay for the struct sockaddr, that eases the portnumber entry.ie. overlays char sa_data[14] with WORD port, ULONG address
    IpAddress.sin_family = AF_INET;
    IpAddress.sin_port = htons(port); // the port to listen on   !!
    IpAddress.sin_addr.s_addr = INADDR_ANY;// INADDR_ANY, server gets IP of the machine its running on.(see bind)
    socklen_t socklen = sizeof(IpAddress);

    // open internet socket/endpoint for HTTP communication. return file handle or -1=error
    serverSocket = socket(
                       AF_INET,      // Domain: IPv4 Internet protocols
                       SOCK_STREAM,  // Communication-Type:  SOCK_STREAM=TCP; SOCK_DGRAM=UDP
                       IPPROTO_TCP   // select TCP.   (was 0: Protocol: 0=IP,internet protocol, pseudo protocol number.TCP and UDP)
                   );
    if (serverSocket < 0)
    {
        ESP_LOGE(TAG,"\nsocket failed");
        return -1;
    }


    // assign a specific internet address and port to the socket using sockaddr-struct from above. return 0=OK, -1=error
    // normally the local loopback address is assigned(0.0.0.0).
    ret=bind(serverSocket, (struct sockaddr *) &IpAddress, socklen );
    if (ret)
    {
        ESP_LOGE(TAG,"\nbind failed");
        return -1;
    }
    // start listening on the socket. returns 0=OK, -1=error
    // The second parameter sets the queue_len for incoming requests.ie. MaxRequests.
    ret = listen(serverSocket, 5);
    if (ret)
    {
        ESP_LOGE(TAG,"\nlisten failed");
        return -1;
    }


    ESP_LOGI(TAG,"Server started on:%s:%u    running on CPUCore:%d", inet_ntoa(IpAddress.sin_addr),ntohs(IpAddress.sin_port),xPortGetCoreID() );

    // wait for connection. We only support 5 connection requests waiting at a time. See listen() above
    // while there are connection requests in the input queue of the socket, process then.
    while(1)
    {
        // wait forever for next tcp connection request from the input queue.
        clientConn = accept(serverSocket, (struct sockaddr *) &IpAddress, &socklen); //this blocks !!
        //printf( "Client connect from: %s:%u\n", inet_ntoa(IpAddress.sin_addr),ntohs(IpAddress.sin_port) );

        // connection is established. loop until closed. So we only allow one connection at a time!
        while (1)
        {
            cnt++;
            // use also poll or select to monitor connection!
            ret = read(clientConn,request,sizeof(request)); //wait for new data on the connection. This blocks!!
            if (ret <= 0)
            {
                //printf("read failed!\n");
                break; // connection lost.  a 0 indicates an orderly disconnect by client; -1 some error occured.
            }
            request[ret]=0; // invalidate last request string
            //printf("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Got:\n %sR-EOT\n",request);

            // process response here.....
            ret=http_response(port, request, clientConn);
            //printf("End of Transaction %d <<<<<<<<<<<<<<<<<<<<<<<<\n",cnt);

            if (!ret) break; //close

        }

        //printf("Connection closed\n");
        close(clientConn); // close current tcp connection

    } // endwhile

    return 0;
}

/*
Request-Line = Method SPACE Request-URI SPACE HTTP-Version CRLF
we only support GET requests!
The request URI contains options on which item is requested!
HTTP-Version: always HTTP1.1.

entry: the complete request string
This routine builds and sends the response!
exit: 1= keep connection; 0=drop connection!
*/
const char *resp_index="HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: %d\r\nContent-Encoding: gzip\r\n\r\n";
const char *resp_basic="HTTP/1.1 %s\r\n\r\n";
// changed to jpg as we only have jpeg.
const char *resp_attach="HTTP/1.1 200 OK\r\nContent-Disposition: attachment; filename=\"frame.jpg\"\r\nContent-Length: %d\r\n\r\n";
const char *resp_capture="HTTP/1.1 200 OK\r\nContent-Type: image/jpeg\r\nContent-Length: %d\r\nContent-Disposition: inline; filename=capture.jpg\r\nAccess-Control-Allow-Origin: *\r\n\r\n";
const char *resp_status="HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: %d\r\nAccess-Control-Allow-Origin: *\r\n\r\n";
const char *resp_control="HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: %d\r\nAccess-Control-Allow-Origin: *\r\n\r\n";

int http_response(int port, char *req, int connection)
{
    // the webpage source is included in the program! This will get the start/end address ..and the length
    extern const unsigned char index_ov2640_html_gz_start[] asm("_binary_index_ov2640_html_gz_start");
    extern const unsigned char index_ov2640_html_gz_end[] asm("_binary_index_ov2640_html_gz_end");
    int indexlength = index_ov2640_html_gz_end - index_ov2640_html_gz_start;
    uint8_t *pb;
    size_t len;
    char response[1024];

    char request[10], uri[100];
    int ret,keepalive=1;
    int more=0;
    uint16_t regval;
    //printf("\n\nLength:%d\n",strlen(req));
    // check for GET: "GET / HTTP/1.1CRLF"
    ret=sscanf(req,"%s %s ",request,uri);
    //printf("req:%s uri:%s ret:%d\n",request,uri,ret);
    if (ret != 2) // some strange request
    {
        sprintf(response,resp_basic,"400 Bad Request");
        goto sendresponse;
    }

    if (strcmp(request,"GET")) // not a GET request
    {
        sprintf(response,resp_basic,"501 Not Implemented");
        goto sendresponse;
    }

    if (port == 80) // control port
    {
        //we are now at GET
        if (!strcmp(uri,"/")||!strcmp(uri,"/index.html")) // request for index.html
        {
            // send the webpage
            sprintf(response,resp_index,indexlength);
            pb=(uint8_t*)index_ov2640_html_gz_start;
            len=indexlength;
            goto sendmore;
        }


        // send status
        if (!strcmp(uri,"/status"))
        {
            if (!get_camstatus()) iobuf[0]=0;
            sprintf(response,resp_status,strlen(iobuf));
            strcat(response,iobuf);
            goto sendresponse;
        }


        // set control
        if (!strncmp(uri,"/control",8))
        {
            ret = set_control(uri);
//        if (ret != 1) goto send404;  webpage freezes if 404 is returned, so dont do it
            sprintf(response,resp_control,0);
            goto sendresponse;
        }

        // Set/Get register value
        if ( !strncmp(uri,"/reg",4) ) // set a register
        {
            regval=set_register(uri);
            sprintf(response,resp_control,0);
            goto sendresponse;

        }

        if ( !strncmp(uri,"/greg",5) ) // get a register
        {
            regval=set_register(uri);
            sprintf(iobuf,"%u",regval);
            sprintf(response,resp_status,strlen(iobuf));
            strcat(response,iobuf);
            goto sendresponse;
        }

        if ( !strncmp(uri,"/getstatus",10) ) // getstatus from server
        {
            ret = get_status(uri);
            sprintf(response,resp_control,strlen(iobuf));
            strcat(response,iobuf);
            goto sendresponse;
        }


        // download raw image!! usually yuv422 like on ov7670, but jpg on ov2640.
        if (!strcmp(uri,"/download"))
        {
            if (!IsStreaming) //if currently streaming 0 Bytes will be downloaded!
            {
                ESP_LOGI(TAG,"Downloading full cam-img as frame.jpg");
                if (flashlight)
                {
                    gpio_set_level(4, 1); // turn led on
                    vTaskDelay(400/portTICK_PERIOD_MS);  // wait a little to get camera exposure settle to new light conditions
                }
				get_frame(&pb,&len); // skip previous frame, it contains old light settings
                if (!get_frame(&pb,&len)) len=0; // get raw image
                gpio_set_level(4, 0); // turn led off
            }
            else
                len = 0;
            sprintf(response,resp_attach,len);
            goto sendmore;

        }

        // capture image!! only if not streaming, as the camera driver gets confused when calling get_frame in 2 tasks at the same time!
        if (!strncmp(uri,"/capture",8))
        {
            if (!IsStreaming)
            {
                ESP_LOGI(TAG,"Get Still");

                if (flashlight)
                {
                    gpio_set_level(4, 1); // turn led on
                    vTaskDelay(400/portTICK_PERIOD_MS);  // wait a little to get camera exposure settle to new light conditions
                }
				get_frame(&pb,&len); // skip previous frame, it contains old light settings
                ret=get_frame(&pb,&len);

                gpio_set_level(4, 0); // turn led off
                if (!ret) len=0;
            }
            else len=0;
            // printf("--pbuf:0x%08x len:%d\n",(uint32_t)pb,len);
            sprintf(response,resp_capture,len);

            goto sendmore;


        }


    } // endif control port 80

// this if we are the streaming server!
    if (port == 81)
    {
        // http stream
        if (!strncmp(uri,"/stream",7))
            return(http_stream(connection));
    }

//default, nothing has catched: send 404 not found/supported----this upsets the client as it waits forever,blocks other controls ...maybe just send http ok??!!
// so we just send a dummy response. The html page does not support catching the error codes!
    ESP_LOGE(TAG,"Unknown GET request: %s",uri);
//    sprintf(response,resp_basic,"404 not found");
    sprintf(response,resp_control,0); // dummy OK

    goto sendresponse;

sendmore:
    more=1; // send data also
    keepalive=1; // keep connection
sendresponse:
    //printf(">>>>send response:\n%sT-EOT\n",response);
    if (more)
    {
        ret = MSG_MORE;
    }
    else ret = 0;

    // send the response text
    ret=send(connection, response, strlen(response),ret);// this blocks until data is sent. ret contains optional MSG_MORE flag to delay sending
    if (ret <= 0)
        return 0; // connection closed. broken connection
    if (ret != strlen(response)) ESP_LOGE(TAG,"send1, not all bytes sent:%d",ret);
    if (more)
    {
        //printf("sending data...\n");
        ret = send(connection, pb, len, 0);// this blocks until data is sent
        if (ret <= 0) // connection closed. broken connection
            return 0;
        if (ret != len) ESP_LOGE(TAG,"send2, not all bytes sent:%d",ret);

    }

// check if reset command was given:
    if (resetflag) 	esp_restart();  // we die from here

    return keepalive;	//in http1.1, always keep connection alive, unless someone hangs up. so always return 1.
}


const char *resp_stream="HTTP/1.1 200 OK\r\nContent-Type: multipart/x-mixed-replace;boundary=ESP32CAM_ServerPush\r\nAccess-Control-Allow-Origin: *\r\n\r\n";
const char *frame_header ="\r\n--ESP32CAM_ServerPush\r\nContent-Type:image/jpeg\r\nContent-Length:%d\r\n\r\n";
//const char *frame_header ="--ESP32CAM_ServerPush\r\n\r\n";
/* keep a streaming video until remote client hangs up
The content type multipart/x-mixed-replace was developed as part of a technology to emulate server push and streaming over HTTP.
This implements "The Multipart Content-Type" over HTTP Protocol using boundary-identifier.
This is not to be confused with chunked!!
The identifier can be any string you like;) must stay the same of corse.

returns 0 = close connection
*/
int http_stream(int connection)
{
    uint8_t *pb;
    size_t len;
    char response[512];

    int ret;

    ESP_LOGI(TAG,"Stream Start....");

    ret=send(connection, resp_stream, strlen(resp_stream),0);
    if (ret <= 0) return 0; //client hanged up

    IsStreaming=1;


    while (1)
    {
        if (streamlight) gpio_set_level(4, 1); // turn led on
        else gpio_set_level(4, 0); // turn led off

        ret=get_frame(&pb,&len);
        if (!ret) // error message is printed in driver if fails
        {
            // something went wrong in the camera/driver, just reset the thing trying to resolve it.
            ESP_LOGE(TAG,"Frame Capture failed....Restarting System now...............>>>>>>\n");
            fflush(stdout);
            esp_restart();
            break;
        }

        sprintf(response,frame_header,len);
        ret=send(connection, response, strlen(response),0);
        if (ret <= 0) //connection closed by client
        {

            break;
        }
        ret = send(connection, pb, len, 0);// this blocks until data is sent
        NetFrameCnt++; // calc FPS
        if (ret <= 0) break; //connection closed by client
        else if (ret != len) ESP_LOGE(TAG,"sendjpg, not all bytes sent:%d errno:%d",ret,errno);
    }

    IsStreaming=0;
    gpio_set_level(4, 0); // turn led off
    ESP_LOGI(TAG,"....Stream Stop");

    return 0; // hangup
}


/*
get a frame from the camera
uses global pointer to  fb_struct (camera framebuffer)
entry:
- address of pointer to receive the resulting framebuffer address.
- address of len variable receiving the length of framebuffer data.
exit:
1=OK, 0=capture  failed.
The buffer with data and the length is returned to caller using pointers!!
*/
int get_frame(uint8_t **buf, size_t *len)
{
    esp_camera_fb_return(fb); //release a possible last used framebuffer. we should work with at least 2 framebuffers!

											   
    fb = esp_camera_fb_get(); // get a new framebuffer with current picture data
    if (!fb)
    {
        ESP_LOGE(TAG,"CamCapture failed");
        return 0;
    }
    else
    {
        // save data from the framebuffer
        *buf=fb->buf;
        *len=fb->len;
    }

    return 1;
}


/* process a register get/set command from client:
ov2640 has byte registers!
If you click a control button on the webpage, it will send the changed control value to us.
We need to forward it to the camera.
entry:
- uri-string containing the json formatted request: fe. URI: "/reg?reg=12296&mask=255&val=2" or "/greg?reg=12296&mask=255"
exit:
  the value returned or 0=OK. no error checking!!!
*/
static uint16_t set_register(char *uri)
{
    char *pfunction, *preg, *pvalue;
    int value=-1,reg,mask,setflag=0;
    sensor_t *s;
    // get json parameters from uri
    uri++; //skip leading /
    pfunction=strtok(uri, "?"); //returns "reg" or "greg"
    strtok(NULL, "=");//returns: "reg"
    preg=strtok(NULL, "&");//  returns: "12296"
    reg=atoi(preg);
    strtok(NULL, "="); // returns: "mask",
    preg=strtok(NULL, "&");//  returns: "255"
    mask=atoi(preg);

    if (!strcmp(pfunction,"reg"))
    {
        setflag=1; // we are setting a register
        strtok(NULL, "="); // returns: "val"
        pvalue=strtok(NULL, "="); // returns: "2". didnt find '=' but returns the last string
        value=atoi(pvalue);
    }
    ESP_LOGI(TAG, "Register: %s reg=0x%02x mask=0x%02x value:0x%02x", pfunction, reg, mask, value);

    s = esp_camera_sensor_get(); // get the cameras function list

    if (setflag)
    {
        if (s->set_reg) return(s->set_reg(s,reg,mask, value)); // set register with value. mask always 0xff
    }
    else
    {
        if (s->get_reg) return(s->get_reg(s,reg,mask)); // get register with value. mask always 0xff
    }
    ESP_LOGI(TAG, "register function not supported!");
    return 0;
}


/* process a set control command from client:
This usually is used to set some parameter in the camera, or to set some functionality on the server side.
entry:
- uri-string containing the json formatted request: fe. URI: /control?var=streamlight&val=0
exit:
- 1 = OK
- 0 = fail, control not found.
-1 = set function failed.
*/
static int set_control(char *uri)
{
    char *variable, *ps;
    int value,ret;
    sensor_t *s;
    int  (*func)(sensor_t *sensor, int val)=NULL;
    // get json parameters from uri
    strtok(uri, "=&"); //goto first & or = .tell strtok to use string uri. returns: "/control?var"
    variable=strtok(NULL, "=&");// we are now at '='.  from last = find next = or & and put a /0 there. returns: "streamlight"
    strtok(NULL, "="); // returns: "val", skip it
    ps=strtok(NULL, "="); // returns: "0". didnt find '=' but returns the last string being the value
    value=atoi(ps);
    ESP_LOGI(TAG, "Control: %s = %d", variable, value);

//first check for internal commands for the server:
    ret=0;
    if (!strcmp(variable, "flashlight"))
    {
        flashlight=value;
        ret=1;
    }
    else if (!strcmp(variable, "streamlight"))
    {
        streamlight=value;
        ret=1;
    }
    else if (!strcmp(variable, "streamspeed"))
    {
        stream_speed(value);
        ret=1;
    }
    else if (!strcmp(variable, "nightmode"))
    {
        night_mode(value);
        if (value==0) streamspeed =1;
        ret=1;
    }
    else if (!strcmp(variable, "esp32reset"))
    {
        resetflag = 1;
        ret=1;
    }

    if (ret) return 1; //OK

    // its a camera setting command:
    s  = esp_camera_sensor_get(); // get the cameras function list

    if (!strcmp(variable, "framesize"))
    {
         func=(void*)s->set_framesize;
        streamspeed=1;
        nightmode=0;
        JPGerrors=DMAerrors=0; // clear errors after framesize change for better readability
    }
    else if (!strcmp(variable, "quality")) func = s->set_quality;
    else if (!strcmp(variable, "brightness")) func = s->set_brightness;
    else if (!strcmp(variable, "contrast")) func = s->set_contrast;
    else if (!strcmp(variable, "saturation")) func = s->set_saturation;
    else if (!strcmp(variable, "special_effect")) func = s->set_special_effect;
    else if (!strcmp(variable, "awb")) func = s->set_whitebal;
    else if (!strcmp(variable, "wb_mode")) func = s->set_wb_mode;
    else if (!strcmp(variable, "awb_gain")) func = s->set_awb_gain;
    else if (!strcmp(variable, "aec")) func = s->set_exposure_ctrl;
    else if (!strcmp(variable, "aec_value")) func = s->set_aec_value;
    else if (!strcmp(variable, "ae_level")) func = s->set_ae_level;
    else if (!strcmp(variable, "aec2")) func = s->set_aec2;
    else if (!strcmp(variable, "agc")) func = s->set_gain_ctrl;
    else if (!strcmp(variable, "agc_gain")) func = s->set_agc_gain;
    else if (!strcmp(variable, "gainceiling")) func = (void*)s->set_gainceiling;
    else if (!strcmp(variable, "raw_gma")) func = s->set_raw_gma;
    else if (!strcmp(variable, "lenc")) func = s->set_lenc;
    else if (!strcmp(variable, "hmirror")) func = s->set_hmirror;
    else if (!strcmp(variable, "vflip")) func = s->set_vflip;
    else if (!strcmp(variable, "colorbar")) func = s->set_colorbar;
    else if (!strcmp(variable, "wpc")) func = s->set_wpc;
    else if (!strcmp(variable, "dcw")) func = s->set_dcw;
    else if (!strcmp(variable, "bpc")) func = s->set_bpc;
    //else the function is not supported: s->function=NULL
    if (func == NULL)
    {
        ESP_LOGE(TAG,"Control not supported");
        return 0; //setting not supported by camera
    }

//call the function:
    if ((*func)(s,value) != 0)
    {
        ESP_LOGE(TAG,"Camera Control failed");
        return -1; // set value failed
    }


    return 1; // OK
}



/* get a status info from the server:
This is a new feature to deliver data to the webpage from the server like current framerate
entry:
- uri-string containing the json formatted request: fe. URI: /getstatus?var=framerate
The var identifiys the parameter requested, here its framerate.
exit:
returns the requested  data in text form. it uses global iobuf to return the response text
- 1 = OK
- 0 = fail, '-1' is returned as text to webpage

*/
static int get_status(char *uri)
{
    char *variable;
    // get json parameters from uri
    strtok(uri, "=&"); //goto first & or = .tell strtok to use string uri. returns: "/getstatus?var"
    variable=strtok(NULL, "=&");// we are now at '='.  from last = find next = or & and put a /0 there. returns: "framerate"


    ESP_LOGI(TAG, "getstatus: %s", variable);

//check 'variable' for the request parameter
    if (!strcmp(variable, "framerate"))
    {
        sprintf(iobuf,"- NetFPS:%d CamFPS:%d I2sFPS:%d - QUEerrors:%d JPGerrors:%d - UpTime(hrs):%d - Rssi:%d",NetFPS,HwFPS,I2sFPS,DMAerrors,JPGerrors,(uptime/3600), rssi);
        return 1; //OK, answer in iobuf
    }

    sprintf(iobuf,"%d",-1);
    return 0; // no parameter-name match
}



/*
get current camera settings status. To be used to init the webpage after retrieval.
exit:
returns the requested  data in text form. it uses global iobuf to return the response text
- 1 = OK
- 0 = fail
*/
static int get_camstatus(void)
{
    sensor_t *s  =  esp_camera_sensor_get(); // get the status of camera controls from camera
    if (s == NULL) return 0;
    char *p = iobuf;
    // assemlbe them into a string
    *p++ = '{';

    p += sprintf(p, "\"framesize\":%u,", s->status.framesize);
    p += sprintf(p, "\"quality\":%u,", s->status.quality);
    p += sprintf(p, "\"brightness\":%d,", s->status.brightness);
    p += sprintf(p, "\"contrast\":%d,", s->status.contrast);
    p += sprintf(p, "\"saturation\":%d,", s->status.saturation);
    p += sprintf(p, "\"sharpness\":%d,", s->status.sharpness);
    p += sprintf(p, "\"special_effect\":%u,", s->status.special_effect);
    p += sprintf(p, "\"wb_mode\":%u,", s->status.wb_mode);
    p += sprintf(p, "\"awb\":%u,", s->status.awb);
    p += sprintf(p, "\"awb_gain\":%u,", s->status.awb_gain);
    p += sprintf(p, "\"aec\":%u,", s->status.aec);
    p += sprintf(p, "\"aec2\":%u,", s->status.aec2);
    p += sprintf(p, "\"ae_level\":%d,", s->status.ae_level);
    p += sprintf(p, "\"aec_value\":%u,", s->status.aec_value);
    p += sprintf(p, "\"agc\":%u,", s->status.agc);
    p += sprintf(p, "\"agc_gain\":%u,", s->status.agc_gain);
    p += sprintf(p, "\"gainceiling\":%u,", s->status.gainceiling);
    p += sprintf(p, "\"bpc\":%u,", s->status.bpc);
    p += sprintf(p, "\"wpc\":%u,", s->status.wpc);
    p += sprintf(p, "\"raw_gma\":%u,", s->status.raw_gma);
    p += sprintf(p, "\"lenc\":%u,", s->status.lenc);
    p += sprintf(p, "\"hmirror\":%u,", s->status.hmirror);
    p += sprintf(p, "\"dcw\":%u,", s->status.dcw);
    p += sprintf(p, "\"colorbar\":%u", s->status.colorbar);
    //internal server maintained settings:
    p += sprintf(p, ",\"nightmode\":%d", nightmode);
    p += sprintf(p, ",\"streamspeed\":%d", streamspeed);
    p += sprintf(p, ",\"flashlight\":%d", flashlight);
    p += sprintf(p, ",\"streamlight\":%d", streamlight);

    *p++ = '}';
    *p++ = 0;
    return 1;
}

/* This function will set the stream fps to either fullspeed or reduced
by changing the xclk divisor value.
It actually changes the internal camera clock to lower value(slow) with the benefit, that
the camera exposure time increases and thus getting more light sensitive in darker situautions.
Also the amount of frames being transfered over the network decreases and thus gives less bandwidth load,
especially usefull if you have several of such cameras on the net.
*/
void stream_speed(int full)
{
    sensor_t *s  =  esp_camera_sensor_get(); // get the cameras function list

    if (full) // set full speed=max possible at current setting=default reset setting
    {
        s->set_reg(s,0x111,0x3f, 0x00); //about 25 fps at 640*480. set divider to 1
        streamspeed=1;
    }
    else
    {
        s->set_reg(s,0x111,0x3f, 0x02); //about 10 fps at 640*480. set divider to 2
        streamspeed=0;
    }

}

/* turn nightmode on/off
The advantage of nightmode is, that exposuretime is much longer, so you get less noise compared to
just increasing the gain, but at lower framerates.

example: 640*480 at normal constant framerate of 25fps:

if on: the framerate varys from 3 fps(dark) to 25fps(light).
	   here longer exposure times are used and exposuretime can be longer than 1 frame ie. 7frames long .
	   thus the framerate is reduced if longer exposuretimes are needed.
if off: framerate is returned to normal constant state of fe. 25 fps, also in dark, so less sensitive.
        exposuretime can only be max 1 frame then.
		NOTE: AEC and AGC must be ON for nightmode to work as its the exposure/light-control engine.
		      (AEC and AGC are working closely together!)
		      Use AE-Level to adjust to best brightness.
			  The clock is changed to full speed after nightmode usage!
*/
void night_mode(int on)
{
    sensor_t *s  =  esp_camera_sensor_get(); // get the cameras function list

    s->set_reg(s,0x111,0xff, 0x00); // first switch to full speed clock
    vTaskDelay(200/portTICK_PERIOD_MS);

    if (on) //turn on
    {
        s->set_reg(s,0x10f,0xff, 0x4b); //undocumented register!! enable extended exposuretimes by inserting dummyframes and lines.
        s->set_reg(s,0x103,0xff, 0xcf); //COM1, allow upto 7 dummyframes, allow additional lines being inserted at start/End of frame
        nightmode=1;
    }
    else //turn off, is abit complicated
    {
        s->set_reg(s,0x103,0xff, 0x0a); //COM1, only allow aditional lines at start of frame
        s->set_reg(s,0x10f,0xff, 0x43);
        s->set_reg(s,0x10f,0xff, 0x4b); //changes are taken at rising edge bit 3
        vTaskDelay(1000/portTICK_PERIOD_MS); //it needs some settle time
        s->set_reg(s,0x10f,0xff, 0x43);
        nightmode=0;
        streamspeed=1;
    }

}

// 1 sec peridic timer
void timerCallBack( TimerHandle_t xTimer )
{
	wifi_ap_record_t ap;
	
    NetFPS=NetFrameCnt;
    NetFrameCnt=0;
    HwFPS=HwFrameCnt;
    HwFrameCnt=0;
    I2sFPS=I2sFrameCnt;
    I2sFrameCnt=0;
    uptime++;
	

esp_wifi_sta_get_ap_info(&ap);
rssi= ap.rssi;

}